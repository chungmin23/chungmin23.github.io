---
layout: single
title: "java"
categories: project
tag: project
toc: true
---

## 자바 요약


*****************************************************************************
1강. Java와 객체지향 프로그래밍
*****************************************************************************

* 바이트 코드
-. Java 소스를 컴파일한 결과물(기계어는 아님. 자바 플랫폼인 자바 가상 머신에서 실행가능)
-. 확장자는 .class이며 클래스 파일이라고도 함
-. 자바 플랫폼의 Java VM에서 실행 가능한 코드
-. Write once, run anywhere.

* 자바 프로그램 = 애플리케이션(자바 플랫폼에서 실행되는 프로그램으로 실행을 위해 main() 함수가 필요) + 애플릿(HTML 웹 페이지에 포함되어 웹 브라우저를 통해 실행)
자바 언어는 플랫폼 독립적, 아키텍처 중립적임

* 애플리케이션
-. Java 플랫폼에서 실행되는 프로그램
-. 실행을 위해 main() 함수가 필요함

* 애플릿
-. HTML 웹 페이지에 포함되어 웹 브라우저를 통해 실행

* Java 플랫폼의 구성(JDK라고도 할 수 있음) = JAVA VM + JAVA API
-. Java VM
-. Java API
	: 프로그램의 개발에 필요한 클래스 라이브러리
	: 패키지(클래스 묶음)들이 계층 구조로 분류되어 있음

* Hello, World 출력
public class Test {
    public static void main(String[ ] args) {
        System.out.println("Hello, World!");
    }
}

* public class는 파일에 최대 1개

4. 객체지향 프로그래밍
1) 클래스와 객체
* 추상화(필요한 일부만을 간단히 표현하는 것)
-. 구체적인 모든 사실이 아니라 전형적이고 필요한 부분만을 발췌하여 사물을 이해하고 표현하는 것
-. 클래스(추상화를 통해 프로그램상에서 표현된 것)
	: 클래스는 객체를 만들기 위한 모형 또는 틀
	: 공통적인 특징을 가지는 객체들을 추상화하기 위한 수단
	: 객체의 상태는 필드(데이터)로, 행위는 메소드로 구현됨
	: 객체는 특정 클래스의 인스턴스(실체화된 것)

2) 객체지향 프로그램
* Java 프로그램
-. 클래스가 프로그램 구성의 기본 단위(C언어는 함수)
-. 데이터(필드)와 알고리즘(메소드)이 클래스에 캡슐화되어 있음
-. 클래스 정의로부터 객체들이 만들어지고, 객체들간의 상호작용으로 프로그램이 동작함









*****************************************************************************
2강. Java 기본 문법(1)
*****************************************************************************

* 식별자 : 클래스, 변수, 메소드, 레이블 등의 이름
대소문자 구분, 길이 제한 없음, 숫자 시작 불가, 키워드인 true, false, null 등은 불가, 공백 불가,
영 대소문자, 한글, 숫자, '_', '$' 사용 가능

* 변수 종류
인스턴스 변수 : 객체가 소유하는 변수(클래스 정의에서 static이 아닌 데이터 필드)
클래스 변수 : 객체가 공유하는 변수(클래스 정의에서 static 데이터 필드)
지역 변수 : 메소드 내부(또는 블럭 내부)에서 선언된 변수
파라미터 : 메소드 호출 시 전달하는 값을 저장하기 위한 변수

* 지역 변수와 파라미터 / 데이터 필드(인스턴스 변수 or 클래스 변수)
지역 변수는 초기값을 지정한 후 사용해야 함(데이터 필드는 초기값 지정 안 하면 기본값이 주어짐)
지역 변수 선언에서 접근 제어자를 사용하지 않음(데이터 필드에서만 접근 제어자 사용)

* 리터럴 : 실제 데이터 값

* 0b11010 : 2진수, 032 : 8진수, 0x1a : 16진수

* 기본형 변수는 저장 공간에 값 자체를 저장, 참조형(기본형을 제외한 모든 자료형) 변수는 저장 공간에 참조 값을 저장함(실제 데이터는 별도의 공간에 저장됨)

* if와 else 짝짓기 : else는 자기 짝이 없는 가장 가까운 if와 짝을 이룸

* for-each문 : 형식은 for(변수선언 : 배열) { 문장 ... }
int[] arrayOfInts = {32, 87, 3};
for (int element : arrayOfInts) {
	System.out.print(element + " ");
}

int[ ] a = {32, 87, 3, 589, 12 }; 
for (int i = 0; i < a.length ; i++)   
        System.out.print( a[i] + " " );
↓
for (int element : a)   
        System.out.print( element + " " );

* break문을 포함하는 가장 가까운 switch문, for문, while문, do-while문의 실행을 끝냄
* continue문 : 가장 가까이 있는 반복문의 다음 반복을 위한 조건식으로 즉시 제어를 이동하기 위한 것

* Java의 기본형을 나타내는 키워드는 byte, short, int, long, float, double, char, boolean의 8가지이다.
* 클래스와 배열은 대표적 참조형으로, 참조형 변수에는 참조 값(주소)이 저장된다.
* 명령행 매개변수란 main( ) 함수에 전달되는 인자로서, 프로그램을 실행시킬 때 프로그램의 이름 뒤에 나열하는 인자를 말한다.
* 제어문은 프로그램의 실행 흐름을 제어하는 문장이다.
* break문, continue문, return문은 제어문 중 점프문(분기문)에 해당한다.





*****************************************************************************
3강. Java 기본 문법(2)
*****************************************************************************

* 배열
같은 자료형의 원소를 정해진 개수만큼 가지고 있는 객체
배열의 크기는 선언 이후 배열이 초기화 또는 생성될 때 정해짐(선언할 때는 크기를 지정할 수 없음)
형식은 자료형[] 변수이름; 또는 자료형 변수이름[];

* 배열도 참조형(클래스 유형, 인터페이스 유형, 배열 등 기본형이 아닌 다른 것들) 변수이기 때문에(참조값, 즉 주소값을 가지고 있음, 배열의 경우 배열 원소가 들어가는 공간에 대한 주소값을 가지고 있음) 선언 후 실제 데이터가 들어갈 공간을 할당 받아 사용한다.

* 배열의 선언(선언할 때는 크기를 지정할 수 없음)
int[]a;
int b[];
int[][]c;
int d[][];
int[]e[];
int f[10]; -> 오류

* 배열의 초기화 : 선언과 동시에 중괄호를 이용하여 초기값을 지정(★중괄호로 배열을 초기화하는 것은 선언과 함께 수행되어야 한다.)
자동으로 메모리 공간이 확보됨
int a[] = {2, 3, 4}; -> 선언과 동시에 초기화
int anArray[][] = {{1, 2, 3},{4, 5, 6}};
int b[]; b = {5, 6, 7}; -> 오류(두 문장으로 초기화하면 오류)


* 배열 초기화 되는 것들
----------------------------------------
int[] numbers = {1, 2, 3};
----------------------------------------
int[] numbers = new int[] {1, 2, 3};
----------------------------------------
int[] numbers = new int[10];
----------------------------------------
int[] numbers = new int[3];
numbers[0] = 1;
numbers[1] = 2;
numbers[2] = 3;
----------------------------------------

* 배열 문법 틀린 것들
----------------------------------------
int[] numbers;
numbers = {1, 2, 3}; // ★중괄호로 배열을 초기화하는 것은 선언과 함께 수행되어야 한다.
----------------------------------------
int b[ ] = new int(10);
----------------------------------------
int a[10] = new int[ ];
----------------------------------------
int[5] d = {1, 2, 3, 4, 5};
----------------------------------------

* 배열의 생성 : 배열의 원소가 사용할 메모리 공간의 생성
new 연산자를 이용
배열의 크기를 정하고 메모리 공간을 확보
new 연산자는 메모리 공간을 확보한 후 그 메모리 주소값을 리턴함
원소가 숫자인 경우 0, 참조형인 경우 null로 자동 초기화
int a[] = new int[3]; -> 선언과 생성
int b[]; b = new int[10];
int anArray4[][] = new int[3][2]; -> 이 경우 new int[3][]과 같이 행 먼저 생성 후 나중에 각 열에 대해 다르게 생성작업을 할 수 있음. [3][2]와 같이 할 경우 3행 2열로 고정이지만 [3][]과 같이 하면 우선 3행이 만들어지고 각 열에 다른 개수(다른 크기로)로 원소를 넣을 수 있음

* null : 해당 참조형 변수가 어떤 객체도 참조하고 있지 않다.

* 문자열의 +연산자
System.out.println('A' + 0); -> 65(char형 A는 65로 간주됨)
System.out.println("A" + 0); -> A0(문자열의 경우는 +연산자를 사용할 때 기본형 또는 참조형 값이 문자열로 자동 형변환 된다.)

* print()나 println()은 1개 매개변수를 문자열로 바꾸어 출력함

* 표준 입력 : 키보드, 표준 출력 : 모니터(화면)

* 키보드에서 입력을 받는 Scanner 객체(키보드로 xxx yyy zzz 이렇게 공백으로 구분하고 엔터를 쳐서 입력을 하는데, 여기서 xxx, yyy, zzz를 토큰이라고 함)
System.in을 이용하여 Scanner 객체를 만들고 사용함
Scanner sc = new Scanner(System.in);
String name = sc.next(); -> String의 경우 next()를 사용

Scanner 클래스의 입력용 메소드
boolean hasNext() : 다음 단어가 있으면 true를 반환
String next() : 단어를 읽어 String으로 반환
boolean hasNextInt(), int nextInt()
boolean hasNextDouble(), double nextDouble()
boolean hasNextLine(), String nextLine() -> 한 문장으로 된 문자열을 입력 받는 것

* 클래스
class Circle {

}

* 클래스 접근 제어자
public, protected, 생략, private
비접근 제어자 : abstract(붙이면 객체 생성이 불가능한 클래스 즉, new로 객체 생성 불가. 그래도 자식 클래스에 상속이 될 수 있음), final(붙이면 부모가 될 수 없는 클래스)
public : 모든 클래스에서 사용 가능
protected : class A { class B {} }에서 class B 앞에만 붙을 수 있다.
생략 : 같은 패키지에 있는 다른 클래스에서 사용 가능(패키지 접근 수준)
private : class A { class B {} }에서 class B 앞에만 붙을 수 있다.

* 데이터 필드 접근 제어자(메소드도 마찬가지)
데이터 필드를 사용할 수 있는 범위를 제한하여 정보를 은닉
public 필드 : 모든 클래스에서 사용 가능
protected 필드 : 같은 패키지와 자식 클래스에서 사용 가능
생략 필드 : 같은 패키지에 있는 다른 클래스에서 사용 가능
private 필드 : 같은 클래스에서만 사용 가능

데이터 필드와 메소드를 멤버라고 부름

* 객체가 가지는 인스턴스 변수(객체가 생성되고 나서 만들어짐), 인스턴스 메소드(인스턴스 변수를 다루기 위한 함수)
클래스가 가지는 클래스 변수(해당 클래스의 객체들이 공유하는 변수로 데이터 값은 하나만 존재, static 변수, 정적 변수라고도 함), 클래스 메소드(클래스 변수를 이용해서 기능을 수행)

* 배열은 선언 후에 초기화 과정이나 생성의 과정을 거쳐야만 사용할 수 있다.
* ‘배열이름.length’을 사용하여 배열의 크기를 표현할 수 있다.
* 문자열 변수나 리터럴에 대해 +연산을 적용한 결과는 두 문자열이 연결된 문자열이다.
* Scanner 클래스를 이용하면 키보드나 파일로부터 편리하게 문자열(또는 기본형 값)을 입력받을 수 있다.
* 클래스를 정의할 때, 특별한 경우가 아니면 클래스의 접근 제어자로서 생략과 public만 지정할 수 있다.
* 클래스를 정의할 때, 접근 제어자가 생략된 데이터 필드는 ‘해당 클래스’와 ‘같은 패키지의 다른 클래스’에서 사용할 수 있다.

int형 변수 i와 j의 값을 각각 출력하기 위해 적당한 출력문은 무엇인가?
System.out.println( i + " " + j ); -> 정답
오답
System.out.println( i , j );
System.out.println( i + j );
System.out.println( i + ‘=’ + j ); -> 작은 따옴표로 되어 있어서









*****************************************************************************
4강. 클래스와 상속
*****************************************************************************

* 생성자 : 객체가 생성될 때 자동으로 실행되는 메소드(특별한 메소드로 임의로 호출해서 실행되는 것이 아니라 new를 통해 객체가 생성될 때만 자동 호출 됨)
객체의 필드 값을 초기화하거나 메모리 할당 등의 작업
Circle c = new Circle(5);
new : new 연산자를 이용하여 객체를 생성(메모리 할당)
Circle(5) : 생성자가 호출(데이터 필드의 초기화)
= : 객체의 참조값을 변수에 대입

* 생성자는 보통의 메소드와 정의 방법이 다름(생성자는 new로 객체를 생성할 때 자동 호출됨)
생성자 이름은 클래스 이름과 같음
반환형을 선언하지 않음
여러 생성자를 정의할 수 있음(생성자 오버로딩 : 인자의 개수와 인자의 자료형으로 구분)
접근 제어자는 보통 public

하나의 소스 파일에 있으면 컴파일 시 같은 패키지에 존재하게 된다.
class Circle {
	double r;
	public Circle(double a) {
		r = a;
	}
	public double getArea() {
		return r * r * 3.14;
	}
}

public class CircleArea {
	public static void main(String args[]) {
		Circle c = new Circle(5.0);
		System.out.println(c.r); // Circle 클래스에서 r의 접근제어자가 생략되어 있기 떄문에 사용 가능(접근제어자가 생략되면 같은 패키지의 다른 클래스에서 사용 가능)
		System.out.println(c.getArea());
	}
}

* 기본 생성자 : 인자가 없는 생성자, 디폴트 생성자(default constructor)
클래스 정의에 한 개의 생성자 정의도 없으면 컴파일러가 public Circle() {}과 같이 자동으로 만들어 줌

* ★기본 생성자와 상관없이, 자식 클래스의 생성자 정의에서 생성자 몸체의 첫 줄에 부모 생성자의 명시적 호출이 없다면 super(); 코드가 자동으로 들어감
super(); : 부모 클래스의 기본 생성자를 호출
따라서 부모 클래스에서 기본 생성자의 존재를 확인해야 함(없으면 에러)

* 클래스의 사용
클래스형 변수를 선언할 때(클래스는 객체의 자료형) : Circle c; (클래스 참조형 변수의 선언)
객체를 생성할 때 : c = new Circle();
상속받아 클래스를 정의할 때 : class CSub extends CSuper {}

* 클래스의 재사용
합성 : 기존 클래스를 새로운 클래스에서 데이터 필드의 자료형으로 사용
has-a 관계
class Line { Point begin, end; }
상속 : 기존 클래스(부모)를 사용하여 새로운 클래스(자식)를 정의
코드의 중복 작성을 줄이고 프로그램의 확장성이 좋아짐
상속은 기존 클래스를 확장 or 특화하는 것
자식 is-a 부모의 관계

* 객체의 사용
객체 변수와 점(.) 연산자를 사용하여 멤버에 접근

* static 필드
정적 필드 or 클래스 변수
클래스의 모든 객체가 공유하는 데이터
객체의 생성이 없이도 항상 사용 가능
★어떤 객체도 값을 변경할 수 있음
사용 방법은 클래스 이름.정적필드(객체변수.정적필드도 가능)

* static 메소드
정적 메소드 or 클래스 메소드
객체와 무관하게 호출되고 실행됨
★메소드 몸체에서 this를 사용할 수 없음(static 메소드는 객체와 무관하게 실행되는 메소드이므로 this와 super는 static 메소드에서 사용할 수 없다.)
static 필드와 인자를 가지고 작업함
사용 방법은 클래스이름.정적메소드()
Math.sqrt(2.0);
Integer.parseInt("120");

* final 필드
상수 데이터를 선언
선언할 때 초기값을 지정해야 함
자주 static과 함께 사용됨
final static double PI = 3.141592;

* final 메소드
자식 클래스로 상속은 가능하나 재정의 할 수 없는 메소드

* 객체 초기화
객체를 생성할 때 데이터 필드에 초기값을 지정하는 것
클래스 변수는 프로그램 시작 시에 자동 초기화됨
데이터 필드는 자동으로 초기값이 주어질 수 있음
* 순서
static 필드의 선언문에서 초기화
static 초기화 블록 실행

① non-static 필드의 선언문에서 초기화
② non-static 초기화 블록 실행
클래스 몸체 내 임의 위치에 포함
초기값 지정을 위한 코드
static 필드는 static 블록을 사용
③ 생성자 실행
class IniTest {
	int nValue = 1; // ①
	{
		nValue = 2; // ②
	}
	public IniTest() {
		nValue = 3; // ③
	}
}
-> 최종적으로 nValue 값은 3이 된다.
static 초기화 블록은 블록 앞에 static을 붙인다.

* 메소드의 signature
메소드 이름, 매개변수 리스트
메소드의 signature로 메소드 구분 가능(반환형은 제외)

* 메소드 오버로딩
인자의 개수나 인자의 자료형이 다르면 같은 이름의 메소드를 한 클래스에서 여러 개 정의할 수 있음
인자의 개수와 자료형이 정확히 일치하면 중복 정의 불가
★반환형은 구분의 기준이 아니다.
메소드를 호출할 때, 가장 가까운 매개변수 목록을 가진 메소드가 호출됨

* 클래스의 상속은 단일 상속만 가능
★인터페이스의 상속은 다중 상속 가능

* 메소드 오버라이딩
부모로부터 상속받은 메소드의 몸체를 자식 클래스에서 재정의 하는 것
★자식 입장에서 보면 부모 클래스에서 상속받은 메소드도 있는 것이고, 그것을 재정의 했다면, 재정의한 메소드도 있는 것
★오버라이딩 방법 : 메소드의 이름, 인자의 개수와 자료형, 반환형이 같은 메소드를 정의
★반환형은 서브 타입(상속 관계에서 자식 클래스)도 가능함
★접근 제어자의 가시성(접근 범위)은 같거나 커져야 함
protected인 경우 protected 또는 public, public인 경우 public만 가능

* this
메소드 호출 시, 숨은 인자로 this가 메소드에 전달됨
this는 현재 객체에 대한 참조값을 가지고 있음(c1.display()과 c2.display()의 결과가 다른 이유임)
★인스턴스 메소드나 생성자에서만 사용 가능(static 메소드는 객체와 무관하게 실행되는 메소드이므로 this와 super는 static 메소드에서 사용할 수 없다.)

* super
this와 같으나 자료형이 부모 클래스 유형임
자식 클래스의 인스턴스 메소드나 생성자에서 사용됨(this와 마찬가지로 static 메소드에서 사용 불가)
부모 클래스에서 오버라이딩 당한 메소드를 호출하거나 상속되었으나 감춰진 필드에 접근할 때 필요
super.메소드(인자)
super.필드
★아래의 경우 CSub에는 x가 2개임
class CSuper {
	public double x;
}
class CSub extends CSuper {
	public double x;
	public CSub(double new_x) {
		this.x = new_x; // 이 경우 CSub의 x를 가리키며, this는 생략 가능
		super.x = new_x * 10; // 이 경우 CSuper의 x를 가리킴
	}
	public double getSupter() {
		return super.x;
	}
	public double getSub() {
		return this.x;
	}
}
public class ThisSuperTest {
	public static void main(String args[]) {
		CSub sub = new CSub(10.0);
		System.out.println(sub.x); // 10 출력
		System.out.println(sub.getSuper());
		System.out.println(sub.getSub());
	}
}
★★★ Super sup = new Sub();에서
메소드 실행은 동적 바인딩에 의해 변수(sup)가 참조하는 실객체의 유형(Sub)이 가지고 있는 메소드를 실행한다는 것이고, 변수의 경우는 정적 바인딩에 의해 참조 변수의 선언 유형(Super)이 가지고 있는 변수를 참조하게 된다.
★★★★ 데이터필드는 선언유형만 봄
동적 바인딩(Dynamic Binding)
다형성을 사용하여 메소드를 호출할 때, 발생하는 현상이다.
실행 시간(Runtime) 즉, 파일을 실행하는 시점에 성격이 결정된다.
실제 참조하는 객체는 서브 클래스이니 서브 클래스의 메소드를 호출한다.
정적 바인딩(Static Binding)
컴파일(Compile) 시간에 성격이 결정된다.
변수의 타입이 수퍼 클래스이니 수퍼 클래스의 메소드를 호출한다.
★위에서 CSuper sub = new CSub(10.0); 으로 할 경우 아래에서 100 출력
sub가 데이터 유형이 CSuper 유형으로 되어 있기 때문에 sub 변수가 실제로 가리키는 객체가 new CSub()로 인해 자식 객체를 만들어 놓고 그것을 포인팅 하고 있더라도, sub.x와 같이 데이터 필드에 접근하게 될 때는 sub의 선언 유형인 CSuper에서 정의되어 있는 x값을 출력하게 된다.(100)
sub.getSuper()는 컴파일 시 sub의 선언 유형이 CSuper이기 때문에 CSuper에서 getSuper를 호출할 수 있는가를 체크하는데, CSuper에 getSuper 메소드가 없기 때문에 컴파일 오류가 난다.

* ()는 메소드 선언 혹은 호출과 관련있는 것
★this() : 같은 클래스의 다른 생성자를 호출하는 것(생성자가 여러 개 있을 때, 어떤 생성자에서 다른 생성자를 이용해서 데이터를 초기화할 때 다른 생성자를 호출)
super() : 부모 클래스의 생성자를 호출하는 것
★상속받은 데이터 필드를 초기화하기 위한 것(상속받은 데이터 필드를 초기화 할 때는 부모 클래스에 있는 생성자를 이용해서 초기화해야함)
생성자 몸체에서 부모 클래스 생성자의 명시적 호출이 없다면, 인자가 없는 생성자인 super()가 자동 호출됨
★this(), super() 둘 다 생성자 몸체의 첫 번째 문장에서만 사용 가능

Circle 클래스에 radius 데이터 필드가 있다고 가정하고 아래 코드를 보자.
아래의 두 Cylinder 생성자에서 할 일은 데이터 필드 height와 radius를 초기화하는 것
그래서 Cylinder()에서는 Circle 클래스의 기본 생성자에서 정의된대로 radius를 초기화 할 것이고, Cylinder (double radius, double h)에서는 인자로 받은 radius와 super(radius)를 통해 radius가 초기화 될 것임
public class Cylinder extends Circle{
	private double height;
	public Cylinder() {
		super();
		height=1.0;
	}
	public Cylinder (double radius, double h) {
		super(radius);
		this.height =h;
	}
	public double getHeight() {
		return height;
	}
	public void setHeight(doubleh ){
		this.height =h;
	}

	public double getArea() {
		return2 * PI * getRadius() * height + 2 * super.getArea();
		// 여기서 getRadius()는 this.getRadius()의 축약형
		// getArea()는 오버라이딩한 것이고 super.getArea()가 아닌 this.getArea()면 자기 자신을 호출하는 것이기 때문에 부모의 getArea()를 호출하도록 super.getArea()가 쓰임
	}
	public double getVolume() {
		return super.getArea() * height;
	}
	public String toString() {
		return "Cylinderofradius=" + getRadius()+ "height=" + height;
		// 여기서 getRadius()는 this.getRadius()의 축약형
	}
}

* 생성자를 정의하려면 이름을 클래스 이름과 같게 하고 반환형을 지정하지 않는다.
* 클래스 정의에 있는 데이터 필드의 선언문, 초기화 블록, 생성자를 통해서 객체 생성 시 필요한 데이터 필드의 초기 값을 지정할 수 있다.
* 클래스를 정의할 때, 객체마다 각각 데이터가 필요하면 인스턴스 변수(non-static 데이터 필드)로, 모든 객체가 공유하는 데이터는 static 데이터 필드로 정의한다.
* 메소드 오버로딩이란 한 클래스에서 이름이 같은 여러 메소드가 존재하는 상황을 말한다. 이때 오버로딩된 메소드끼리는 매개변수 목록이 달라 구별될 수 있다.
* 부모로부터 상속받은 메소드의 몸체를 자식 클래스에서 다시 정의하는 것을 메소드 오버라이딩이라 한다.
* 인스턴스 메소드와 생성자에서 숨은 인자인 this와 super를 사용할 수 있다.






*****************************************************************************
5강. 인터페이스와 다형성
*****************************************************************************

* 추상 메소드
메소드 선언에 abstract 키워드를 사용함
몸체의 구현이 없이 형식만 존재
자식 클래스에 상속될 때 몸체의 구현이 필요
final과 함께 사용 불가
추상 메소드를 가진 클래스는 추상 클래스 혹은 인터페이스여야만 함
abstract public class Shape {
	abstract public double getArea();
}

* 추상 클래스(반대 의미가 구체 클래스, 일반 클래스)
클래스 정의에 abstract 키워드를 사용함
★데이터 필드나 일반 메소드를 포함할 수 있음
★객체 생성을 할 수 없음(구체적이지 못한 불완전한 클래스라는 의미)

* 추상 클래스의 사용
★의미적으로 유사한 클래스(의미적으로 유사한 클래스는 자식 클래스가 됨)들을 묶고자 할 때 사용(하나의 추상 클래스 아래에 의미적으로 유사한 클래스들을 자식으로 둠, 의미적으로 비슷하기 때문에 자식들이 공통으로 사용할 데이터 필드와 메소드를 부모 추상 클래스에 정의해둔다.)
도형이란 부모 추상 클래스가 있고, 그 안에 면적을 구하는 추상 메소드가 있다고 할 때, 자식 클래스(삼각형, 사각형 등)에서 각 면적을 구하는 메소드를 구현하여 사용한다.
공통으로 사용할 데이터 필드와 메소드를 정의
추상 클래스는 일반 클래스와 인터페이스의 중간적 성격을 가짐(추상 클래스보다 더 추상적인게 인터페이스)
(기능적으로 유사한 것은 인터페이스)

* 인터페이스(abstract는 생략하는 것이 보통임(abstract interface인데 interface만 씀. ★interface 소문자인 것 주의)
100% 추상적 클래스
★인터페이스의 모든 메소드는 추상 메소드(public abstract, 생략 가능, 각각도 생략 가능)
★단, 몸체가 구현된 default 메소드와 static 메소드도 포함 가능, 접근 제어자는 public(생략 가능)
★모든 메소드의 기본 접근 제어자는 public
★★★데이터 필드는 클래스 상수만 가능(public static final, 생략 가능) -> 객체 생성 없이 참조할 수 있는 데이터 필드만 가능(객체를 생성할 수 없으니 클래스 상수만 가능한듯)
참조 자료형이며 직접적 객체 생성은 불가(추상 클래스보다 더 추상적인게 인터페이스)
인터페이스의 이름은 보통 형용사(Runnable, Serializable, Comparable)

* 인터페이스의 사용
추상 클래스와 마찬가지로 자식 클래스에 상속되어 사용됨
인터페이스를 구현하는 자식 클래스는 모든 추상 메소드를 구현해 주어야 함
★의미적으로는 관련이 없으나 기능적으로 유사한 클래스들을 묶을 때 인터페이스를 사용할 수 있음
사각형 클래스, 운동 선수 클래스, TV 클래스, 아파트 클래스 -> 의미적으로는 관련 없지만 크기 비교가 가능하다는 클래스로 볼 수 있음. 부모 인터페이스에 comparable과 같이 대소비교가 가능한 추상 메소드를 둘 수 있음
인터페이스를 상속받아 자식 인터페이스를 정의할 수 있음 -> 인터페이스의 상속(또는 확장)

* 인터페이스의 상속(자식 인터페이스가 부모 인터페이스를 상속받는 경우)
인터페이스를 상속받아 인터페이스를 정의할 때 키워드 extends를 사용
★★여러 인터페이스를 상속받는 다중 상속도 가능(콤마로 구분)
★interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2
★인터페이스가 부모 역할을 할 때는 다중 상속이 가능
* 인터페이스의 구현(자식 클래스가 부모 인터페이스를 상속받는 경우)
자식은 부모가 나열한 기능(추상 메소드)을 구현해야 함
구현을 통해 클래스를 정의할 때 implements를 사용
class 자식클래스 extends 부모클래스 implements 부모인터페이스1, 부모인터페이스2

* 상속과 인터페이스의 차이점은 강제성의 유무
인터페이스는 implments를 선언하고 구현을 하지 않으면 오류가 남
상속은 오버라이딩을 해서 구현을 해도 그만 안 해도 그만

interface Movable{
	void moveUp(); // ★public abstract 생략되어 있음
	void moveDown(); // ★public abstract 생략되어 있음
	void moveLeft(); // ★public abstract 생략되어 있음
	void moveRight(); // ★public abstract 생략되어 있음
}
public class MovableTest {
	public static void main(String[]args) {
		Movable m1 = new MovablePoint(5,5); // ★인터페이스 Movable 유형으로 선언
		System.out.println(m1); // ★자동으로 m1.toString()이 호출된다.
		m1.moveUp();
		System.out.println(m1);
		m1.moveRight();
		System.out.println(m1);
	}
}

class MovablePoint implements Movable {
	private int x,y;
	public Movable Point(intx,inty) {
		this.x =x;
		this.y =y;
	}
	public String toString() {
		return "Pointat("+x+","+y+")";
	}
	public voidmoveUp(){y++;}
	public voidmoveDown(){y--;}
	public voidmoveLeft(){x--;}
	public voidmoveRight(){x++;}
}

* 디폴트 메소드
인터페이스에서 선언하는 메소드에 기본 구현을 넣을 수 있음
자식 클래스에서 상속받을 때 디폴트 메소드를 그대로 사용하거나 몸체를 다시 정의해 줄 수 있음
메소드 선언시 default를 사용하고 몸체를 구현해 줌
★인터페이스에 나열된 기능을 확장할 때 기존 코드의 수정을 피하기 위함
★단순히 추상 메소드가 추가된다면 이전 인터페이스를 구현한 클래스 모두를 수정해야 함
interface DoIt {
	void doSomething();
	int doSomethingElse(String s);
	// ★시간이 한참 지난 뒤 추상 메소드가 추가된다면 이전 인터페이스를 구현한 클래스 모두를 수정해야 함. 그래서 아래와 같이 기본몸체가 구현된 default 메소드를 추가하여 원하는 곳에서만 아래 메소드를 재정의하면 됨
	default boolean didItWork(int i, String s) {
	}
}

* 추상 클래스, 인터페이스, 클래스의 형변환
인터페이스와 클래스는 모두 사용자 정의형(사용자 자료유형)
상위 유형의 변수는 하위 객체의 참조값을 가질 수 있음
상위 유형의 변수가 가리키는 객체의 실제 유형에 따라 수행되는 메소드가 결정됨(동적 바인딩, 동적 바인딩은 실행 시점에 결정됨)
메소드 호출 시 변수의 선언 유형으로 정하지 않음
★SuperClass super = new SubClass(); // 업캐스팅
super.method(); // SubClass에서 찾음
★★★ Super sup = new Sub();에서
메소드 실행은 동적 바인딩에 의해 변수(sup)가 참조하는 실객체의 유형(Sub)이 가지고 있는 메소드를 실행한다는 것이고, 변수의 경우는 정적 바인딩에 의해 참조 변수의 선언 유형(Super)이 가지고 있는 변수를 참조하게 된다.

* 다형성과 형변환
상속 관계에 있는 클래스 간에는 타입 변환이 가능
Animal animal = (animal)new Dog(); // (animal) 생략 가능

class A { 
	public void func( ) {
		System.out.println(“a”); 
	}
}
class B extends A {
	public void func( ) {
		System.out.println(“b”);
	}
}
class C extends B {
	public void func( ) {
		System.out.println(“c”);
	}
}

public class PolymorphTest {
	public static void main(String args[ ]) {
		A a = new B( );
		a.func( ); // ★실행 시점에 B를 가리키고 있기 때문에 class B에서 func()
		a = new C( );
		a.func( ); // ★실행 시점에 C를 가리키고 있기 때문에 class C에서 func()
	}
}

위의 결과는 b, c인데, 만약 class C에 func()가 없으면 c가 아닌 b가 답이다.
★컴파일 시점에 class A에 func()가 없다면 컴파일 오류가 남
★컴파일 시점에는 a.func( ); 시 선언 유형을 봄. A a = new B( ); 그래서 선언 유형이 A이기 때문에 A에 func()가 있어야 함
★★컴파일할 때는 선언 유형을 보고 거기에 해당 메소드가 있는지 확인을 하고, 문제가 없으면 넘어간다. 실행할 때는 실유형을 본다.
★★★★ 데이터필드는 선언유형만 봄

* 열거형 정의
열거형은 미리 정의된 상수값을 만들기 위한 자료형
enum을 사용하여 정의
열거형으로 선언된 변수에는 미리 지정된 값만 대입 가능
상수값을 배열로 리턴하는 static 메소드로 values()를 제공
Enum Day {
	SUNDAY, MONDAY, TUESDAY
}
// main 함수에서
Day day = Day.MONDAY;
for (Day d : Day.values()) {
	System.out.println(d);
}

* 열거형의 생성자와 메소드
열거형 정의에 필드와 메소드를 포함할 수 있음
상수 선언이 필드나 메소드보다 먼저 정의되어야 하며 세미콜론(;)으로 끝나야 함
생성자는 열거형과 같은 이름을 가지며 접근 제어자는 생략 또는 private이어야 함
열거형에서 상수값은 마치 하나의 객체와 같음
열거형의 생성자는 상수값을 설정(객체 생성)할 때 자동 호출됨

enum BaseballTeam {
	LG(40, 30), SS(30, 40), KT(20, 50), 
	SK(35, 35), NC(55, 15); // 세미콜론으로 끝남

	private final int win;
	private final int lose;

	private BaseballTeam(int win, int lose) {
		this.win = win;
		this.lose = lose;
	}
	public double winsRate( ) { 
		return (win * 100.0) / (win + lose); 
	}
}

public class EnumTest2 {
	public static void main(String args[ ]) {                       
		BaseballTeam bt = BaseballTeam.LG; // ★enum BaseballTeam에서 LG를 찾아가면 LG(40, 30) 이렇게 괄호가 있기 때문에 생성자가 호출되고 생성자를 통해 데이터 필드가 초기화 된다.
		System.out.println(bt.winsRate( ));
	}
}

* 익명 클래스
일회성으로 1개의 객체를 생성하기 위한 클래스
클래스 정의와 동시에 객체를 생성할 수 있음
슈퍼 클래스를 상속받거나 인터페이스를 구현하도록 익명 클래스를 정의함
new 슈퍼클래스() {...} // 여기서 {...} 이게 익명 클래스 정의고, 슈퍼클래스를 부모로 하는, 즉, 슈퍼클래스를 상속받는 익명클래스 정의(슈퍼클래스의 자식 객체 생성. 앞에 new가 있으므로)
new 인터페이스() {...} // 인터페이스를 구현하는 자식 객체 생성 
★CSuper sub = new CSuper( ) {  } ; 의미 : CSuper를 상속받는 익명 클래스를 정의하고, 동시에 객체를 생성한다.

★53분(동적바인딩, 정적바인딩)

* 몸체가 없는 메소드를 추상 메소드라고 하고, 추상 메소드를 하나라도 가지고 있는 클래스는 추상 클래스이어야 한다.
* 인터페이스는 추상 메소드로만 구성된다. 단, default 메소드와 static 메소드는 몸체가 있어야 한다.
* 의미적으로 유사한 클래스를 묶을 때는 추상 클래스로, 기능적으로 유사한 클래스를 묶을 때는 인터페이스를 사용한다.
* 다형성은 메소드 오버라이딩과 오버로딩, 클래스 간 상속과 형변환, 인터페이스의 구현과 형변환, 메소드 동적 바인딩을 통해 구현될 수 있다.
* 열거 자료형은 여러 상수값을 미리 정의하기 위한 자료형이며, 각 상수값은 하나의 객체와 같다.
* 익명 클래스는 이름이 없는 클래스로, 일회성으로 객체를 생성하는 용도로만 사용되는 클래스를 의미한다.






*****************************************************************************
6강. 제네릭과 람다식
*****************************************************************************

* 제네릭 : 캐스트(형변환) 연산자의 사용 불필요
class ArrayList<E> implements List<E> { // ArrayList를 사용할 때, 즉, ArrayList 유형으로 변수 선언을 하거나, 객체 생성을 할 때 <E> 여기다가 자료형을 전달해 줘야 한다는 의미(타입 매개변수(타입 파라미터)를 전달해 줘야 한다.) -> 예를 들어 Integer가 전달되면 E 부분이 Integer가 된다.
	boolean add(E e) {}
	E get(int index) {}
	E remove(int index) {}
}

List list1 = new ArrayList(); // ★ArrayList에서 관리되는 원소 하나하나를 Object 유형으로 보면 됨
list1.add("hello"); // ★hello가 Object 유형으로 자동형변환(업캐스팅)되서 add된다.
String s1 = (String)list1.get(0); // ★형변환 필요(get할 경우 Object 유형으로 return이 되기 때문에 문자열 변수에 대입하려면 String으로의 형변환(다운캐스팅)이 필요한 것이다.)

List<String> list2 = new ArrayList<String>(); // ★문자열을 원소로 하는 ArrayList 객체가 만들어짐
list2.add("hello");
String s2 = list2.get(0); // ★형변환 불필요

* 제네릭 클래스
클래스 정의에서 타입 파라미터를 선언함
클래스를 사용할 때는 타입을 명시해야함
타입 파라미터는 참조형만 가능
★필드의 자료형, 메소드 반환형, 인자의 자료형으로 사용할 수 있음

* 제네릭 클래스 필요성
제네릭 타입을 사용하지 않으면 컴파일 시점에서 오류를 검출하지 못함
★의미가 명확하면 생성자 호출 시 괄호만 사용할 수 있음
Data2<String> b3 = new Data2<>();
Pair<String, Integer> p1;
p1 = new OrderedPair<>("Even", 8);

* 제네릭 인터페이스를 구현하는 제네릭 클래스
interface Pair<K, V> {
	public K getKey();
	public V getValue();
}

class OrderedPair<K, V> implements Pair<K, V> {
	...
}

* 제네릭 타입을 상속/구현하는 일반 클래스
제네릭 인터페이스를 구현하는 일반 클래스 : 클래스를 정의할 때 제네릭 인터페이스의 <> 안에 자료형을 지정하면 됨
class MyPair implements Pair<String, Integer> {
	private String key;
	private Integer value;
	public MyPair(String key, Integer value) {
		this.key = key;
		this.value = value;
}

* Raw타입
제네릭 타입이지만 일반 타입처럼 사용하는 경우, 제네릭 타입을 지칭하는 용어
타입 매개변수 없이 사용되는 제네릭 타입
자료형을 Object로 처리함
Data2 data = new Data2("hello");
이 때 Data2는 제네릭 타입 Data2<T>의 raw 타입

* 제네릭 메소드
자료형을 매개변수로 가지는 메소드
하나의 메소드 정의로 여러 유형의 데이터를 처리할 때 유용
메소드 정의에서 반환형 왼편에 각괄호<> 안에 타입 매개변수 표시
타입 매개변수를 메소드의 반환형이나 메소드의 매개변수의 자료형, 지역 변수의 자료형으로 사용 가능
public static <T> T getLast(T[] a) {
	return a[a.length-1];
}
인스턴스 메소드와 static 메소드 모두 제네릭 메소드로 정의 가능
★제네릭 메소드를 호출할 때 타입을 명시하지 않아도 인자에 의해 추론이 가능(생략 가능하다는 말)
class Util {
	public static<K,V>boolean compare(Pair<K, V> p1,Pair<K, V> p2) {
		return p1.getKey().equals(p2.getKey())&&p1.getValue().equals(p2.getValue());
	}
}

public class GenericsTest5 {
	public static void main(Stringargs[]) {
		Pair<Integer, String> p1 = new OrderedPair<>(1,"apple"); // ★ <>처럼 생략됨
		Pair<Integer, String> p2=new OrderedPair<>(2,"pear");
		boolean same=Util.<Integer,String>compare(p1, p2); // ★★여기서 <Integer,String> 생략 가능(p1, p2를 추적해보면 Pair<Integer, String> 유형이니)
		System.out.println(same);
	}
}

* 제네릭의 타입 제한
자료형을 매개변수화하여 클래스/인터페이스/메소드를 정의할 때 적용가능한 자료형에 제한을 두는 것
★<T extends Number>와 같이 하면 Number를 상한으로 정할 수 있음
T에 주어지는자료형은Number의서브 클래스라야함

* 제네릭 타입과 형변환
★Integer나 Double은 Number와 상관관계가 있지만, Data<Number>와 Data<Integer>는 상하위 관계가 없음
class Data<T> {}
class FormatterdData<T> extends Data<T> {} // 상속 관계

public class GenericTypeConversion1 {
	public static void main(String args[]) {
		Data<Number>data=new Data<Number>();
		data.set(new Integer(10)); // ★OK 여기서 set 메소드에 Number 유형이 들어가야하는데 Integer나 밑에 Double은 Number의 자식 유형이기 때문에 Integer나 밑에 Double이 업캐스팅이 됨
		data.set(new Double(10.1)); // OK
		Data<Number>data1=new Data<Integer>(); // 컴파일 오류. 여기서 Data<Integer>가 Data<Number> 유형으로 형변환되어야 하는데 서로 관계가 없으므로 오류
		Data<Integer>data=new FormattedData<Integer>();
	}
}

* 제네릭 타입 사용 시 유의사항
기본 자료형은 타입 매개변수로 지정할 수 없음
Data<int>d=new Data<>(); // 오류
타입 매개변수로 객체 생성을 할 수 없음
class Data<T> {private Tt1=new T();} // 오류
타입 매개변수의 타입으로 static 데이터 필드를 선언할 수 없음(static 필드는 모든 객체가 공유하는 하나의 변수이기 때문)
class Data<T>{private static T t2;} // 오류
제네릭 타입의 배열을 선언할 수 없음
Data<Integer>[]arrayOfData; // 오류

* ★람다식 : 인터페이스를 구현하는 익명 클래스의 객체 생성 부분을 수식화 한 것
구현할 것이 1개의 추상 메소드 뿐일 때 간단히 표현할 수 있음
람다식 구문은 메소드 매개변수의 괄호, 화살표, 메소드 몸체로 표현
인터페이스 객체변수 = (매개변수 목록) -> {실행문 목록};
Runnable runnable = new Runnable() {
	public void run() {...}
};
위가 아래로 바뀔 수 있다.
Runnable runnable = () -> {...};
위에서 Runnable을 타겟 타입이라고 함
1개의 추상 메소드를 포함하는 인터페이스를 함수적 인터페이스라고 함(default, static 메소드는 고려하지 말자)

인터페이스 객체변수 = (매개변수목록)->{실행문목록 };
매개변수 목록에서 자료형은 인터페이스(타깃 타입) 정의에
서 알 수 있으므로 자료형을 생략하고 변수 이름만 사용 가능
매개변수가1개면 괄호도 생략 가능하며변수 이름 하나만 남음
매개변수를 가지지 않으면 괄호만 남음
화살표 사용
실행문 목록에서 실행문이 1개이면 중괄호 생략 가능
★실행문이 return문 뿐이라면 return과 세미콜론, 중괄호를 동시 생략해야 하고 1개의 수식만 남게 됨

* 패키지 java.util.function에서 표준 함수적 인터페이스가 제네릭 인터페이스로 제공됨
★★★표준 함수적 인터페이스의 예(리턴하는게 없으면, 즉 void면 실행문이 있음)
Consumer<T>는 void accept(T t)를 가짐(받기만 하고 return은 없음)
u Supplier<T>는 T get() 메소드를 가짐(받는건 없는데 return은 있음)
u Function<T,R>은 R apply(T t)를 가짐(하나를 받아서 하나를 return)

★아래와 같은 인터페이스가 있다고 가정할 때, 보기에서 람다식 사용이 잘못된 것은?
interface Addable {
        int add(int a, int b);
}
Addable ad = (int a, int b) -> { return (a + b); };
Addable ad = (a, b) -> { return (a + b); };
Addable ad = (a, b) -> (a + b);
아래 보기가 잘못된 것(★★★실행문이 return문 뿐이라면 return과 세미콜론, 중괄호를 동시 생략해야 하고 1개의 수식만 남게 됨)
Addable ad = (int a, int b) -> return (a + b);

* ★6강 40분부터 다시보기

* 자료형을 매개변수로 가지는 클래스와 인터페이스를 제네릭 타입이라고 한다.
* 제네릭 클래스를 사용할 때 제공되는 타입 파라미터는 필드의 자료형, 메소드의 반환형, 인자의 자료형으로 사용될 수 있다.
* 자료형을 매개변수로 가지는 메소드를 제네릭 메소드라고 한다.
* 제네릭을 활용하면 컴파일 시점에 명확한 자료형 검사를 수행할 수 있다.
* 함수적 인터페이스를 구현하는 클래스의 객체를 생성할 때 람다식을 사용하는 것이 효율적이다.
* 람다식의 실행 결과가 대입되는 인터페이스를 람다식의 타깃 타입이라고 한다.







