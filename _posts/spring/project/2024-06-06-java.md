---
layout: single
title: "java"
categories: project
tag: project
toc: true
---

## 자바 요약


*****************************************************************************
1강. Java와 객체지향 프로그래밍
*****************************************************************************

* 바이트 코드
-. Java 소스를 컴파일한 결과물(기계어는 아님. 자바 플랫폼인 자바 가상 머신에서 실행가능)
-. 확장자는 .class이며 클래스 파일이라고도 함
-. 자바 플랫폼의 Java VM에서 실행 가능한 코드
-. Write once, run anywhere.

* 자바 프로그램 = 애플리케이션(자바 플랫폼에서 실행되는 프로그램으로 실행을 위해 main() 함수가 필요) + 애플릿(HTML 웹 페이지에 포함되어 웹 브라우저를 통해 실행)
자바 언어는 플랫폼 독립적, 아키텍처 중립적임

* 애플리케이션
-. Java 플랫폼에서 실행되는 프로그램
-. 실행을 위해 main() 함수가 필요함

* 애플릿
-. HTML 웹 페이지에 포함되어 웹 브라우저를 통해 실행

* Java 플랫폼의 구성(JDK라고도 할 수 있음) = JAVA VM + JAVA API
-. Java VM
-. Java API
	: 프로그램의 개발에 필요한 클래스 라이브러리
	: 패키지(클래스 묶음)들이 계층 구조로 분류되어 있음

* Hello, World 출력
public class Test {
    public static void main(String[ ] args) {
        System.out.println("Hello, World!");
    }
}

* public class는 파일에 최대 1개

4. 객체지향 프로그래밍
1) 클래스와 객체
* 추상화(필요한 일부만을 간단히 표현하는 것)
-. 구체적인 모든 사실이 아니라 전형적이고 필요한 부분만을 발췌하여 사물을 이해하고 표현하는 것
-. 클래스(추상화를 통해 프로그램상에서 표현된 것)
	: 클래스는 객체를 만들기 위한 모형 또는 틀
	: 공통적인 특징을 가지는 객체들을 추상화하기 위한 수단
	: 객체의 상태는 필드(데이터)로, 행위는 메소드로 구현됨
	: 객체는 특정 클래스의 인스턴스(실체화된 것)

2) 객체지향 프로그램
* Java 프로그램
-. 클래스가 프로그램 구성의 기본 단위(C언어는 함수)
-. 데이터(필드)와 알고리즘(메소드)이 클래스에 캡슐화되어 있음
-. 클래스 정의로부터 객체들이 만들어지고, 객체들간의 상호작용으로 프로그램이 동작함









*****************************************************************************
2강. Java 기본 문법(1)
*****************************************************************************

* 식별자 : 클래스, 변수, 메소드, 레이블 등의 이름
대소문자 구분, 길이 제한 없음, 숫자 시작 불가, 키워드인 true, false, null 등은 불가, 공백 불가,
영 대소문자, 한글, 숫자, '_', '$' 사용 가능

* 변수 종류
인스턴스 변수 : 객체가 소유하는 변수(클래스 정의에서 static이 아닌 데이터 필드)
클래스 변수 : 객체가 공유하는 변수(클래스 정의에서 static 데이터 필드)
지역 변수 : 메소드 내부(또는 블럭 내부)에서 선언된 변수
파라미터 : 메소드 호출 시 전달하는 값을 저장하기 위한 변수

* 지역 변수와 파라미터 / 데이터 필드(인스턴스 변수 or 클래스 변수)
지역 변수는 초기값을 지정한 후 사용해야 함(데이터 필드는 초기값 지정 안 하면 기본값이 주어짐)
지역 변수 선언에서 접근 제어자를 사용하지 않음(데이터 필드에서만 접근 제어자 사용)

* 리터럴 : 실제 데이터 값

* 0b11010 : 2진수, 032 : 8진수, 0x1a : 16진수

* 기본형 변수는 저장 공간에 값 자체를 저장, 참조형(기본형을 제외한 모든 자료형) 변수는 저장 공간에 참조 값을 저장함(실제 데이터는 별도의 공간에 저장됨)

* if와 else 짝짓기 : else는 자기 짝이 없는 가장 가까운 if와 짝을 이룸

* for-each문 : 형식은 for(변수선언 : 배열) { 문장 ... }
int[] arrayOfInts = {32, 87, 3};
for (int element : arrayOfInts) {
	System.out.print(element + " ");
}

int[ ] a = {32, 87, 3, 589, 12 }; 
for (int i = 0; i < a.length ; i++)   
        System.out.print( a[i] + " " );
↓
for (int element : a)   
        System.out.print( element + " " );

* break문을 포함하는 가장 가까운 switch문, for문, while문, do-while문의 실행을 끝냄
* continue문 : 가장 가까이 있는 반복문의 다음 반복을 위한 조건식으로 즉시 제어를 이동하기 위한 것

* Java의 기본형을 나타내는 키워드는 byte, short, int, long, float, double, char, boolean의 8가지이다.
* 클래스와 배열은 대표적 참조형으로, 참조형 변수에는 참조 값(주소)이 저장된다.
* 명령행 매개변수란 main( ) 함수에 전달되는 인자로서, 프로그램을 실행시킬 때 프로그램의 이름 뒤에 나열하는 인자를 말한다.
* 제어문은 프로그램의 실행 흐름을 제어하는 문장이다.
* break문, continue문, return문은 제어문 중 점프문(분기문)에 해당한다.





*****************************************************************************
3강. Java 기본 문법(2)
*****************************************************************************

* 배열
같은 자료형의 원소를 정해진 개수만큼 가지고 있는 객체
배열의 크기는 선언 이후 배열이 초기화 또는 생성될 때 정해짐(선언할 때는 크기를 지정할 수 없음)
형식은 자료형[] 변수이름; 또는 자료형 변수이름[];

* 배열도 참조형(클래스 유형, 인터페이스 유형, 배열 등 기본형이 아닌 다른 것들) 변수이기 때문에(참조값, 즉 주소값을 가지고 있음, 배열의 경우 배열 원소가 들어가는 공간에 대한 주소값을 가지고 있음) 선언 후 실제 데이터가 들어갈 공간을 할당 받아 사용한다.

* 배열의 선언(선언할 때는 크기를 지정할 수 없음)
int[]a;
int b[];
int[][]c;
int d[][];
int[]e[];
int f[10]; -> 오류

* 배열의 초기화 : 선언과 동시에 중괄호를 이용하여 초기값을 지정(★중괄호로 배열을 초기화하는 것은 선언과 함께 수행되어야 한다.)
자동으로 메모리 공간이 확보됨
int a[] = {2, 3, 4}; -> 선언과 동시에 초기화
int anArray[][] = {{1, 2, 3},{4, 5, 6}};
int b[]; b = {5, 6, 7}; -> 오류(두 문장으로 초기화하면 오류)


* 배열 초기화 되는 것들
----------------------------------------
int[] numbers = {1, 2, 3};
----------------------------------------
int[] numbers = new int[] {1, 2, 3};
----------------------------------------
int[] numbers = new int[10];
----------------------------------------
int[] numbers = new int[3];
numbers[0] = 1;
numbers[1] = 2;
numbers[2] = 3;
----------------------------------------

* 배열 문법 틀린 것들
----------------------------------------
int[] numbers;
numbers = {1, 2, 3}; // ★중괄호로 배열을 초기화하는 것은 선언과 함께 수행되어야 한다.
----------------------------------------
int b[ ] = new int(10);
----------------------------------------
int a[10] = new int[ ];
----------------------------------------
int[5] d = {1, 2, 3, 4, 5};
----------------------------------------

* 배열의 생성 : 배열의 원소가 사용할 메모리 공간의 생성
new 연산자를 이용
배열의 크기를 정하고 메모리 공간을 확보
new 연산자는 메모리 공간을 확보한 후 그 메모리 주소값을 리턴함
원소가 숫자인 경우 0, 참조형인 경우 null로 자동 초기화
int a[] = new int[3]; -> 선언과 생성
int b[]; b = new int[10];
int anArray4[][] = new int[3][2]; -> 이 경우 new int[3][]과 같이 행 먼저 생성 후 나중에 각 열에 대해 다르게 생성작업을 할 수 있음. [3][2]와 같이 할 경우 3행 2열로 고정이지만 [3][]과 같이 하면 우선 3행이 만들어지고 각 열에 다른 개수(다른 크기로)로 원소를 넣을 수 있음

* null : 해당 참조형 변수가 어떤 객체도 참조하고 있지 않다.

* 문자열의 +연산자
System.out.println('A' + 0); -> 65(char형 A는 65로 간주됨)
System.out.println("A" + 0); -> A0(문자열의 경우는 +연산자를 사용할 때 기본형 또는 참조형 값이 문자열로 자동 형변환 된다.)

* print()나 println()은 1개 매개변수를 문자열로 바꾸어 출력함

* 표준 입력 : 키보드, 표준 출력 : 모니터(화면)

* 키보드에서 입력을 받는 Scanner 객체(키보드로 xxx yyy zzz 이렇게 공백으로 구분하고 엔터를 쳐서 입력을 하는데, 여기서 xxx, yyy, zzz를 토큰이라고 함)
System.in을 이용하여 Scanner 객체를 만들고 사용함
Scanner sc = new Scanner(System.in);
String name = sc.next(); -> String의 경우 next()를 사용

Scanner 클래스의 입력용 메소드
boolean hasNext() : 다음 단어가 있으면 true를 반환
String next() : 단어를 읽어 String으로 반환
boolean hasNextInt(), int nextInt()
boolean hasNextDouble(), double nextDouble()
boolean hasNextLine(), String nextLine() -> 한 문장으로 된 문자열을 입력 받는 것

* 클래스
class Circle {

}

* 클래스 접근 제어자
public, protected, 생략, private
비접근 제어자 : abstract(붙이면 객체 생성이 불가능한 클래스 즉, new로 객체 생성 불가. 그래도 자식 클래스에 상속이 될 수 있음), final(붙이면 부모가 될 수 없는 클래스)
public : 모든 클래스에서 사용 가능
protected : class A { class B {} }에서 class B 앞에만 붙을 수 있다.
생략 : 같은 패키지에 있는 다른 클래스에서 사용 가능(패키지 접근 수준)
private : class A { class B {} }에서 class B 앞에만 붙을 수 있다.

* 데이터 필드 접근 제어자(메소드도 마찬가지)
데이터 필드를 사용할 수 있는 범위를 제한하여 정보를 은닉
public 필드 : 모든 클래스에서 사용 가능
protected 필드 : 같은 패키지와 자식 클래스에서 사용 가능
생략 필드 : 같은 패키지에 있는 다른 클래스에서 사용 가능
private 필드 : 같은 클래스에서만 사용 가능

데이터 필드와 메소드를 멤버라고 부름

* 객체가 가지는 인스턴스 변수(객체가 생성되고 나서 만들어짐), 인스턴스 메소드(인스턴스 변수를 다루기 위한 함수)
클래스가 가지는 클래스 변수(해당 클래스의 객체들이 공유하는 변수로 데이터 값은 하나만 존재, static 변수, 정적 변수라고도 함), 클래스 메소드(클래스 변수를 이용해서 기능을 수행)

* 배열은 선언 후에 초기화 과정이나 생성의 과정을 거쳐야만 사용할 수 있다.
* ‘배열이름.length’을 사용하여 배열의 크기를 표현할 수 있다.
* 문자열 변수나 리터럴에 대해 +연산을 적용한 결과는 두 문자열이 연결된 문자열이다.
* Scanner 클래스를 이용하면 키보드나 파일로부터 편리하게 문자열(또는 기본형 값)을 입력받을 수 있다.
* 클래스를 정의할 때, 특별한 경우가 아니면 클래스의 접근 제어자로서 생략과 public만 지정할 수 있다.
* 클래스를 정의할 때, 접근 제어자가 생략된 데이터 필드는 ‘해당 클래스’와 ‘같은 패키지의 다른 클래스’에서 사용할 수 있다.

int형 변수 i와 j의 값을 각각 출력하기 위해 적당한 출력문은 무엇인가?
System.out.println( i + " " + j ); -> 정답
오답
System.out.println( i , j );
System.out.println( i + j );
System.out.println( i + ‘=’ + j ); -> 작은 따옴표로 되어 있어서









*****************************************************************************
4강. 클래스와 상속
*****************************************************************************

* 생성자 : 객체가 생성될 때 자동으로 실행되는 메소드(특별한 메소드로 임의로 호출해서 실행되는 것이 아니라 new를 통해 객체가 생성될 때만 자동 호출 됨)
객체의 필드 값을 초기화하거나 메모리 할당 등의 작업
Circle c = new Circle(5);
new : new 연산자를 이용하여 객체를 생성(메모리 할당)
Circle(5) : 생성자가 호출(데이터 필드의 초기화)
= : 객체의 참조값을 변수에 대입

* 생성자는 보통의 메소드와 정의 방법이 다름(생성자는 new로 객체를 생성할 때 자동 호출됨)
생성자 이름은 클래스 이름과 같음
반환형을 선언하지 않음
여러 생성자를 정의할 수 있음(생성자 오버로딩 : 인자의 개수와 인자의 자료형으로 구분)
접근 제어자는 보통 public

하나의 소스 파일에 있으면 컴파일 시 같은 패키지에 존재하게 된다.
class Circle {
	double r;
	public Circle(double a) {
		r = a;
	}
	public double getArea() {
		return r * r * 3.14;
	}
}

public class CircleArea {
	public static void main(String args[]) {
		Circle c = new Circle(5.0);
		System.out.println(c.r); // Circle 클래스에서 r의 접근제어자가 생략되어 있기 떄문에 사용 가능(접근제어자가 생략되면 같은 패키지의 다른 클래스에서 사용 가능)
		System.out.println(c.getArea());
	}
}

* 기본 생성자 : 인자가 없는 생성자, 디폴트 생성자(default constructor)
클래스 정의에 한 개의 생성자 정의도 없으면 컴파일러가 public Circle() {}과 같이 자동으로 만들어 줌

* ★기본 생성자와 상관없이, 자식 클래스의 생성자 정의에서 생성자 몸체의 첫 줄에 부모 생성자의 명시적 호출이 없다면 super(); 코드가 자동으로 들어감
super(); : 부모 클래스의 기본 생성자를 호출
따라서 부모 클래스에서 기본 생성자의 존재를 확인해야 함(없으면 에러)

* 클래스의 사용
클래스형 변수를 선언할 때(클래스는 객체의 자료형) : Circle c; (클래스 참조형 변수의 선언)
객체를 생성할 때 : c = new Circle();
상속받아 클래스를 정의할 때 : class CSub extends CSuper {}

* 클래스의 재사용
합성 : 기존 클래스를 새로운 클래스에서 데이터 필드의 자료형으로 사용
has-a 관계
class Line { Point begin, end; }
상속 : 기존 클래스(부모)를 사용하여 새로운 클래스(자식)를 정의
코드의 중복 작성을 줄이고 프로그램의 확장성이 좋아짐
상속은 기존 클래스를 확장 or 특화하는 것
자식 is-a 부모의 관계

* 객체의 사용
객체 변수와 점(.) 연산자를 사용하여 멤버에 접근

* static 필드
정적 필드 or 클래스 변수
클래스의 모든 객체가 공유하는 데이터
객체의 생성이 없이도 항상 사용 가능
★어떤 객체도 값을 변경할 수 있음
사용 방법은 클래스 이름.정적필드(객체변수.정적필드도 가능)

* static 메소드
정적 메소드 or 클래스 메소드
객체와 무관하게 호출되고 실행됨
★메소드 몸체에서 this를 사용할 수 없음(static 메소드는 객체와 무관하게 실행되는 메소드이므로 this와 super는 static 메소드에서 사용할 수 없다.)
static 필드와 인자를 가지고 작업함
사용 방법은 클래스이름.정적메소드()
Math.sqrt(2.0);
Integer.parseInt("120");

* final 필드
상수 데이터를 선언
선언할 때 초기값을 지정해야 함
자주 static과 함께 사용됨
final static double PI = 3.141592;

* final 메소드
자식 클래스로 상속은 가능하나 재정의 할 수 없는 메소드

* 객체 초기화
객체를 생성할 때 데이터 필드에 초기값을 지정하는 것
클래스 변수는 프로그램 시작 시에 자동 초기화됨
데이터 필드는 자동으로 초기값이 주어질 수 있음
* 순서
static 필드의 선언문에서 초기화
static 초기화 블록 실행

① non-static 필드의 선언문에서 초기화
② non-static 초기화 블록 실행
클래스 몸체 내 임의 위치에 포함
초기값 지정을 위한 코드
static 필드는 static 블록을 사용
③ 생성자 실행
class IniTest {
	int nValue = 1; // ①
	{
		nValue = 2; // ②
	}
	public IniTest() {
		nValue = 3; // ③
	}
}
-> 최종적으로 nValue 값은 3이 된다.
static 초기화 블록은 블록 앞에 static을 붙인다.

* 메소드의 signature
메소드 이름, 매개변수 리스트
메소드의 signature로 메소드 구분 가능(반환형은 제외)

* 메소드 오버로딩
인자의 개수나 인자의 자료형이 다르면 같은 이름의 메소드를 한 클래스에서 여러 개 정의할 수 있음
인자의 개수와 자료형이 정확히 일치하면 중복 정의 불가
★반환형은 구분의 기준이 아니다.
메소드를 호출할 때, 가장 가까운 매개변수 목록을 가진 메소드가 호출됨

* 클래스의 상속은 단일 상속만 가능
★인터페이스의 상속은 다중 상속 가능

* 메소드 오버라이딩
부모로부터 상속받은 메소드의 몸체를 자식 클래스에서 재정의 하는 것
★자식 입장에서 보면 부모 클래스에서 상속받은 메소드도 있는 것이고, 그것을 재정의 했다면, 재정의한 메소드도 있는 것
★오버라이딩 방법 : 메소드의 이름, 인자의 개수와 자료형, 반환형이 같은 메소드를 정의
★반환형은 서브 타입(상속 관계에서 자식 클래스)도 가능함
★접근 제어자의 가시성(접근 범위)은 같거나 커져야 함
protected인 경우 protected 또는 public, public인 경우 public만 가능

* this
메소드 호출 시, 숨은 인자로 this가 메소드에 전달됨
this는 현재 객체에 대한 참조값을 가지고 있음(c1.display()과 c2.display()의 결과가 다른 이유임)
★인스턴스 메소드나 생성자에서만 사용 가능(static 메소드는 객체와 무관하게 실행되는 메소드이므로 this와 super는 static 메소드에서 사용할 수 없다.)

* super
this와 같으나 자료형이 부모 클래스 유형임
자식 클래스의 인스턴스 메소드나 생성자에서 사용됨(this와 마찬가지로 static 메소드에서 사용 불가)
부모 클래스에서 오버라이딩 당한 메소드를 호출하거나 상속되었으나 감춰진 필드에 접근할 때 필요
super.메소드(인자)
super.필드
★아래의 경우 CSub에는 x가 2개임
class CSuper {
	public double x;
}
class CSub extends CSuper {
	public double x;
	public CSub(double new_x) {
		this.x = new_x; // 이 경우 CSub의 x를 가리키며, this는 생략 가능
		super.x = new_x * 10; // 이 경우 CSuper의 x를 가리킴
	}
	public double getSupter() {
		return super.x;
	}
	public double getSub() {
		return this.x;
	}
}
public class ThisSuperTest {
	public static void main(String args[]) {
		CSub sub = new CSub(10.0);
		System.out.println(sub.x); // 10 출력
		System.out.println(sub.getSuper());
		System.out.println(sub.getSub());
	}
}
★★★ Super sup = new Sub();에서
메소드 실행은 동적 바인딩에 의해 변수(sup)가 참조하는 실객체의 유형(Sub)이 가지고 있는 메소드를 실행한다는 것이고, 변수의 경우는 정적 바인딩에 의해 참조 변수의 선언 유형(Super)이 가지고 있는 변수를 참조하게 된다.
★★★★ 데이터필드는 선언유형만 봄
동적 바인딩(Dynamic Binding)
다형성을 사용하여 메소드를 호출할 때, 발생하는 현상이다.
실행 시간(Runtime) 즉, 파일을 실행하는 시점에 성격이 결정된다.
실제 참조하는 객체는 서브 클래스이니 서브 클래스의 메소드를 호출한다.
정적 바인딩(Static Binding)
컴파일(Compile) 시간에 성격이 결정된다.
변수의 타입이 수퍼 클래스이니 수퍼 클래스의 메소드를 호출한다.
★위에서 CSuper sub = new CSub(10.0); 으로 할 경우 아래에서 100 출력
sub가 데이터 유형이 CSuper 유형으로 되어 있기 때문에 sub 변수가 실제로 가리키는 객체가 new CSub()로 인해 자식 객체를 만들어 놓고 그것을 포인팅 하고 있더라도, sub.x와 같이 데이터 필드에 접근하게 될 때는 sub의 선언 유형인 CSuper에서 정의되어 있는 x값을 출력하게 된다.(100)
sub.getSuper()는 컴파일 시 sub의 선언 유형이 CSuper이기 때문에 CSuper에서 getSuper를 호출할 수 있는가를 체크하는데, CSuper에 getSuper 메소드가 없기 때문에 컴파일 오류가 난다.

* ()는 메소드 선언 혹은 호출과 관련있는 것
★this() : 같은 클래스의 다른 생성자를 호출하는 것(생성자가 여러 개 있을 때, 어떤 생성자에서 다른 생성자를 이용해서 데이터를 초기화할 때 다른 생성자를 호출)
super() : 부모 클래스의 생성자를 호출하는 것
★상속받은 데이터 필드를 초기화하기 위한 것(상속받은 데이터 필드를 초기화 할 때는 부모 클래스에 있는 생성자를 이용해서 초기화해야함)
생성자 몸체에서 부모 클래스 생성자의 명시적 호출이 없다면, 인자가 없는 생성자인 super()가 자동 호출됨
★this(), super() 둘 다 생성자 몸체의 첫 번째 문장에서만 사용 가능

Circle 클래스에 radius 데이터 필드가 있다고 가정하고 아래 코드를 보자.
아래의 두 Cylinder 생성자에서 할 일은 데이터 필드 height와 radius를 초기화하는 것
그래서 Cylinder()에서는 Circle 클래스의 기본 생성자에서 정의된대로 radius를 초기화 할 것이고, Cylinder (double radius, double h)에서는 인자로 받은 radius와 super(radius)를 통해 radius가 초기화 될 것임
public class Cylinder extends Circle{
	private double height;
	public Cylinder() {
		super();
		height=1.0;
	}
	public Cylinder (double radius, double h) {
		super(radius);
		this.height =h;
	}
	public double getHeight() {
		return height;
	}
	public void setHeight(doubleh ){
		this.height =h;
	}

	public double getArea() {
		return2 * PI * getRadius() * height + 2 * super.getArea();
		// 여기서 getRadius()는 this.getRadius()의 축약형
		// getArea()는 오버라이딩한 것이고 super.getArea()가 아닌 this.getArea()면 자기 자신을 호출하는 것이기 때문에 부모의 getArea()를 호출하도록 super.getArea()가 쓰임
	}
	public double getVolume() {
		return super.getArea() * height;
	}
	public String toString() {
		return "Cylinderofradius=" + getRadius()+ "height=" + height;
		// 여기서 getRadius()는 this.getRadius()의 축약형
	}
}

* 생성자를 정의하려면 이름을 클래스 이름과 같게 하고 반환형을 지정하지 않는다.
* 클래스 정의에 있는 데이터 필드의 선언문, 초기화 블록, 생성자를 통해서 객체 생성 시 필요한 데이터 필드의 초기 값을 지정할 수 있다.
* 클래스를 정의할 때, 객체마다 각각 데이터가 필요하면 인스턴스 변수(non-static 데이터 필드)로, 모든 객체가 공유하는 데이터는 static 데이터 필드로 정의한다.
* 메소드 오버로딩이란 한 클래스에서 이름이 같은 여러 메소드가 존재하는 상황을 말한다. 이때 오버로딩된 메소드끼리는 매개변수 목록이 달라 구별될 수 있다.
* 부모로부터 상속받은 메소드의 몸체를 자식 클래스에서 다시 정의하는 것을 메소드 오버라이딩이라 한다.
* 인스턴스 메소드와 생성자에서 숨은 인자인 this와 super를 사용할 수 있다.




