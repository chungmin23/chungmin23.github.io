---
layout: single
title: "java"
categories: project
tag: project
toc: true
---

## 자바 요약


동영상 강의 + 최근 기출(방송통신대학교 KNOU 기준) 핵심 요약

*****************************************************************************
1강. Java와 객체지향 프로그래밍
*****************************************************************************

* 바이트 코드
-. Java 소스를 컴파일한 결과물(기계어는 아님. 자바 플랫폼인 자바 가상 머신에서 실행가능)
-. 확장자는 .class이며 클래스 파일이라고도 함
-. 자바 플랫폼의 Java VM에서 실행 가능한 코드
-. Write once, run anywhere.

* 자바 프로그램 = 애플리케이션(자바 플랫폼에서 실행되는 프로그램으로 실행을 위해 main() 함수가 필요) + 애플릿(HTML 웹 페이지에 포함되어 웹 브라우저를 통해 실행)
자바 언어는 플랫폼 독립적, 아키텍처 중립적임

* 애플리케이션
-. Java 플랫폼에서 실행되는 프로그램
-. 실행을 위해 main() 함수가 필요함

* 애플릿
-. HTML 웹 페이지에 포함되어 웹 브라우저를 통해 실행

* Java 플랫폼의 구성(JDK라고도 할 수 있음) = JAVA VM + JAVA API
-. Java VM
-. Java API
	: 프로그램의 개발에 필요한 클래스 라이브러리
	: 패키지(클래스 묶음)들이 계층 구조로 분류되어 있음

* Hello, World 출력
public class Test {
    public static void main(String[ ] args) {
        System.out.println("Hello, World!");
    }
}

* public class는 파일에 최대 1개

4. 객체지향 프로그래밍
1) 클래스와 객체
* 추상화(필요한 일부만을 간단히 표현하는 것)
-. 구체적인 모든 사실이 아니라 전형적이고 필요한 부분만을 발췌하여 사물을 이해하고 표현하는 것
-. 클래스(추상화를 통해 프로그램상에서 표현된 것)
	: 클래스는 객체를 만들기 위한 모형 또는 틀
	: 공통적인 특징을 가지는 객체들을 추상화하기 위한 수단
	: 객체의 상태는 필드(데이터)로, 행위는 메소드로 구현됨
	: 객체는 특정 클래스의 인스턴스(실체화된 것)

2) 객체지향 프로그램
* Java 프로그램
-. 클래스가 프로그램 구성의 기본 단위(C언어는 함수)
-. 데이터(필드)와 알고리즘(메소드)이 클래스에 캡슐화되어 있음
-. 클래스 정의로부터 객체들이 만들어지고, 객체들간의 상호작용으로 프로그램이 동작함









*****************************************************************************
2강. Java 기본 문법(1)
*****************************************************************************

* 식별자 : 클래스, 변수, 메소드, 레이블 등의 이름
대소문자 구분, 길이 제한 없음, 숫자 시작 불가, 키워드인 true, false, null 등은 불가, 공백 불가,
영 대소문자, 한글, 숫자, '_', '$' 사용 가능

* 변수 종류
인스턴스 변수 : 객체가 소유하는 변수(클래스 정의에서 static이 아닌 데이터 필드)
클래스 변수 : 객체가 공유하는 변수(클래스 정의에서 static 데이터 필드)
지역 변수 : 메소드 내부(또는 블럭 내부)에서 선언된 변수
파라미터 : 메소드 호출 시 전달하는 값을 저장하기 위한 변수

* 지역 변수와 파라미터 / 데이터 필드(인스턴스 변수 or 클래스 변수)
지역 변수는 초기값을 지정한 후 사용해야 함(데이터 필드는 초기값 지정 안 하면 기본값이 주어짐)
지역 변수 선언에서 접근 제어자를 사용하지 않음(데이터 필드에서만 접근 제어자 사용)

* 리터럴 : 실제 데이터 값

* 0b11010 : 2진수, 032 : 8진수, 0x1a : 16진수

* 기본형 변수는 저장 공간에 값 자체를 저장, 참조형(기본형을 제외한 모든 자료형) 변수는 저장 공간에 참조 값을 저장함(실제 데이터는 별도의 공간에 저장됨)

* if와 else 짝짓기 : else는 자기 짝이 없는 가장 가까운 if와 짝을 이룸

* for-each문 : 형식은 for(변수선언 : 배열) { 문장 ... }
int[] arrayOfInts = {32, 87, 3};
for (int element : arrayOfInts) {
	System.out.print(element + " ");
}

int[ ] a = {32, 87, 3, 589, 12 }; 
for (int i = 0; i < a.length ; i++)   
        System.out.print( a[i] + " " );
↓
for (int element : a)   
        System.out.print( element + " " );

* break문을 포함하는 가장 가까운 switch문, for문, while문, do-while문의 실행을 끝냄
* continue문 : 가장 가까이 있는 반복문의 다음 반복을 위한 조건식으로 즉시 제어를 이동하기 위한 것

* Java의 기본형을 나타내는 키워드는 byte, short, int, long, float, double, char, boolean의 8가지이다.
* 클래스와 배열은 대표적 참조형으로, 참조형 변수에는 참조 값(주소)이 저장된다.
* 명령행 매개변수란 main( ) 함수에 전달되는 인자로서, 프로그램을 실행시킬 때 프로그램의 이름 뒤에 나열하는 인자를 말한다.
* 제어문은 프로그램의 실행 흐름을 제어하는 문장이다.
* break문, continue문, return문은 제어문 중 점프문(분기문)에 해당한다.





*****************************************************************************
3강. Java 기본 문법(2)
*****************************************************************************

* 배열
같은 자료형의 원소를 정해진 개수만큼 가지고 있는 객체
배열의 크기는 선언 이후 배열이 초기화 또는 생성될 때 정해짐(선언할 때는 크기를 지정할 수 없음)
형식은 자료형[] 변수이름; 또는 자료형 변수이름[];

* 배열도 참조형(클래스 유형, 인터페이스 유형, 배열 등 기본형이 아닌 다른 것들) 변수이기 때문에(참조값, 즉 주소값을 가지고 있음, 배열의 경우 배열 원소가 들어가는 공간에 대한 주소값을 가지고 있음) 선언 후 실제 데이터가 들어갈 공간을 할당 받아 사용한다.

* 배열의 선언(선언할 때는 크기를 지정할 수 없음)
int[]a;
int b[];
int[][]c;
int d[][];
int[]e[];
int f[10]; -> 오류

* 배열의 초기화 : 선언과 동시에 중괄호를 이용하여 초기값을 지정(★중괄호로 배열을 초기화하는 것은 선언과 함께 수행되어야 한다.)
자동으로 메모리 공간이 확보됨
int a[] = {2, 3, 4}; -> 선언과 동시에 초기화
int anArray[][] = {{1, 2, 3},{4, 5, 6}};
int b[]; b = {5, 6, 7}; -> 오류(두 문장으로 초기화하면 오류)


* 배열 초기화 되는 것들
----------------------------------------
int[] numbers = {1, 2, 3};
----------------------------------------
int[] numbers = new int[] {1, 2, 3};
----------------------------------------
int[] numbers = new int[10];
----------------------------------------
int[] numbers = new int[3];
numbers[0] = 1;
numbers[1] = 2;
numbers[2] = 3;
----------------------------------------

* 배열 문법 틀린 것들
----------------------------------------
int[] numbers;
numbers = {1, 2, 3}; // ★중괄호로 배열을 초기화하는 것은 선언과 함께 수행되어야 한다.
----------------------------------------
int b[ ] = new int(10);
----------------------------------------
int a[10] = new int[ ];
----------------------------------------
int[5] d = {1, 2, 3, 4, 5};
----------------------------------------

* 배열의 생성 : 배열의 원소가 사용할 메모리 공간의 생성
new 연산자를 이용
배열의 크기를 정하고 메모리 공간을 확보
new 연산자는 메모리 공간을 확보한 후 그 메모리 주소값을 리턴함
원소가 숫자인 경우 0, 참조형인 경우 null로 자동 초기화
int a[] = new int[3]; -> 선언과 생성
int b[]; b = new int[10];
int anArray4[][] = new int[3][2]; -> 이 경우 new int[3][]과 같이 행 먼저 생성 후 나중에 각 열에 대해 다르게 생성작업을 할 수 있음. [3][2]와 같이 할 경우 3행 2열로 고정이지만 [3][]과 같이 하면 우선 3행이 만들어지고 각 열에 다른 개수(다른 크기로)로 원소를 넣을 수 있음

* null : 해당 참조형 변수가 어떤 객체도 참조하고 있지 않다.

* 문자열의 +연산자
System.out.println('A' + 0); -> 65(char형 A는 65로 간주됨)
System.out.println("A" + 0); -> A0(문자열의 경우는 +연산자를 사용할 때 기본형 또는 참조형 값이 문자열로 자동 형변환 된다.)

* print()나 println()은 1개 매개변수를 문자열로 바꾸어 출력함

* 표준 입력 : 키보드, 표준 출력 : 모니터(화면)

* 키보드에서 입력을 받는 Scanner 객체(키보드로 xxx yyy zzz 이렇게 공백으로 구분하고 엔터를 쳐서 입력을 하는데, 여기서 xxx, yyy, zzz를 토큰이라고 함)
System.in을 이용하여 Scanner 객체를 만들고 사용함
Scanner sc = new Scanner(System.in);
String name = sc.next(); -> String의 경우 next()를 사용

Scanner 클래스의 입력용 메소드
boolean hasNext() : 다음 단어가 있으면 true를 반환
String next() : 단어를 읽어 String으로 반환
boolean hasNextInt(), int nextInt()
boolean hasNextDouble(), double nextDouble()
boolean hasNextLine(), String nextLine() -> 한 문장으로 된 문자열을 입력 받는 것

* 클래스
class Circle {

}

* 클래스 접근 제어자
public, protected, 생략, private
비접근 제어자 : abstract(붙이면 객체 생성이 불가능한 클래스 즉, new로 객체 생성 불가. 그래도 자식 클래스에 상속이 될 수 있음), final(붙이면 부모가 될 수 없는 클래스)
public : 모든 클래스에서 사용 가능
protected : class A { class B {} }에서 class B 앞에만 붙을 수 있다.
생략 : 같은 패키지에 있는 다른 클래스에서 사용 가능(패키지 접근 수준)
private : class A { class B {} }에서 class B 앞에만 붙을 수 있다.

* 데이터 필드 접근 제어자(메소드도 마찬가지)
데이터 필드를 사용할 수 있는 범위를 제한하여 정보를 은닉
public 필드 : 모든 클래스에서 사용 가능
protected 필드 : 같은 패키지와 자식 클래스에서 사용 가능
생략 필드 : 같은 패키지에 있는 다른 클래스에서 사용 가능
private 필드 : 같은 클래스에서만 사용 가능

데이터 필드와 메소드를 멤버라고 부름

* 객체가 가지는 인스턴스 변수(객체가 생성되고 나서 만들어짐), 인스턴스 메소드(인스턴스 변수를 다루기 위한 함수)
클래스가 가지는 클래스 변수(해당 클래스의 객체들이 공유하는 변수로 데이터 값은 하나만 존재, static 변수, 정적 변수라고도 함), 클래스 메소드(클래스 변수를 이용해서 기능을 수행)

* 배열은 선언 후에 초기화 과정이나 생성의 과정을 거쳐야만 사용할 수 있다.
* ‘배열이름.length’을 사용하여 배열의 크기를 표현할 수 있다.
* 문자열 변수나 리터럴에 대해 +연산을 적용한 결과는 두 문자열이 연결된 문자열이다.
* Scanner 클래스를 이용하면 키보드나 파일로부터 편리하게 문자열(또는 기본형 값)을 입력받을 수 있다.
* 클래스를 정의할 때, 특별한 경우가 아니면 클래스의 접근 제어자로서 생략과 public만 지정할 수 있다.
* 클래스를 정의할 때, 접근 제어자가 생략된 데이터 필드는 ‘해당 클래스’와 ‘같은 패키지의 다른 클래스’에서 사용할 수 있다.

int형 변수 i와 j의 값을 각각 출력하기 위해 적당한 출력문은 무엇인가?
System.out.println( i + " " + j ); -> 정답
오답
System.out.println( i , j );
System.out.println( i + j );
System.out.println( i + ‘=’ + j ); -> 작은 따옴표로 되어 있어서









*****************************************************************************
4강. 클래스와 상속
*****************************************************************************

* 생성자 : 객체가 생성될 때 자동으로 실행되는 메소드(특별한 메소드로 임의로 호출해서 실행되는 것이 아니라 new를 통해 객체가 생성될 때만 자동 호출 됨)
객체의 필드 값을 초기화하거나 메모리 할당 등의 작업
Circle c = new Circle(5);
new : new 연산자를 이용하여 객체를 생성(메모리 할당)
Circle(5) : 생성자가 호출(데이터 필드의 초기화)
= : 객체의 참조값을 변수에 대입

* 생성자는 보통의 메소드와 정의 방법이 다름(생성자는 new로 객체를 생성할 때 자동 호출됨)
생성자 이름은 클래스 이름과 같음
반환형을 선언하지 않음
여러 생성자를 정의할 수 있음(생성자 오버로딩 : 인자의 개수와 인자의 자료형으로 구분)
접근 제어자는 보통 public

하나의 소스 파일에 있으면 컴파일 시 같은 패키지에 존재하게 된다.
class Circle {
	double r;
	public Circle(double a) {
		r = a;
	}
	public double getArea() {
		return r * r * 3.14;
	}
}

public class CircleArea {
	public static void main(String args[]) {
		Circle c = new Circle(5.0);
		System.out.println(c.r); // Circle 클래스에서 r의 접근제어자가 생략되어 있기 떄문에 사용 가능(접근제어자가 생략되면 같은 패키지의 다른 클래스에서 사용 가능)
		System.out.println(c.getArea());
	}
}

* 기본 생성자 : 인자가 없는 생성자, 디폴트 생성자(default constructor)
클래스 정의에 한 개의 생성자 정의도 없으면 컴파일러가 public Circle() {}과 같이 자동으로 만들어 줌

* ★기본 생성자와 상관없이, 자식 클래스의 생성자 정의에서 생성자 몸체의 첫 줄에 부모 생성자의 명시적 호출이 없다면 super(); 코드가 자동으로 들어감
super(); : 부모 클래스의 기본 생성자를 호출
따라서 부모 클래스에서 기본 생성자의 존재를 확인해야 함(없으면 에러)

* 클래스의 사용
클래스형 변수를 선언할 때(클래스는 객체의 자료형) : Circle c; (클래스 참조형 변수의 선언)
객체를 생성할 때 : c = new Circle();
상속받아 클래스를 정의할 때 : class CSub extends CSuper {}

* 클래스의 재사용
합성 : 기존 클래스를 새로운 클래스에서 데이터 필드의 자료형으로 사용
has-a 관계
class Line { Point begin, end; }
상속 : 기존 클래스(부모)를 사용하여 새로운 클래스(자식)를 정의
코드의 중복 작성을 줄이고 프로그램의 확장성이 좋아짐
상속은 기존 클래스를 확장 or 특화하는 것
자식 is-a 부모의 관계

* 객체의 사용
객체 변수와 점(.) 연산자를 사용하여 멤버에 접근

* static 필드
정적 필드 or 클래스 변수
클래스의 모든 객체가 공유하는 데이터
객체의 생성이 없이도 항상 사용 가능
★어떤 객체도 값을 변경할 수 있음
사용 방법은 클래스 이름.정적필드(객체변수.정적필드도 가능)

* static 메소드
정적 메소드 or 클래스 메소드
객체와 무관하게 호출되고 실행됨
★메소드 몸체에서 this를 사용할 수 없음(static 메소드는 객체와 무관하게 실행되는 메소드이므로 this와 super는 static 메소드에서 사용할 수 없다.)
static 필드와 인자를 가지고 작업함
사용 방법은 클래스이름.정적메소드()
Math.sqrt(2.0);
Integer.parseInt("120");

* final 필드
상수 데이터를 선언
선언할 때 초기값을 지정해야 함
자주 static과 함께 사용됨
final static double PI = 3.141592;

* final 메소드
자식 클래스로 상속은 가능하나 재정의 할 수 없는 메소드

* 객체 초기화
객체를 생성할 때 데이터 필드에 초기값을 지정하는 것
클래스 변수는 프로그램 시작 시에 자동 초기화됨
데이터 필드는 자동으로 초기값이 주어질 수 있음
* 순서
static 필드의 선언문에서 초기화
static 초기화 블록 실행

① non-static 필드의 선언문에서 초기화
② non-static 초기화 블록 실행
클래스 몸체 내 임의 위치에 포함
초기값 지정을 위한 코드
static 필드는 static 블록을 사용
③ 생성자 실행
class IniTest {
	int nValue = 1; // ①
	{
		nValue = 2; // ②
	}
	public IniTest() {
		nValue = 3; // ③
	}
}
-> 최종적으로 nValue 값은 3이 된다.
static 초기화 블록은 블록 앞에 static을 붙인다.

* 메소드의 signature
메소드 이름, 매개변수 리스트
메소드의 signature로 메소드 구분 가능(반환형은 제외)

* 메소드 오버로딩
인자의 개수나 인자의 자료형이 다르면 같은 이름의 메소드를 한 클래스에서 여러 개 정의할 수 있음
인자의 개수와 자료형이 정확히 일치하면 중복 정의 불가
★반환형은 구분의 기준이 아니다.
메소드를 호출할 때, 가장 가까운 매개변수 목록을 가진 메소드가 호출됨

* 클래스의 상속은 단일 상속만 가능
★인터페이스의 상속은 다중 상속 가능

* 메소드 오버라이딩
부모로부터 상속받은 메소드의 몸체를 자식 클래스에서 재정의 하는 것
★자식 입장에서 보면 부모 클래스에서 상속받은 메소드도 있는 것이고, 그것을 재정의 했다면, 재정의한 메소드도 있는 것
★오버라이딩 방법 : 메소드의 이름, 인자의 개수와 자료형, 반환형이 같은 메소드를 정의
★반환형은 서브 타입(상속 관계에서 자식 클래스)도 가능함
★접근 제어자의 가시성(접근 범위)은 같거나 커져야 함
protected인 경우 protected 또는 public, public인 경우 public만 가능

* this
메소드 호출 시, 숨은 인자로 this가 메소드에 전달됨
this는 현재 객체에 대한 참조값을 가지고 있음(c1.display()과 c2.display()의 결과가 다른 이유임)
★인스턴스 메소드나 생성자에서만 사용 가능(static 메소드는 객체와 무관하게 실행되는 메소드이므로 this와 super는 static 메소드에서 사용할 수 없다.)

* super
this와 같으나 자료형이 부모 클래스 유형임
자식 클래스의 인스턴스 메소드나 생성자에서 사용됨(this와 마찬가지로 static 메소드에서 사용 불가)
부모 클래스에서 오버라이딩 당한 메소드를 호출하거나 상속되었으나 감춰진 필드에 접근할 때 필요
super.메소드(인자)
super.필드
★아래의 경우 CSub에는 x가 2개임
class CSuper {
	public double x;
}
class CSub extends CSuper {
	public double x;
	public CSub(double new_x) {
		this.x = new_x; // 이 경우 CSub의 x를 가리키며, this는 생략 가능
		super.x = new_x * 10; // 이 경우 CSuper의 x를 가리킴
	}
	public double getSupter() {
		return super.x;
	}
	public double getSub() {
		return this.x;
	}
}
public class ThisSuperTest {
	public static void main(String args[]) {
		CSub sub = new CSub(10.0);
		System.out.println(sub.x); // 10 출력
		System.out.println(sub.getSuper());
		System.out.println(sub.getSub());
	}
}
★★★ Super sup = new Sub();에서
메소드 실행은 동적 바인딩에 의해 변수(sup)가 참조하는 실객체의 유형(Sub)이 가지고 있는 메소드를 실행한다는 것이고, 변수의 경우는 정적 바인딩에 의해 참조 변수의 선언 유형(Super)이 가지고 있는 변수를 참조하게 된다.
★★★★ 데이터필드는 선언유형만 봄
동적 바인딩(Dynamic Binding)
다형성을 사용하여 메소드를 호출할 때, 발생하는 현상이다.
실행 시간(Runtime) 즉, 파일을 실행하는 시점에 성격이 결정된다.
실제 참조하는 객체는 서브 클래스이니 서브 클래스의 메소드를 호출한다.
정적 바인딩(Static Binding)
컴파일(Compile) 시간에 성격이 결정된다.
변수의 타입이 수퍼 클래스이니 수퍼 클래스의 메소드를 호출한다.
★위에서 CSuper sub = new CSub(10.0); 으로 할 경우 아래에서 100 출력
sub가 데이터 유형이 CSuper 유형으로 되어 있기 때문에 sub 변수가 실제로 가리키는 객체가 new CSub()로 인해 자식 객체를 만들어 놓고 그것을 포인팅 하고 있더라도, sub.x와 같이 데이터 필드에 접근하게 될 때는 sub의 선언 유형인 CSuper에서 정의되어 있는 x값을 출력하게 된다.(100)
sub.getSuper()는 컴파일 시 sub의 선언 유형이 CSuper이기 때문에 CSuper에서 getSuper를 호출할 수 있는가를 체크하는데, CSuper에 getSuper 메소드가 없기 때문에 컴파일 오류가 난다.

* ()는 메소드 선언 혹은 호출과 관련있는 것
★this() : 같은 클래스의 다른 생성자를 호출하는 것(생성자가 여러 개 있을 때, 어떤 생성자에서 다른 생성자를 이용해서 데이터를 초기화할 때 다른 생성자를 호출)
super() : 부모 클래스의 생성자를 호출하는 것
★상속받은 데이터 필드를 초기화하기 위한 것(상속받은 데이터 필드를 초기화 할 때는 부모 클래스에 있는 생성자를 이용해서 초기화해야함)
생성자 몸체에서 부모 클래스 생성자의 명시적 호출이 없다면, 인자가 없는 생성자인 super()가 자동 호출됨
★this(), super() 둘 다 생성자 몸체의 첫 번째 문장에서만 사용 가능

Circle 클래스에 radius 데이터 필드가 있다고 가정하고 아래 코드를 보자.
아래의 두 Cylinder 생성자에서 할 일은 데이터 필드 height와 radius를 초기화하는 것
그래서 Cylinder()에서는 Circle 클래스의 기본 생성자에서 정의된대로 radius를 초기화 할 것이고, Cylinder (double radius, double h)에서는 인자로 받은 radius와 super(radius)를 통해 radius가 초기화 될 것임
public class Cylinder extends Circle{
	private double height;
	public Cylinder() {
		super();
		height=1.0;
	}
	public Cylinder (double radius, double h) {
		super(radius);
		this.height =h;
	}
	public double getHeight() {
		return height;
	}
	public void setHeight(doubleh ){
		this.height =h;
	}

	public double getArea() {
		return2 * PI * getRadius() * height + 2 * super.getArea();
		// 여기서 getRadius()는 this.getRadius()의 축약형
		// getArea()는 오버라이딩한 것이고 super.getArea()가 아닌 this.getArea()면 자기 자신을 호출하는 것이기 때문에 부모의 getArea()를 호출하도록 super.getArea()가 쓰임
	}
	public double getVolume() {
		return super.getArea() * height;
	}
	public String toString() {
		return "Cylinderofradius=" + getRadius()+ "height=" + height;
		// 여기서 getRadius()는 this.getRadius()의 축약형
	}
}

* 생성자를 정의하려면 이름을 클래스 이름과 같게 하고 반환형을 지정하지 않는다.
* 클래스 정의에 있는 데이터 필드의 선언문, 초기화 블록, 생성자를 통해서 객체 생성 시 필요한 데이터 필드의 초기 값을 지정할 수 있다.
* 클래스를 정의할 때, 객체마다 각각 데이터가 필요하면 인스턴스 변수(non-static 데이터 필드)로, 모든 객체가 공유하는 데이터는 static 데이터 필드로 정의한다.
* 메소드 오버로딩이란 한 클래스에서 이름이 같은 여러 메소드가 존재하는 상황을 말한다. 이때 오버로딩된 메소드끼리는 매개변수 목록이 달라 구별될 수 있다.
* 부모로부터 상속받은 메소드의 몸체를 자식 클래스에서 다시 정의하는 것을 메소드 오버라이딩이라 한다.
* 인스턴스 메소드와 생성자에서 숨은 인자인 this와 super를 사용할 수 있다.






*****************************************************************************
5강. 인터페이스와 다형성
*****************************************************************************

* 추상 메소드
메소드 선언에 abstract 키워드를 사용함
몸체의 구현이 없이 형식만 존재
자식 클래스에 상속될 때 몸체의 구현이 필요
final과 함께 사용 불가
추상 메소드를 가진 클래스는 추상 클래스 혹은 인터페이스여야만 함
abstract public class Shape {
	abstract public double getArea();
}

* 추상 클래스(반대 의미가 구체 클래스, 일반 클래스)
클래스 정의에 abstract 키워드를 사용함
★데이터 필드나 일반 메소드를 포함할 수 있음
★객체 생성을 할 수 없음(구체적이지 못한 불완전한 클래스라는 의미)

* 추상 클래스의 사용
★의미적으로 유사한 클래스(의미적으로 유사한 클래스는 자식 클래스가 됨)들을 묶고자 할 때 사용(하나의 추상 클래스 아래에 의미적으로 유사한 클래스들을 자식으로 둠, 의미적으로 비슷하기 때문에 자식들이 공통으로 사용할 데이터 필드와 메소드를 부모 추상 클래스에 정의해둔다.)
도형이란 부모 추상 클래스가 있고, 그 안에 면적을 구하는 추상 메소드가 있다고 할 때, 자식 클래스(삼각형, 사각형 등)에서 각 면적을 구하는 메소드를 구현하여 사용한다.
공통으로 사용할 데이터 필드와 메소드를 정의
추상 클래스는 일반 클래스와 인터페이스의 중간적 성격을 가짐(추상 클래스보다 더 추상적인게 인터페이스)
(기능적으로 유사한 것은 인터페이스)

* 인터페이스(abstract는 생략하는 것이 보통임(abstract interface인데 interface만 씀. ★interface 소문자인 것 주의)
100% 추상적 클래스
★인터페이스의 모든 메소드는 추상 메소드(public abstract, 생략 가능, 각각도 생략 가능)
★단, 몸체가 구현된 default 메소드와 static 메소드도 포함 가능, 접근 제어자는 public(생략 가능)
★모든 메소드의 기본 접근 제어자는 public
★★★데이터 필드는 클래스 상수만 가능(public static final, 생략 가능) -> 객체 생성 없이 참조할 수 있는 데이터 필드만 가능(객체를 생성할 수 없으니 클래스 상수만 가능한듯)
참조 자료형이며 직접적 객체 생성은 불가(추상 클래스보다 더 추상적인게 인터페이스)
인터페이스의 이름은 보통 형용사(Runnable, Serializable, Comparable)

* 인터페이스의 사용
추상 클래스와 마찬가지로 자식 클래스에 상속되어 사용됨
인터페이스를 구현하는 자식 클래스는 모든 추상 메소드를 구현해 주어야 함
★의미적으로는 관련이 없으나 기능적으로 유사한 클래스들을 묶을 때 인터페이스를 사용할 수 있음
사각형 클래스, 운동 선수 클래스, TV 클래스, 아파트 클래스 -> 의미적으로는 관련 없지만 크기 비교가 가능하다는 클래스로 볼 수 있음. 부모 인터페이스에 comparable과 같이 대소비교가 가능한 추상 메소드를 둘 수 있음
인터페이스를 상속받아 자식 인터페이스를 정의할 수 있음 -> 인터페이스의 상속(또는 확장)

* 인터페이스의 상속(자식 인터페이스가 부모 인터페이스를 상속받는 경우)
인터페이스를 상속받아 인터페이스를 정의할 때 키워드 extends를 사용
★★여러 인터페이스를 상속받는 다중 상속도 가능(콤마로 구분)
★interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2
★인터페이스가 부모 역할을 할 때는 다중 상속이 가능
* 인터페이스의 구현(자식 클래스가 부모 인터페이스를 상속받는 경우)
자식은 부모가 나열한 기능(추상 메소드)을 구현해야 함
구현을 통해 클래스를 정의할 때 implements를 사용
class 자식클래스 extends 부모클래스 implements 부모인터페이스1, 부모인터페이스2

* 상속과 인터페이스의 차이점은 강제성의 유무
인터페이스는 implments를 선언하고 구현을 하지 않으면 오류가 남
상속은 오버라이딩을 해서 구현을 해도 그만 안 해도 그만

interface Movable{
	void moveUp(); // ★public abstract 생략되어 있음
	void moveDown(); // ★public abstract 생략되어 있음
	void moveLeft(); // ★public abstract 생략되어 있음
	void moveRight(); // ★public abstract 생략되어 있음
}
public class MovableTest {
	public static void main(String[]args) {
		Movable m1 = new MovablePoint(5,5); // ★인터페이스 Movable 유형으로 선언
		System.out.println(m1); // ★자동으로 m1.toString()이 호출된다.
		m1.moveUp();
		System.out.println(m1);
		m1.moveRight();
		System.out.println(m1);
	}
}

class MovablePoint implements Movable {
	private int x,y;
	public Movable Point(intx,inty) {
		this.x =x;
		this.y =y;
	}
	public String toString() {
		return "Pointat("+x+","+y+")";
	}
	public voidmoveUp(){y++;}
	public voidmoveDown(){y--;}
	public voidmoveLeft(){x--;}
	public voidmoveRight(){x++;}
}

* 디폴트 메소드
인터페이스에서 선언하는 메소드에 기본 구현을 넣을 수 있음
자식 클래스에서 상속받을 때 디폴트 메소드를 그대로 사용하거나 몸체를 다시 정의해 줄 수 있음
메소드 선언시 default를 사용하고 몸체를 구현해 줌
★인터페이스에 나열된 기능을 확장할 때 기존 코드의 수정을 피하기 위함
★단순히 추상 메소드가 추가된다면 이전 인터페이스를 구현한 클래스 모두를 수정해야 함
interface DoIt {
	void doSomething();
	int doSomethingElse(String s);
	// ★시간이 한참 지난 뒤 추상 메소드가 추가된다면 이전 인터페이스를 구현한 클래스 모두를 수정해야 함. 그래서 아래와 같이 기본몸체가 구현된 default 메소드를 추가하여 원하는 곳에서만 아래 메소드를 재정의하면 됨
	default boolean didItWork(int i, String s) {
	}
}

* 추상 클래스, 인터페이스, 클래스의 형변환
인터페이스와 클래스는 모두 사용자 정의형(사용자 자료유형)
상위 유형의 변수는 하위 객체의 참조값을 가질 수 있음
상위 유형의 변수가 가리키는 객체의 실제 유형에 따라 수행되는 메소드가 결정됨(동적 바인딩, 동적 바인딩은 실행 시점에 결정됨)
메소드 호출 시 변수의 선언 유형으로 정하지 않음
★SuperClass super = new SubClass(); // 업캐스팅
super.method(); // SubClass에서 찾음
★★★ Super sup = new Sub();에서
메소드 실행은 동적 바인딩에 의해 변수(sup)가 참조하는 실객체의 유형(Sub)이 가지고 있는 메소드를 실행한다는 것이고, 변수의 경우는 정적 바인딩에 의해 참조 변수의 선언 유형(Super)이 가지고 있는 변수를 참조하게 된다.

* 다형성과 형변환
상속 관계에 있는 클래스 간에는 타입 변환이 가능
Animal animal = (animal)new Dog(); // (animal) 생략 가능

class A { 
	public void func( ) {
		System.out.println(“a”); 
	}
}
class B extends A {
	public void func( ) {
		System.out.println(“b”);
	}
}
class C extends B {
	public void func( ) {
		System.out.println(“c”);
	}
}

public class PolymorphTest {
	public static void main(String args[ ]) {
		A a = new B( );
		a.func( ); // ★실행 시점에 B를 가리키고 있기 때문에 class B에서 func()
		a = new C( );
		a.func( ); // ★실행 시점에 C를 가리키고 있기 때문에 class C에서 func()
	}
}

위의 결과는 b, c인데, 만약 class C에 func()가 없으면 c가 아닌 b가 답이다.
★컴파일 시점에 class A에 func()가 없다면 컴파일 오류가 남
★컴파일 시점에는 a.func( ); 시 선언 유형을 봄. A a = new B( ); 그래서 선언 유형이 A이기 때문에 A에 func()가 있어야 함
★★컴파일할 때는 선언 유형을 보고 거기에 해당 메소드가 있는지 확인을 하고, 문제가 없으면 넘어간다. 실행할 때는 실유형을 본다.
★★★★ 데이터필드는 선언유형만 봄

* 열거형 정의
열거형은 미리 정의된 상수값을 만들기 위한 자료형
enum을 사용하여 정의
열거형으로 선언된 변수에는 미리 지정된 값만 대입 가능
상수값을 배열로 리턴하는 static 메소드로 values()를 제공
Enum Day {
	SUNDAY, MONDAY, TUESDAY
}
// main 함수에서
Day day = Day.MONDAY;
for (Day d : Day.values()) {
	System.out.println(d);
}

* 열거형의 생성자와 메소드
열거형 정의에 필드와 메소드를 포함할 수 있음
상수 선언이 필드나 메소드보다 먼저 정의되어야 하며 세미콜론(;)으로 끝나야 함
생성자는 열거형과 같은 이름을 가지며 접근 제어자는 생략 또는 private이어야 함
열거형에서 상수값은 마치 하나의 객체와 같음
열거형의 생성자는 상수값을 설정(객체 생성)할 때 자동 호출됨

enum BaseballTeam {
	LG(40, 30), SS(30, 40), KT(20, 50), 
	SK(35, 35), NC(55, 15); // 세미콜론으로 끝남

	private final int win;
	private final int lose;

	private BaseballTeam(int win, int lose) {
		this.win = win;
		this.lose = lose;
	}
	public double winsRate( ) { 
		return (win * 100.0) / (win + lose); 
	}
}

public class EnumTest2 {
	public static void main(String args[ ]) {                       
		BaseballTeam bt = BaseballTeam.LG; // ★enum BaseballTeam에서 LG를 찾아가면 LG(40, 30) 이렇게 괄호가 있기 때문에 생성자가 호출되고 생성자를 통해 데이터 필드가 초기화 된다.
		System.out.println(bt.winsRate( ));
	}
}

* 익명 클래스
일회성으로 1개의 객체를 생성하기 위한 클래스
클래스 정의와 동시에 객체를 생성할 수 있음
슈퍼 클래스를 상속받거나 인터페이스를 구현하도록 익명 클래스를 정의함
new 슈퍼클래스() {...} // 여기서 {...} 이게 익명 클래스 정의고, 슈퍼클래스를 부모로 하는, 즉, 슈퍼클래스를 상속받는 익명클래스 정의(슈퍼클래스의 자식 객체 생성. 앞에 new가 있으므로)
new 인터페이스() {...} // 인터페이스를 구현하는 자식 객체 생성 
★CSuper sub = new CSuper( ) {  } ; 의미 : CSuper를 상속받는 익명 클래스를 정의하고, 동시에 객체를 생성한다.

★53분(동적바인딩, 정적바인딩)

* 몸체가 없는 메소드를 추상 메소드라고 하고, 추상 메소드를 하나라도 가지고 있는 클래스는 추상 클래스이어야 한다.
* 인터페이스는 추상 메소드로만 구성된다. 단, default 메소드와 static 메소드는 몸체가 있어야 한다.
* 의미적으로 유사한 클래스를 묶을 때는 추상 클래스로, 기능적으로 유사한 클래스를 묶을 때는 인터페이스를 사용한다.
* 다형성은 메소드 오버라이딩과 오버로딩, 클래스 간 상속과 형변환, 인터페이스의 구현과 형변환, 메소드 동적 바인딩을 통해 구현될 수 있다.
* 열거 자료형은 여러 상수값을 미리 정의하기 위한 자료형이며, 각 상수값은 하나의 객체와 같다.
* 익명 클래스는 이름이 없는 클래스로, 일회성으로 객체를 생성하는 용도로만 사용되는 클래스를 의미한다.






*****************************************************************************
6강. 제네릭과 람다식
*****************************************************************************

* 제네릭 : 캐스트(형변환) 연산자의 사용 불필요
class ArrayList<E> implements List<E> { // ArrayList를 사용할 때, 즉, ArrayList 유형으로 변수 선언을 하거나, 객체 생성을 할 때 <E> 여기다가 자료형을 전달해 줘야 한다는 의미(타입 매개변수(타입 파라미터)를 전달해 줘야 한다.) -> 예를 들어 Integer가 전달되면 E 부분이 Integer가 된다.
	boolean add(E e) {}
	E get(int index) {}
	E remove(int index) {}
}

List list1 = new ArrayList(); // ★ArrayList에서 관리되는 원소 하나하나를 Object 유형으로 보면 됨
list1.add("hello"); // ★hello가 Object 유형으로 자동형변환(업캐스팅)되서 add된다.
String s1 = (String)list1.get(0); // ★형변환 필요(get할 경우 Object 유형으로 return이 되기 때문에 문자열 변수에 대입하려면 String으로의 형변환(다운캐스팅)이 필요한 것이다.)

List<String> list2 = new ArrayList<String>(); // ★문자열을 원소로 하는 ArrayList 객체가 만들어짐
list2.add("hello");
String s2 = list2.get(0); // ★형변환 불필요

* 제네릭 클래스
클래스 정의에서 타입 파라미터를 선언함
클래스를 사용할 때는 타입을 명시해야함
타입 파라미터는 참조형만 가능
★필드의 자료형, 메소드 반환형, 인자의 자료형으로 사용할 수 있음

* 제네릭 클래스 필요성
제네릭 타입을 사용하지 않으면 컴파일 시점에서 오류를 검출하지 못함
★의미가 명확하면 생성자 호출 시 괄호만 사용할 수 있음
Data2<String> b3 = new Data2<>();
Pair<String, Integer> p1;
p1 = new OrderedPair<>("Even", 8);

* 제네릭 인터페이스를 구현하는 제네릭 클래스
interface Pair<K, V> {
	public K getKey();
	public V getValue();
}

class OrderedPair<K, V> implements Pair<K, V> {
	...
}

* 제네릭 타입을 상속/구현하는 일반 클래스
제네릭 인터페이스를 구현하는 일반 클래스 : 클래스를 정의할 때 제네릭 인터페이스의 <> 안에 자료형을 지정하면 됨
class MyPair implements Pair<String, Integer> {
	private String key;
	private Integer value;
	public MyPair(String key, Integer value) {
		this.key = key;
		this.value = value;
}

* Raw타입
제네릭 타입이지만 일반 타입처럼 사용하는 경우, 제네릭 타입을 지칭하는 용어
타입 매개변수 없이 사용되는 제네릭 타입
자료형을 Object로 처리함
Data2 data = new Data2("hello");
이 때 Data2는 제네릭 타입 Data2<T>의 raw 타입

* 제네릭 메소드
자료형을 매개변수로 가지는 메소드
하나의 메소드 정의로 여러 유형의 데이터를 처리할 때 유용
메소드 정의에서 반환형 왼편에 각괄호<> 안에 타입 매개변수 표시
타입 매개변수를 메소드의 반환형이나 메소드의 매개변수의 자료형, 지역 변수의 자료형으로 사용 가능
public static <T> T getLast(T[] a) {
	return a[a.length-1];
}
인스턴스 메소드와 static 메소드 모두 제네릭 메소드로 정의 가능
★제네릭 메소드를 호출할 때 타입을 명시하지 않아도 인자에 의해 추론이 가능(생략 가능하다는 말)
class Util {
	public static<K,V>boolean compare(Pair<K, V> p1,Pair<K, V> p2) {
		return p1.getKey().equals(p2.getKey())&&p1.getValue().equals(p2.getValue());
	}
}

public class GenericsTest5 {
	public static void main(Stringargs[]) {
		Pair<Integer, String> p1 = new OrderedPair<>(1,"apple"); // ★ <>처럼 생략됨
		Pair<Integer, String> p2=new OrderedPair<>(2,"pear");
		boolean same=Util.<Integer,String>compare(p1, p2); // ★★여기서 <Integer,String> 생략 가능(p1, p2를 추적해보면 Pair<Integer, String> 유형이니)
		System.out.println(same);
	}
}

* 제네릭의 타입 제한
자료형을 매개변수화하여 클래스/인터페이스/메소드를 정의할 때 적용가능한 자료형에 제한을 두는 것
★<T extends Number>와 같이 하면 Number를 상한으로 정할 수 있음
T에 주어지는자료형은Number의서브 클래스라야함

* 제네릭 타입과 형변환
★Integer나 Double은 Number와 상관관계가 있지만, Data<Number>와 Data<Integer>는 상하위 관계가 없음
class Data<T> {}
class FormatterdData<T> extends Data<T> {} // 상속 관계

public class GenericTypeConversion1 {
	public static void main(String args[]) {
		Data<Number>data=new Data<Number>();
		data.set(new Integer(10)); // ★OK 여기서 set 메소드에 Number 유형이 들어가야하는데 Integer나 밑에 Double은 Number의 자식 유형이기 때문에 Integer나 밑에 Double이 업캐스팅이 됨
		data.set(new Double(10.1)); // OK
		Data<Number>data1=new Data<Integer>(); // 컴파일 오류. 여기서 Data<Integer>가 Data<Number> 유형으로 형변환되어야 하는데 서로 관계가 없으므로 오류
		Data<Integer>data=new FormattedData<Integer>();
	}
}

* 제네릭 타입 사용 시 유의사항
기본 자료형은 타입 매개변수로 지정할 수 없음
Data<int>d=new Data<>(); // 오류
타입 매개변수로 객체 생성을 할 수 없음
class Data<T> {private Tt1=new T();} // 오류
타입 매개변수의 타입으로 static 데이터 필드를 선언할 수 없음(static 필드는 모든 객체가 공유하는 하나의 변수이기 때문)
class Data<T>{private static T t2;} // 오류
제네릭 타입의 배열을 선언할 수 없음
Data<Integer>[]arrayOfData; // 오류

* ★람다식 : 인터페이스를 구현하는 익명 클래스의 객체 생성 부분을 수식화 한 것
구현할 것이 1개의 추상 메소드 뿐일 때 간단히 표현할 수 있음
람다식 구문은 메소드 매개변수의 괄호, 화살표, 메소드 몸체로 표현
인터페이스 객체변수 = (매개변수 목록) -> {실행문 목록};
Runnable runnable = new Runnable() {
	public void run() {...}
};
위가 아래로 바뀔 수 있다.
Runnable runnable = () -> {...};
위에서 Runnable을 타겟 타입이라고 함
1개의 추상 메소드를 포함하는 인터페이스를 함수적 인터페이스라고 함(default, static 메소드는 고려하지 말자)

인터페이스 객체변수 = (매개변수목록)->{실행문목록 };
매개변수 목록에서 자료형은 인터페이스(타깃 타입) 정의에
서 알 수 있으므로 자료형을 생략하고 변수 이름만 사용 가능
매개변수가1개면 괄호도 생략 가능하며변수 이름 하나만 남음
매개변수를 가지지 않으면 괄호만 남음
화살표 사용
실행문 목록에서 실행문이 1개이면 중괄호 생략 가능
★실행문이 return문 뿐이라면 return과 세미콜론, 중괄호를 동시 생략해야 하고 1개의 수식만 남게 됨

* 패키지 java.util.function에서 표준 함수적 인터페이스가 제네릭 인터페이스로 제공됨
★★★표준 함수적 인터페이스의 예(리턴하는게 없으면, 즉 void면 실행문이 있음)
Consumer<T>는 void accept(T t)를 가짐(받기만 하고 return은 없음)
u Supplier<T>는 T get() 메소드를 가짐(받는건 없는데 return은 있음)
u Function<T,R>은 R apply(T t)를 가짐(하나를 받아서 하나를 return)

★아래와 같은 인터페이스가 있다고 가정할 때, 보기에서 람다식 사용이 잘못된 것은?
interface Addable {
        int add(int a, int b);
}
Addable ad = (int a, int b) -> { return (a + b); };
Addable ad = (a, b) -> { return (a + b); };
Addable ad = (a, b) -> (a + b);
아래 보기가 잘못된 것(★★★실행문이 return문 뿐이라면 return과 세미콜론, 중괄호를 동시 생략해야 하고 1개의 수식만 남게 됨)
Addable ad = (int a, int b) -> return (a + b);

* ★6강 40분부터 다시보기

* 자료형을 매개변수로 가지는 클래스와 인터페이스를 제네릭 타입이라고 한다.
* 제네릭 클래스를 사용할 때 제공되는 타입 파라미터는 필드의 자료형, 메소드의 반환형, 인자의 자료형으로 사용될 수 있다.
* 자료형을 매개변수로 가지는 메소드를 제네릭 메소드라고 한다.
* 제네릭을 활용하면 컴파일 시점에 명확한 자료형 검사를 수행할 수 있다.
* 함수적 인터페이스를 구현하는 클래스의 객체를 생성할 때 람다식을 사용하는 것이 효율적이다.
* 람다식의 실행 결과가 대입되는 인터페이스를 람다식의 타깃 타입이라고 한다.









*****************************************************************************
7강. 패키지와 예외처리
*****************************************************************************

* Java 언어에서 가장 기본적 클래스는 java.lang 패키지에 존재
그래서 Java 프로그램에서 import java.lang.*; 구문은 자동 포함됨

* package com.vehicle;
public class Car {
} 
javac Car.java - d D:\javaClasses
위의 경우 D:\javaClasses\com\vehicle\Car.class

* ★컴파일러는 환경변수 CLASSPATH에 지정된 경로에서 사용자 클래스를 찾을 수 있음
CLASSPATH의 경로는 jar 파일을 포함할 수 있음
예: 프로그램에서 graphics.Circle 클래스를 사용
CLASSPATH=경로1;경로2;a.jar라고 가정
이때, 경로1\graphics\Circle.class 또는
경로2\graphics\Circle.class 가 있거나
a.jar에 \graphics\Circle.class가 있어야 함

* 메소드를 수행할 때 예외가 발생하면 예외 객체가 만들어지고 던져짐
예외 객체는 Exception 클래스(또는 하위 클래스)로 표현되며 예외 발생 정보를 가지고 있음

* Object - Throwable - Exception / Error
Exception - RuntimeException(Unchecked Exception) / IOException 외(Checked Exception)

* Checked Exception은 예외처리 코드를 강제함(예외처리 코드가 없으면 컴파일 오류)
* RuntimeException(Unchecked Exception)은 예외처리를 안 해도 됨(ArithmeticException, NullpointerException, IndexOutOfBoundsException 등)
RuntimeException은 컴파일 시 통과, 런타임 시 예외 발생
그 외의 Exception은 컴파일 시 예외 발생

public class A {
	public void problem() throws RuntimeException {
		throw new RuntimeException(); // ★
	}
}

* catch 블럭은 하나만 실행됨

* 사용자 정의 예외
사용자가 직접 예외 클래스를 작성할 수 있음
일반적으로 Exception 클래스를 상속받음
throw 구문을 사용하여, 필요할 때 예외 객체를 던질 수 있음

class MyException extends Exception {
	public MyException( ) { super( ); }
	public String toString( ) { return "MyException"; }
}
class MyExceptionTest {
	public void testFunc(int x) throws MyException {
		if (x > 10) throw new MyException( ); // 예외 객체 생성(예외 발생)
	}
} 

* 다음 코드에 관한 설명으로 올바른 것은?
try {
... ...
} catch (Exception ex1) {
... ...
} catch (IOException ex2) {
... ...
}
-> 어떠한 종류의 예외가 발생해도 첫 번째 catch 블록에서 잡히고 두 번째 catch 블록에는 도달할 수 없으므로 오류가 있다.


* Java의 패키지는 관련이 있는 클래스와 인터페이스의 묶음이며 계층 구조로 구성된다.
* 다른 패키지에 있는 클래스를 사용할 때는 import 구문을 사용하는 것이 편리하다.
* Java 프로그램에서 필요한 클래스나 패키지는 환경변수 CLASSPATH에 포함되어 있는 경로상에서 찾을 수 있어야 한다.
* Java 프로그램의 실행 도중 심각하지는 않지만 정상적 흐름을 벗어난 비정상적 상황이 발생할 수 있으며 이것을 예외라고 한다.
* checked Exception에 속하는 예외가 발생할 수 있는 경우, 반드시 예외처리 구문을 작성해야 한다.
* 예외의 직접 처리를 위해 try-catch 구문을 사용하고, 예외를 전파하려면 메소드 선언에 ‘throws 예외유형’을 표시한다.









*****************************************************************************
8강. java.lang 패키지
*****************************************************************************

* 주요 클래스
Object, System, Math
, String, StringBuffer
, Thread
, Exception, Throwable, Error
포장 클래스(Number, Integer, Double, Character, Boolean 등)

* Object
자동으로 모든 클래스의 조상이 되는 클래스
주요 메소드
protected Object clone() : 객체를 복제하여 반환
public boolean equals(Object obj)
public int hashCode() : 객체를 식별하는 정수값을 반환
public String toString()

* String toString()
Object 클래스에 있는 toString은 객체의 문자열 표현을 반환(클래스 이름@16진수 해시코드)
문자열의 +연산, System.out.print() 등에서 필요(System.out.print(a.toString()))
자식 클래스에서 재정의 할 수 있음
★String, Integer 클래스 등에서 재정의되어 있음 : '클래스 이름@16진수 해시코드'와 같이 리턴하지 않는다는 말
객체를 출력, 즉, System.out.println(my_class1); 이렇게 하면 괄호 안에 .toString()이 붙음

* boolean equals(Object obj)
★두 객체 변수를 비교해서 두 변수의 참조값이 같을 때 true를 반환
★Object 클래스에서 equals()의 의미 : obj1.equals(obj2)의 결과는 (obj1 == obj2)와 같음
String, Integer 클래스 등에서 재정의 되어 있음(Object의 것과 다름을 주의하자)
★Integer에서는 보관하고 있는 int 값이 같으면 true를 리턴하도록 재정의 되어 있음(다른 참조값을 가지고 있어도 보관하고 있는 int 값이 같으면 true. 유형은 같아야함. 보관하고 있는 값이 같아도 유형이 Integer와 Short이면 false)
★obj1 == obj2의 경우는 참조값이 같아야함

* Object clone()
객체를 복제하여 리턴함
'Cloneable 인터페이스를 구현한 클래스'의 객체만 clone() 메소드를 호출할 수 있음
예외 처리를 해야함(CloneNotSupportedException)
동영상 16분 보자
Box b1 = new Box(20, 30);
Box b2 = (Box)b1.clone(); // Object로 리턴하기 때문에 형변환 필요
★b2는 b1에서 복제됐지만 다른 해시코드를 가지고 있다.(참조값이 다르다.)

* String 클래스
문자열을 표현하고 처리하기 위한 클래스
참조형이지만 기본 자료형처럼 다룰 수 있음
String s1 = "Java"; // 리터럴을 대입
★같은 리터럴은 1개만 만들어져 공유됨
★String 객체는 내용이 변하지 않는(Immutable) 상수 객체

* String 클래스의 생성자
public String() : 빈 문자열 객체 생성
public String(String original) : 기존에 있던 것을 String 객체를 이용해서 새로운 String 객체 생성
public String(char[] value)
public String(char[] value, int offset, int count) : 문자 배열 중 일부만 쓰는 것

* 문자열 비교 메소드
int compareTo(String anotherString)
같으면 0을 리턴하고, 다르면 0이 아닌 정수값을 리턴함
s1.compareTo(s2) : s1이 작으면 음수가 리턴(사전식 순서로 비교)
int compareToIgnoreCase(String anotherString) : 대소문자를 구분하지 않고 비교
boolean equalsIgnoreCase(String anotherString)
★boolean equals(Object anObject) : Object 클래스의 equals 메소드가 재정의 된 것으로 문자열(값)이 같으면 true를 리턴하고, 다르면 false를 리턴함
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");
String s4 = new String("Java");
여기서 s1 == s2는 true이고 나머지들을 ==하면 다 false. ==은 참조값이 같아야함
s1.equals(s3)도 true이고 나머지들 모두 true

* 문자열의 검색 메소드
int indexOf(String str), int indexOf(String str, int fromIndex)
처음 위치부터 문자열 str을 찾아 처음 등장하는 위치(인덱스)를 리턴함.
없으면 -1을 리턴함
★System.out.println( "hamburger".indexOf("urge") ); // 4리턴
int lastIndexOf(String str), int lastIndexOf(String str, int fromIndex)
마지막 위치부터 앞 방향으로 찾음

* 문자열 추출 메소드
char charAt(int index)
index 위치에 있는 문자를 리턴한다.
String substring(int beginIndex)
beginIndex 위치부터 마지막까지의 문자열을 리턴함
★System.out.println( "hamburger".substring(3) ); // burger 리턴
String substring(int beginIndex, int endIndex)
beginIndex 위치부터 (endIndex-1)까지의 문자열을 리턴함(리턴되는 문자열 길이를 계산하려면 beginIndex - endIndex하면 됨)

* 문자열의 변환 메소드
★★★원본 문자열은 변경되지 않고 새로운 객체가 만들어짐
String replace(char oldChar, char newChar)
oldChar 문자를 newChar 문자로 변환하여 리턴함(★원본 문자열은 그대로 있는거고, replace 결과의 새로운 문자열이 만들어지는 것임)
String trim( )
문자열 앞과 뒤에 나오는 화이트 스페이스 문자를 제거하여
리턴함
String toUpperCase( ) : 소문자를 대문자로
String toLowerCase( )
String concat(String str) : 두 문자열을 연결함
s1.concat(s2)하면 s1과 s2 문자열은 그대로 있고, 두 문자열을 연결한 새로운 문자열이 생기는 것

★★다음 프로그램의 출력 결과는 무엇인가?
public class Test {
        public static void main(String args[]) {
                String s = new String("Jovo");
                s.replace('o','a');
                s.concat("Exam");
                System.out.println(s);
        }
}
★★정답은 Jovo
★★만약 아래와 같이 한다면 JavaExam이 출력됨
public class Test {
        public static void main(String args[]) {
                String s = new String("Jovo");
                s = s.replace('o','a');
                s = s.concat("Exam");
                System.out.println(s);
        }
}


* 다른 자료형을 문자열로 변환하는 메소드
System.out.println(String.valueOf(123)); // 123
System.out.println(String.valueOf(5 > 3)); // ★true
System.out.println(String.valueOf(3.0)); // 3.0
System.out.println(String.valueOf('c')); // c("c"로 스트링이 되는 것임)
char[ ] a = { 'J', 'a‘, 'v', 'a' };
System.out.println(String.valueOf(a)); // Java

* 기타 메소드
boolean startsWith(String prefix)
prefix로 시작하면 true를 리턴함
boolean endsWith(String suffix)
suffix로 끝나면 true를 리턴함
char[ ] toCharArray( ) : 문자열을 문자 배열로 리턴

* StringBuffer 클래스와 생성자
객체 생성 이후 문자열을 수정할 수 있는 기능을 제공
StringBuffer는 내용 변경이 가능한 mutable 클래스
내부적으로 문자열을 저장하기 위해 크기가 조절되는 버퍼(문자 배열)를 사용함
생성자
StringBuffer( ) : ★초기 버퍼의 크기는 16
StringBuffer(int length) : length 길이의 버퍼를 가진 StringBuffer 객체가 만들어짐
StringBuffer(String str) : 초기 버퍼의 크기는 (str의 길이+16)
new StringBuffer("Java") : 초기 버퍼 크기 20

* StringBuffer 주요 메소드
int capacity( ) : 버퍼 크리 리턴
int length( ) : 문자열의 길이 리턴
char charAt(int index) : 해당 위치의 문자를 리턴
int indexOf(String str) : 해당 문자열을 찾아서 index를 리턴
String substring(int start, int end) : start 위치부터 end-1 위치까지의 부분 문자열 리턴
★StringBuffer append(char c) : 인자를 String 표현으로 바꾸고 원 문자열 끝에 추가하여 반환함, 인자는 char[ ], Object, String, 기본 자료형도 가능함 -> 원본 문자열이 바뀌는 것임
★StringBuffer s1 = new StringBuffer("start");
System.out.println(s1.capacity( )); // 21
System.out.println(s1.length( )); // 5
System.out.println(s1.append("le" )); // "startle"(원본 문자열이 바뀌는 것임. s1이 String 유형이었으면 원본은 그대로이고, 새로운 "startle"이 생기는 것임)

StringBuffer delete(int start, int end) : start 위치에서 (end-1)까지의 문자열을 삭제
StringBuffer insert(int offset, String s) : offset 위치부터 s를 삽입
StringBuffer replace(int start, int end, String s) : start 위치부터 (end-1)까지의 문자열을 s로 교체
StringBuffer reverse( ) : 문자열을 역순으로 변경

public class StringTest2 {
	public static void main(String args[]) {
		final String tmp = "abcde"; long start, end;
		String str = new String( );
		StringBuffer sb1 = new StringBuffer( );
		StringBuilder sb2 = new StringBuilder( );
		start = System.nanoTime( );
		for(int i = 0; i < 10000; i++) str = str + tmp;
		end = System.nanoTime( );
		System.out.println((end-start)/1000000.0 +" msecs");
		start = System.nanoTime( );
		for(int i = 0; i < 10000; i++) sb1.append(tmp);
		end = System.nanoTime( );
		System.out.println((end-start)/1000000.0 +" msecs");
		start = System.nanoTime();
		for(int i = 0;i < 10000; i++) sb2.append(tmp);
		end = System.nanoTime();
		System.out.println((end-start)/1000000.0 +" msecs");
	}
}
StringBuffer와 StringBuilder는 mutable 클래스인데(원본 문자열이 변경되는), 다만 StringBuffer는 멀티쓰레트 프로그램에서 동시성 제어를 고려해서 구현되어 있기 때문에 StringBuilder보다 약간 느리다.
(StringBuffer 클래스의 경우가 StringBuilder 클래스의 경우보다 시간이 더 걸리는 이유는 동시성 제어를 고려하여 메소드가 구현되었기 때문)

* 포장 클래스
★기본형을 참조형으로 표현하기 위한 클래스
기본형의 값을 가지고 객체로 포장(boxing)함
사용 목적
메소드의 인자로 객체가 필요할 때(★제네릭 클래스가 제공하는 거의 모든 메소드가 기본형이 아닌 객체 유형, 즉 참조형의 인자가 필요)
클래스가 제공하는 상수를 사용할 때(Integer.MIN_VALUE, Integer.MAX_VALUE 등, Double.MIN_VALUE : 양수로써 최소값, Double.MAX_VALUE : 양수로써 최대값)
클래스가 제공하는 다양한 메소드를 사용할 때

* Number 클래스
Number는 Byte, Short, Integer, Long, Float, Double의 추상 부모 클래스
Number의 자식 클래스에서 구현된 주요 메소드
byte byteValue( ), short shortValue( ), … : 객체를 해당 기본형의 숫자로 변환(unboxing)
Integer객체.intValue() 이렇게 하면 int값으로 리턴
int compareTo(Byte anotherByte), … : this와 인자를 비교하여 같으면 0을 리턴(this가 작으면 음수 리턴, 크면 양수 리턴) XXX.compareTo(YYY)
boolean equals(Object obj) : 같은 유형이고, 값이 같으면 true를 리턴

* String과 기본형 데이터 간의 변환
포장 클래스가 제공하는 static 메소드를 사용함
String을 int(또는 long)형으로 변환할 때
int n = Interger.parseInt("123");
long l = Long.parseLong("1234");
int형(또는 long)을 String 형으로 변환
String s1 = Integer.toString(4); // "4"
String s2 = Long.toString(5); // "5"
String s3 = String.valueOf(123); // "123"

* Integer 클래스
Integer, String, int 사이의 변환 기능을 제공
다른 클래스들도 유사한 기능을 제공함
static int parseInt(String s) : String을 int로
static String toString(int i) : int를 String으로
static Integer valueOf(int i) : int를 Integer로
static Integer valueOf(String s) : String을 Integer로
String toString( ) : Integer를 String으로

* 박싱
기본형 데이터를 포장 클래스의 객체로 변환하는 것
Double radius = new Double(2.59); // 생성자 사용, 구식, 2.59가 double 값인데 Double 객체를 만들기 위한 생성자를 통해 Double을 만듦(double -> Double 이게 박싱) -> 잘 안 쓰임
Double radius = Double.valueOf(10.4); // valueOf( ) 사용
Double radius = 2.59; // 자동 boxing(요즘엔 이렇게 씀)
double -> Double 박싱, Double -> double 언박싱
자동 박싱
기본형에서 포장 클래스의 객체로 자동 변환되는 것
인자에 전달되거나 변수에 대입될 때 적용됨

* 언박싱
포장 클래스의 객체를 기본형 데이터로 변환하는 것
포장 클래스에서 기본형Value( ) 메소드를 사용
radius는 Double형 객체라 가정
double r = radius.doubleValue( ); // 객체.기본형Value( ) // Double -> double
double r = radius; // 자동 unboxing
System.out.println(new Integer(3) % 2); // 자동 unboxing // 여기서 new Integer는 Integer인데 이게 int로 자동 언박싱되어 3이 된다.
자동 언박싱
포장 클래스의 객체에서 기본형으로 자동 변환되는 것
인자에 전달되거나 변수에 대입될 때 적용됨

* System 클래스
Java 플랫폼 및 시스템과 관련된 기능 제공
유용한 클래스 필드와 메소드를 가짐
★모든 멤버는 static, 사용 시 객체를 생성할 필요 없음(out : System 클래스에 정의되어 있는 static 데이터 필드)
주요 기능
표준 입출력
JVM 또는 운영체제 속성과 시스템 환경 변수의 사용
배열 복사

* System 클래스의 표준 입출력 필드
System.in
표준 입력 스트림으로 InputStream 유형
키보드로부터 입력을 받을 때 사용
★System.in.read( )는 키보드로부터 1바이트 문자를 입력 받음(한글을 입력하면 처리 불가)
System.out
표준 출력 스트림으로 PrintStream 유형
화면에 데이터를 출력할 때 사용
System.err
표준 에러 출력 스트림으로 PrintStream 유형
오류 메시지를 화면에 출력할 때 사용

System.in.read()는 아스키코드 / int값을 리턴
0을 입력하면 0의 아스키코드 값인 48을 리턴

System.in.available() : 현재 아직도 유효한 입력된 문자 개수를 따짐
★윈도우에서 엔터키를 치면 캐리지 리턴키(CR)와 라인피드(LF) 문자로 조합되서 전달이 된다.(Carriage Return & Line Feed, Carriage Return의 아스키코드값은 13이고 Line Feed의 아스키코드 값은 10) 리눅스나 다른 운영체제에서는 다를 수 있음
import java.io.*;
public class ExInput {
	public static void main(String args[ ]) throws IOException {
		char cInput = 0;
		int i;
		System.out.print("Input a character: ");
		cInput = (char)System.in.read( );
		System.out.println(cInput);
		i = System.in.read( );
		System.out.println(i);
		i = System.in.read( );
		System.out.println(i);
		System.out.println(System.in.available( ));
	}
}
Input a character: a입력 후 엔터를 치면 결과가
a
13
10
0

import java.io.*;
public class ExInout4 {
	public static void main(String args[]) throws IOException {
		String szInputLine;
		int nValue;
		InputStreamReader isr = new InputStreamReader(System.in); // 1바이트 단위 입력을 할 수 있는 System.in 객체를 InputStreamReader를 이용해서 문자 단위 입력이 가능하게
		BufferedReader is = new BufferedReader(isr);
		System.out.print("Input a number: ");
		szInputLine = is.readLine( );
		nValue = Integer.parseInt(szInputLine);
		System.out.println(nValue);
		is.close();
	}
}

* java.lang 패키지는 import 구문을 쓰지 않더라도 모든 Java 소스 코드에 자동으로 포함된다.
* String은 문자열 처리를 위한 다양한 메소드를 제공하지만 immutable 클래스로, String 객체는 생성 이후에 내용 변경이 불가능하다.
* toString() 메소드와 equals() 메소드는 Object 클래스에서 정의되어 있으며, 몇몇 하위 클래스들에서 적절히 재정의되어 있다.
* 자주 변경되는 문자열을 다루어야 할 경우에는 String 클래스보다 StringBuffer나 StringBuilder 클래스를 사용하는 것이 보다 효율적이다.
* 기본형 값을 객체로 다루기 위해, 모든 기본형마다 상응하는 포장 클래스가 존재한다.
* System 클래스는 표준 입력과 출력, 표준 오류 출력을 위해 in, out, err 객체를 제공한다.









*****************************************************************************
9강. java.io 패키지와 스트림
*****************************************************************************

* 스트림
Java 언어에서 스트림을 통해 입출력을 수행할 수 있음
입력 스트림은 데이터 생산자(소스)와 연결
출력 스트림은 데이터 소비자(목적지)와 연결
다양한 입출력 종류(디스크, 문자 배열, 네트워크 소켓, 다른 프로그램 등)에 상관없이 동일한 방법으로 프로그램을 작성
스트림을 통해 입출력을 제어함
스트림 : 순서가 있는 일련의 데이터 흐름을 의미, 데이터 생산자(소스)와 데이터 소비자(목적지) 사이의
데이터가 지나는 통로

* 스트림의 분류
바이트 스트림과 캐릭터 스트림
바이트 스트림은 1 byte 단위로 데이터를 다룸
xxxInputStream(입력)과 xxxOutputStream(출력)
캐릭터 스트림은 char(2 바이트 문자) 단위로 데이터를 다룸
xxxReader(입력)과 xxxWriter(출력)
기본 스트림과 보조 스트림
기본 스트림은 입출력 기능을 제공하는 스트림
보조 스트림은 자체적으로 입출력 기능을 수행할 수는 없어서 기본 스트림과 함께 사용되어야 하며, 보조 기능을 제공하는 스트림

* 스트림 관련 클래스
java.io 패키지의 스트림 클래스
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	처리 방향		입력 스트림		출력 스트림
처리 단위
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	바이트 스트림	InputStream		OutputStream
기본			FileInputStream		FileOutputStream
스트림	ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	문자 스트림	Reader			Writer
			FileReader		FileWriter
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ	
	바이트 스트림	BufferedInputStream	BufferedOutputStream
보조						PrintStream
스트림			DataInputStream		DataOutputStream
			ObjectInputStream		ObjectOutputStream
	ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	문자 스트림	BufferedReader		BufferedWriter
						PrintWriter
	ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	기타		InputStreamReader		OutputStreamWriter
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
★ 뒤에 Stream이 붙으면 바이트 스트림
★ Input / Output 바이트 스트림
★ Reader / Writer 문자 스트림
FileInputStream fis = new FileInputStream();
BufferedInputStream bis = new BufferedInputStream fis;
입력 스트림이면 데이터 생산자를 결정해야하고, 출력 스트림이면 소비자를 결정해야함

** 바이트 스트림
* InputStream 클래스(추상 클래스)
바이트 단위 입력 스트림 클래스의 최상위 클래스
주요 메소드
abstract int read( ) :★입력 스트림으로부터 1 바이트를 읽어 정수(★아스키 코드 / Reader 클래스 설명에서는 유니코드라고 함)로 리턴함(한글은 못 읽음. 한글은 2바이트, 즉, 문자 단위로 읽어야함) System.in.read()에서 System.in(키보드 입력을 받기 위한 표준 입력 스트림)이 InputStream 유형
int read(byte[ ] b) : 입력 스트림으로부터 읽어서 byte 배열에 저장, 읽어 들인 바이트 개수를 리턴함
int read(byte[ ] b, int off, int len) : 바이트 배열의 off 위치부터 byte 단위 개수인 len(바이트 길이) 만큼 읽는다.
int available( ) : 다음 read( )할 때, 블로킹 없이(지연 작업 없이)  입력 스트림에서 읽을 수 있는 데이터 길이
long skip(long n) : 입력 스트림에서 n 바이트를 건너 뜀. 실제 건너뛴 바이트 수가 리턴됨
void mark(int readlimit), void reset( ) : 입력 스트림에서 현재 읽을 위치(현재의 포지션 값)를 기억해둠. reset()이 호출되면 mark해놨던 포지션으로 이동(읽을 위치를 이동)

* OutputStream 클래스(추상 클래스)
바이트 단위 출력 스트림 클래스의 최상위 클래스
하위 클래스는 xxxOutputStream
주요 메소드
★void write(int b) : 1 바이트의 데이터를 출력 스트림에 씀(인자로 주어지는 것은 int b. 즉 4바이트. 그 중에서 1바이트만 취해서 데이터 출력을 함)
void write(byte[ ] b) : byte 배열의 내용을 출력 스트림에 씀
void write(byte[ ] b, int off, int len)
void close( ) : 출력 스트림을 닫고 할당받은 자원을 시스템에 반납
void flush( ) : 출력을 하면 출력 스트림에 출력을 하는 것인데, flush()를 하면 스트림에 남아있는 바이트 데이터를 강제로 데이터 목적지로 내보낸다.

** 캐릭터 스트림
* Reader 클래스
입력용 캐릭터 단위 스트림 클래스의 최상위 클래스
추상 클래스이며 이것의 하위 클래스는 xxxReader
주요 메소드
int read( ) : 1개 문자(2 바이트)를 읽어 리턴함(한글 읽을 수 있음)
int read(char[ ] cbuf) : 문자를 읽어 char 배열에 저장함, 읽어 들인 문자의 개수를 리턴함
boolean ready( ) : 스트림이 읽힐 준비가 되었으면(블러킹 없이, 지연 없이) true를 리턴함
abstract void close( ) : 입력 스트림을 닫고 자원을 반납함

* Writer 클래스
출력용 캐릭터 단위 스트림 클래스의 최상위 클래스
추상 클래스이며 이것의 하위 클래스는 xxxWriter
주요 메소드
void write(int c) : 1개의 문자(2 바이트)를 출력함
void write(char[ ] cbuf) : 캐릭터 배열에 있는 내용을 출력(출력 스트림에 내보낸다.)
void write(String str) : String을 출력
void write(String str, int off, int len) : off 위치에서 문자 단위로 len 길이만큼 출력
abstract void close( )

** 파일 입출력(가장 많이 쓰인다고 볼 수 있음)
* File 클래스(파일 자체 혹은 디렉터리 하나를 표현하기 위한 클래스)
★jdk7부터는 java.io 패키지의 File 클래스를 쓰지말고 java.nio.file 패키지에 있는 Path 인터페이스를 쓰기를 권장하고 있음
파일이나 디렉터리를 표현
상대 또는 절대 경로를 가짐
파일/디렉터리를 조작할 수 있는 메소드 제공
이름과 경로의 조회
파일과 디렉토리의 생성과 삭제
★파일에다가 직접 입력하거나 출력하는 입출력 메소드는 제공되지 않음(파일 클래스는 파일 자체 혹은 디렉터리 하나를 표현하기 위한 클래스. 파일의 입출력을 하려면 FileInputStream, FileOutputStream, FileReader, FileWriter를 써야함)
생성자
File(String pathname)
pathname은 상대 또는 절대 경로로 표현될 수 있음
★File myFile = new File("c:\\temp\\data.txt"); // \\두개 주의

* File 클래스의 주요 메소드
boolean exists( ) : 파일 객체.exists() / 존재하느냐
boolean isDirectory( ), boolean isFile( ) : 디렉토리냐, 파일이냐
String getName( ) : 경로의 맨 마지막 이름
String getPath( ) : 경로를 문자열로 바꾸어 리턴
long length( ) : 파일이면 데이터의 바이트 수 리턴
boolean createNewFile( ) : 해당 파일 객체를 create(존재하지 않으면 파일을 생성후 true 리턴)
boolean delete( ) : 파일이나 디렉터리 삭제. 디렉터리의 경우 그 디렉터리가 empty인 경우에만 삭제가 된다.
boolean mkdir( ) : 지정된 경로에서 맨 마지막 디렉터리만 만듦(확인해봐야함)
boolean mkdirs( ) : 중간 경로까지 만듦
String[ ] list( ) : File 객체에 지정된 디렉터리 안에 들어 있는 파일과 서브 디렉터리들의 이름을 문자열 배열로 반환, 에러일 경우 null을 리턴
File[ ] listFiles( ) : File 객체에 지정된 디렉터리 안에 들어 있는 파일과 서브 디렉터리들의 경로를 File 배열로 반환, 에러일 경우 null을 리턴
String getParent( ), File getParentFile( ) : 상위 경로의 이름(또는 File 객체)을 반환
static File[ ] listRoots( ) : 루트 디렉터리들을 File 배열로 반환(static 메소드이기 때문에 File.listRoots();)

* 디렉터리의 내용을 보여주는 예제
import java.io.*;
public class ListDirectory2 {
	public static void main(String args[]) {
		File file = new File("c:\\windows"); // \\두개 주의, ★디렉터리가 아닌 경우 null이 리턴되어 file에 null이 대입되고 그 다음 행부터 문제가 된다.
		File files[ ] = file.listFiles( );
		int i = 0;
		while(i < files.length) {
			System.out.print(files[i].getPath( ));
			System.out.println("\t" + files[i].length( ));
			i++;
		}
	}
}
c:\windows\addins 0
c:\windows\afreeca.ico 353118
c:\windows\AhnInst.log 121513

* RandomAccessFile 클래스
랜덤 엑세스 파일
파일의 임의 위치에서 읽기/쓰기가 가능
파일을 오픈하고, 위치를 지정하고, 읽기/쓰기를 함
★읽고 쓰는 위치는 파일 포인터가 가리킴, 읽기(또는 쓰기)는 파일 포인터가 가리키는 위치부터 바이트
단위로 읽음(또는 씀)
byte 단위로 읽고 쓰며, 파일 포인터가 이동됨
랜덤 엑세스 파일을 커다란 byte 배열로 볼 수 있음

* RandomAccessFile 클래스의 메소드
생성자
RandomAccessFile(File file, String mode),
RandomAccessFile(String name, String mode)
mode는 읽기 전용의 ＂r＂ 또는 읽기/쓰기 겸용의 "rw"(★r로 했는데 쓰기 연산을 시도하면 IOException 발생, r로 했는데 해당 파일이 존재하지 않으면 FileNotFoundException 발생)
주요 메소드
int read( )
int read(byte[ ] b), int read(byte[ ] b, int off, int len)
void seek(long pos) : 인자로 포지션. 읽기나 쓰기를 할 위치를 파일 포인터가 가리키고 있는데, seek은 파일 포인터의 위치를 설정해준다. 파일 포인터를 이동
void write(byte[ ] b),
void write(byte[ ] b, int off, int len)

import java.io.*;
public class RAFTest {
	public static void main(String args[ ]) {
		try {
			RandomAccessFile raf;
			raf = new RandomAccessFile("c:\\java\\test.txt", "rw"); // ★RandomAccessFile을 생성한다. 해당 파일을 오픈한다는 의미. rw 모드일 경우, 해당 파일이 없으면, 해당 파일을 생성한다.
			for( int i = 0; i < 10; i++)
				raf.write(i);
			for(int i = 9;i >= 0;i--) {
				raf.seek(i); // 해당 파일 포인터를 옮긴 다음에
				System.out.print(raf.read( )); // 해당 위치에서 read
			}
			raf.close();
		} catch (Exception e) { System.out.println(e); }
	}
}

* FileInputStream, FileOutputStream 클래스
파일로부터 데이터를 읽기/쓰기 위한 입력/출력용 기본 스트림
바이트 단위의 입력/출력

FileInputStream 클래스의 생성자
기존 파일과 연결된 입력 스트림 객체를 생성
FileInputStream(File file), FileInputStream(String name)
바이트 단위로 입력을 받을 수 있기 때문에 이미지나 오디오 파일을 읽을 때 유용
없으면 FileNotFoundException 발생

FileOutputStream 클래스의 생성자
기존 파일(없다면 생성)과 연결된 출력 스트림 객체를 생성
FileOutputStream(String name)
FileOutputStream(File file, boolean append) : append 값을 true를 하면 기존 파일 맨 뒤에 붙여쓰기
없으면 FileNotFoundException 발생
바이트 단위로 파일에 출력을 함

* FileOutputStream 예제(복사 예제)
import java.io.*;
public class FileOutputStreamTest {
	public static void main(String args[ ]) {
		try {
			File inFile, outFile;
			inFile = new File("c:\\Java\\FileInputStreamTest.java"); // 이 파일을 아래 경로에 복사할 예정
			outFile = new File("c:\\Java\\FileTemp.java"); // 출력용 파일의 경우 해당 파일이 존재하지 않으면 생성함, 존재하면 덮어씀
			InputStream is = new FileInputStream(inFile);
			OutputStream os = new FileOutputStream(outFile);
			int nData;
			nData = is.read( );
			while(nData != -1) { // ★파일의 끝이면 -1 리턴
				os.write(nData);
				nData = is.read( );
			}
			is.close( ); os.close( ); }
		catch (Exception e) {
			System.out.println(e); }
		}
}

* FileReader, FileWriter 클래스
텍스트 파일을 다루기 위한 기본 스트림
문자 단위의 입력 / 출력
FileReader(File file)
FileReader(String fileName)
FileWriter(File file)
FileWriter(String fileName)
FileWriter(File file, boolean append)

** 콘솔 입출력과 보조 스트림
콘솔 입출력을 제공하는 클래스
키보드 입력과 화면 출력을 편리하게 지원
1. 표준 스트림 이용 System.in : 콘솔 입력(키보드 입력), System.out : 모니터 출력
2. 콘솔 클래스 이용. System.in이나 System.out 보다 편리
★명령 프롬프트 창에서 실행해야 함
★System.console( )을 사용하여 콘솔 객체를 생성함
주요 메소드
String readLine( ) : 한 라인을 읽음
char[ ] readPasssword( ) : 입력할 때 화면에 보이지 않음
PrintWriter writer( ), Reader reader( )

import java.io.*;
public class ConsoleTest {
	public static void main(String args[]) {
		String name;
		char[ ] pw; // 문자 배열
		Console con = System.console( ); // 콘솔 객체를 생성함
		System.out.print("name : ");
		name = con.readLine( ); // 한 라인을 읽음
		System.out.print("password : ");
		pw = con.readPassword( );
		PrintWriter pr = con.writer( );
		pr.println("name : " + name);
		pr.println("password : " + pw);
	}
}
>java ConsoleTest
name : kildong↲
password : ↲
name : kildong
password : [C@16d3586 // 암호화된 내용으로 출력된 것임

* 보조 스트림
기본 스트림의 성능을 높이거나 보조 기능을 제공하는 스트림
입출력 기능을 직접 수행하지는 못함
보조 스트림을 생성할 때, 기본 스트림 객체를 생성자의 인자로 이용함
‘기본 스트림을 보조 스트림으로 감싼다’라고 함
프로그램에서는 보조 스트림을 사용해 입출력하면 됨
FileInputStream fis = new FileInputStream( );
BufferedInputStream bis = new BufferedInputStream(fis);

* 보조 스트림 종류
버퍼링 기능의 제공
BufferedInputStream, BufferedOutputStream
BufferedReader, BufferedWriter

Java의 기본 자료형을 그대로 읽기/쓰기 위한 기능의 제공 : DataInputStream, DataOutputStream
DataOutputStream을 통해 writeInt()하고 DataInputStream을 통해 readInt()

다양한 출력 형식의 제공 : PrintStream(System.out이 PrintStream유형, printf()나 format(), printLine() 같은거), PrintWriter
텍스트 파일을 라인 단위로 읽는 메소드를 제공 : LineNumberReader
★바이트 스트림과 캐릭터 스트림의 호환 : InputStreamReader, OutputStreamWriter

* LineNumberReader 클래스
텍스트 파일을 라인 단위로 읽어 들이는 메소드 제공
BufferedReader의 서브 클래스
주요 메소드
String readLine( )
int getLineNumber( ) : 라인 번호를 리턴

File file = new File("src\\LineNumberTest.java");
FileReader fr = new FileReader(file);
LineNumberReader rd = new LineNumberReader(fr);
String line;
while ((line = rd.readLine( )) != null) { // ★한 줄씩 라인 단위로 읽어서 라인 끝을 의미하는 캐리지 리턴이나 라인 피드를 제외한 나머지를 문자열로 리턴
	System.out.print(rd.getLineNumber( )+" ");
	System.out.println(line);
}

* InputStreamReader 클래스
★★바이트 입력 스트림을 캐릭터 입력 스트림으로 바꾸기 위한 클래스
바이트 단위로 읽은 후 문자로 바꾸어 처리함
생성자는 InputStreamReader(InputStream in)
int read( )
1개 문자를 읽어 리턴함
int read(char[] cbuf, int offset, int length)

★★InputStreamReader isr = new
	InputStreamReader(System.in); // System.in, 즉, InputStream 객체(1 바이트만 읽을 수 있는 것)를 감쌈
try {
	while((i = isr.read( )) != '끝') { // isr.read( ) 하면 2바이트 문자 단위로 읽기 가능(한글 가능)
		System.out.print((char) i);
}
} catch ( … … 

* Java 프로그램에서는 스트림을 통해 데이터 생산자(또는 소비자)의 종류와 무관하게 동일한 방법으로 입력(또는 출력)을 수행할 수 있다.
* File 클래스는 파일(또는 디렉터리)를 표현하는 클래스로 파일(또는 디렉터리)를 조작할 수 있는 메소드를 제공하나 입출력 메소드는 제공하지 않는다.
* RandomAccessFile 클래스는 파일의 읽기/쓰기를 지원하며 파일 포인터가 가리키는 임의의 위치에 읽기/쓰기가 가능하다.
* BufferedInputStream(OutputStream)과 BufferedReader(Writer)는 보조 스트림으로 버퍼링 기능을 제공하여 입출력 성능을 향상시킨다.
* 기본 스트림의 객체를 먼저 생성하고, 그 객체를 인자로 하여 보조 스트림 객체를 생성한다.
* InputStreamReader는 바이트 스트림으로 읽어들인 데이터를 캐릭터 스트림으로 변환시킨다.









*****************************************************************************
10강. java.nio 패키지의 활용
*****************************************************************************

* java.nio 패키지
NIO는 ‘New Input Output의 약자’
기존 java.io 패키지를 개선한 새로운 입출력 패키지
JDK 7부터는 파일 I/O를 개선한 NIO2도 등장
java.nio와 그것의 서브 패키지 형태(java.nio.file , java.nio.channels, java.nio.charset 등)
File 클래스보다 다양한 기능을 제공하는 Path 인터페이스
Files의 static 메소드를 통한 파일/디렉터리의 조작, 파일의 읽기/쓰기
입력과 출력이 모두 가능한 FileChannel 클래스 : 버퍼링 기능, 멀티스레드에 안전
★비동기식 입출력을 위한 AsynchronousFileChannel 클래스 : non-blocking 방식 파일 입출력. 입출력을 별도의 쓰레드로 관리하고 프로그램은 다른 작업을 수행하게끔 함. 즉 멀티쓰레드

* Path 인터페이스
 java.nio.file 패키지에 존재하며 java.io.File 클래스를 대신함
파일시스템에 존재하는 파일이나 디렉터리에 해당하는 경로를 표현함 : 절대 경로 또는 상대 경로로 표현됨
경로의 생성, 경로의 비교, 경로 정보 추출, 경로 요소 조작 기능 등을 제공
★java.nio.file.Files 클래스의 static 메소드를 이용해 Path 객체에 대한
다양한 실제 조작(읽기, 쓰기, 복사, 이동 등)이 가능함

Path 객체의 생성 방법
★java.nio.file.Paths.get(＂C:\\tmp\\foo＂) // Path 인터페이스를 구현한 클래스의 객체(FileSystems.getDefault( ) 후에 JVM이 다루는 기본 파일 시스템이 리턴이 되고, FileSystem 객체.getPath()의 축소 버전이 java.nio.file.Paths.get(＂C:\\tmp\\foo＂)임)
파일이나 디렉터리 경로(절대 또는 상대 경로)를 명시해야 함

* Path 인터페이스의 메소드(아래는 모두 인스턴스 메소드 객체.compareTo(또 다른 객체) 이런식으로 사용)
int compareTo(Path other) : 두 경로를 비교
Path getFileName( ) : 파일 또는 디렉터리 이름을 Path 객체로 리턴
FileSystem getFileSystem( ) : Path 객체를 생성해준 파일 시스템 객체를 리턴(상대 경로 리턴).★FileSystems.getDefault( )과 동일(FileSystems.getDefault( )은 기본 파일 시스템을 리턴함)
Path getName(int index) : C:\\temp\\foo 여기서 temp의 인덱스는 0, foo는 1, Path 객체 리턴
int getNameCount( ) : 경로에 포함된 디렉터리나 파일의 개수. Path에 존재하는 요소의 개수. 위의 경우 2가 리턴
Path getParent( ) : 경로의 맨 오른쪽을 제외한 것. 절대 경로 리턴
Path getRoot( ) : 루트 리턴. 절대 경로 리턴
Iterator<Path> iterator( ) : Path 요소를 다룰 수 있도록. Iterator는 인터페이스. 이걸 구현한게 Scanner 클래스
File toFile( ) : java.io 패키지의 파일과의 호환성을 위해. Path 객체.toFile() 이렇게 하면 io 패키지의 파일 객체를 리턴 받을 수 있다.
String toString( )

* ★★Path 인터페이스 사용 예
import java.util.*;
import java.nio.file.*;
public class PathTest {
	public static void main(String args[ ]) {
		try {
			Path path = Paths.get("C:\\windows\\system32\\drivers\\etc\\hosts"); // Path 객체 만들기
			System.out.println("파일 이름 : " + path.getFileName( )); // hosts 리턴
			System.out.println("상위 폴더 : " + path.getParent( ).getFileName( )); // getParent()로 인해 처음부터 etc까지 나오고, 거기에 getFileName()이니까 etc 리턴(Path 객체 리턴)
			System.out.println("경로 길이 : " + path.getNameCount( ));
			System.out.print("현재 경로 : ");★★★
			for (int i = 0; i < path.getNameCount( ); i++)
				System.out.print(path.getName(i) + "\\");
			Iterator<Path> it = path.iterator( );
			System.out.print("\n현재 경로 : ");
			while (it.hasNext( ))
				System.out.print(it.next( ).getFileName( ) + "\\");
		} catch (Exception e) {
			System.out.println(e);
		}
	}
}
파일 이름 : hosts
상위 폴더 : etc
경로 길이 : 5
현재 경로 : windows\system32\drivers\etc\hosts\
현재 경로 : windows\system32\drivers\etc\hosts\

* FileSystem과 FileStore 클래스
FileSystem의 메소드(FileSystem은 java.nio.File 패키지에 있는 클래스)
FileSystem은 파일 시스템에 대한 인터페이스를 제공
하나 이상의 파일 스토어로 구성됨
FileSystems.getDefault( )은 기본 파일 시스템을 리턴함
★Iterable <FileStore> getFileStores( ) : Iterable 유형의 파일스토어들로 이루어진 객체가 리턴됨. 여기서 Iterable은 향상된 for문에서 오른쪽에 들어갈 수 있음(Iterable은 for문으로, Iterator는 while안에 hasNext()로)
WatchService newWatchService( )

FileStore의 메소드
FileStore는 파티션(또는 볼륨)을 표현함
String name( ), String type( )
long getTotalSpace( ),
long getUnallocatedSpace( ), long getUsableSpace( )

import java.nio.file.*;
public class FileSystemTest {
	public static void main(String args[]) throws Exception { // ★파일입출력, 파일시스템, 파일스토어 관련해서는 보통 IOException 처리해야함
		FileSystem fs = FileSystems.getDefault( );
		for (FileStore store : fs.getFileStores( )) { // ★Iterable <FileStore> getFileStores( ), Iterable은 for문으로, Iterator는 while안에 hasNext()로
			System.out.println("드라이브 이름 : " + store.name( ));
			System.out.println("파일시스템 타입 : " + store.type( ));
			long total = store.getTotalSpace( );
			long free = store.getUnallocatedSpace( );
			System.out.println("전체 공간 : " + total + " bytes");
			System.out.println("사용 중인 공간 : " + (total - free) + "bytes");
			System.out.println("사용 가능한 공간 : " + free + " bytes");
			System.out.println( );
		}
	}
}
드라이브 이름 : C드라이브
파일시스템 타입 : NTFS
전체 공간 : 2000290836480 bytes
사용 중인 공간 : 97686507520 bytes
사용 가능한 공간 : 1902604328960 bytes

* Files 클래스
파일 조작 기능을 제공하는 static 메소드를 제공함
★메소드는 Path 객체를 인자로 가지고 작업함

파일의 읽기와 쓰기
byte[ ] readAllBytes(Path)
Path write(Path, byte[ ]) : 파일 출력, byte[ ] 배열에 있는 내용을 Path가 표현하는 파일에 write

파일이나 디렉터리의 검사/생성/삭제/복사/이동/속성관리
boolean isDirectory(Path)
boolean isRegularFile(Path) : 정규 파일이냐
이 밑에서부터는 IOException 처리 해야함
Path createFile(Path)
void delete(Path) : 디렉터리를 delete할 경우 디렉터리가 empty인 경우만 delete 가능
Path copy(Path, Path)
Path move(Path, Path) : 이동 또는 이름 바꾸기
long size(Path), UserPrincipal getOwner(Path)

import java.nio.file.*;
public class FilesTest2 {
	public static void main(String args[ ]) throws Exception {
		Path path = Paths.get("C:\\Java");
		DirectoryStream<Path> ds = Files.newDirectoryStream(path); // ★newDirectoryStream(path) : 인자로 들어간 path가 디렉터리라고 보고, 이 디렉토리에 포함된 목록들, 즉, 파일들이나 서브 디렉터리들을 확인하기 위한 메소드, ★DirectoryStream는 Iterable의 서브 인터페이스로 보면 됨. 그래서 향상된 for문 오른쪽에 들어갈 수 있음
		for (Path p : ds) {
			if (Files.isDirectory(p)) { // 디렉터리인 경우
				System.out.println("[디렉터리] " + p.getFileName( ));
			} else { // 파일인 경우
				System.out.print("[파일] " + p.getFileName( ));
				System.out.println(" (" + Files.size(p) + ")");
			}
		}
	}
}
[디렉터리] Example
[파일] FileInputStreamTest.java (434)
[파일] FilesTest1.java (800)
[디렉터리] temp
[파일] winhlp.exe (9728)
[파일] winhlp32.exe (9728)

* 버퍼
데이터 생산자와 프로그램(입력), 프로그램과 데이터 소비
자(출력) 간 속도 차로 인해 지연이 발생할 수 있음
버퍼를 사용하면 지연 현상을 방지할 수 있음
프로그램은 버퍼로부터 데이터를 읽음(입력)
프로그램은 버퍼로 데이터를 출력함(출력)
Java 프로그램 <- Input Buffer <- 데이터 생산자
Java 프로그램 -> Output Buffer -> 데이터 소비자

* Buffer 클래스
★버퍼는 기본형 값을 저장하는 데이터 보관소
채널 입출력에 사용되며 버퍼 단위로 입출력할 수 있음
java.nio 패키지에 존재하며, ★Buffer는 추상 클래스
자식 클래스에서 구현해야 할 공통의 메소드를 선언
실제 사용을 위해 boolean을 제외한 모든 기본형에 대해 서브 클래스가 존재함(자식 클래스)
ByteBuffer, CharBuffer , DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer

* 버퍼의 생성
버퍼의 생성
1. Buffer buffer = ByteBuffer.allocate(1024*1024); // allocate는 static 메소드
자바 가상기계가 관리하는 메모리에 버퍼를 생성 :  allocate()
운영체제가 관리하는 메모리에 버퍼를 생성 :  allocateDirect()
2. byte[ ] barray = new byte[100]; Buffer bbuffer = ByteBuffer.wrap(barray);

* 버퍼의 속성
★(0 <= mark <= position <= limit <= capacity)
capacity : 버퍼의 크기(데이터의 개수)로 생성될 때 정해짐, 변하지 않음. 버퍼에 저장되는 데이터의 개수(바이트 수가 아니고 저장될 수 있는 데이터 수)
position : 읽기나 쓰기가 적용되는 위치 (position <= limit). 최초의 position은 0. 처음 write한다고 했을 때, 처음 position이 0이니까 0번부터 write 됨
limit : 읽거나 쓸 수 없는 최초 위치 (limit <= capacity). 버퍼가 처음 만들어질 때 limit은 설정되어 있지 않음(근데 뒤에서는 또 처음에 설정된다고 함). 즉, undefined 상태. ★flip 메소드는 버퍼에 담겨있는 데이터를 내보낼 때 사용되는데, flip 메소드 후 position은 0이 되고, 그 때 당시(flip메소드 호출 시점)의 position 값이 limit로 설정됨(limit값-1까지만 유효함. 유효한 데이터의 저장위치 바로 다음 위치가 limit)
mark : 버퍼가 reset( ) 되었을 때 position이 가리킬 위치. mark가 호출되면 그 시점에서의 포지션 값이 mark 값으로 설정됨. reset하면 mark를 호출했을 때의 position값으로 position 값이 재설정됨

* Buffer 클래스의 메소드
Buffer mark( ) : mark를 position의 값으로 설정
Buffer reset( ) : position을 mark의 값으로 설정
Buffer rewind( ) : position을 0으로 바꾸고 mark를 삭제, 처음부터 다시 읽기를 준비하는 것
Buffer flip( ) : limit를 position 값으로 설정(★쓰기 작업을 한 만큼만 읽어야 하니까), position은 0으로 변경. 버퍼에 쓰기를 끝내고, 버퍼 읽기를 준비하는 것. 실제 유효한 데이터는 limit-1까지임
Buffer clear( ) : 버퍼를 초기 상태로 돌림. 새로운 쓰기를 준비하는 것(position은 0으로, capacity와 limit은 버퍼의 크기로)

0부터 9까지 있다고 할 때, 처음 버퍼가 생성되면 position은 0이고, capacity와 limit은 9인데, 실제 유효한 버퍼는 8까지. mark는 undefined 상태

* 버퍼 읽기와 쓰기(스트림에서는 바이트나 캐릭터 단위로 읽거나 썼다면, nio에서는 버퍼 단위로 읽고 씀)
Buffer의 서브클래스에서 제공
ByteBuffer, CharBuffer, DoubleBuffer, …

상대적 읽기/쓰기 메소드(ByteBuffer에서)
현재 position에서 읽기 또는 쓰기를 수행하며, 읽거나 쓴 요소 만큼 position 값이 증가함

읽기
★byte get() : 읽거나 쓴 요소만큼 1증가(1byte)
★ByteBuffer get(byte[ ]) : 읽거나 쓰고나면 ByteBuffer의 개수만큼 증가

쓰기
ByteBuffer put(byte), ByteBuffer put(byte[ ])

★절대적 읽기/쓰기 메소드(데이터 하나만. 아래에서는 1byte만 읽거나 쓸 수 있음)
position 값에 영향을 주지 않음
byte get(int index) : 여기서 index는 어느 위치에서 읽을것이냐
ByteBuffer put(int index, byte b) : 어느 위치에 기록할 것이냐

* FileChannel 클래스(스트림에서는 바이트나 캐릭터 단위로 읽거나 썼다면, nio에서는 버퍼 단위로 읽고 씀)
java.io 패키지의 파일 관련 입출력 스트림을 대체
java.nio.channels 패키지에 존재
파일에 대한 읽기와 쓰기를 모두 제공
멀티 스레드 환경에서도 안전하게 사용할 수 있음
읽기와 쓰기 메소드
int read(ByteBuffer dst) : 실제 파일로부터 읽어서 ByteBuffer에 기록
int write(ByteBuffer src) : ByteBuffer에 있는 내용을 실제 데이터 소비자에 속하는 파일 채널에 전달

FileChannel 객체의 생성 방법
1. FileChannel.open(Path path, OpenOption … options)
옵션은 StandardOpenOption.READ 등(열거형으로 파일을 오픈할 때 읽기용으로 오픈한다는 의미)
WRITE는 쓰기용, CREATE는 생성하겠다
2. FileInputStream 이나 RandomAccessFile 객체에서 getChannel( ) // 기존 java.io와의 호환성을 위함

* FileChannel 클래스에 관한 설명으로 틀린 것은 무엇인가?
java.io 패키지의 파일 관련 스트림 클래스를 대체하기 위한 클래스이다.
FileChannel.open(path)으로 객체 생성을 하면 해당 파일을 읽기용으로 열게 된다.
멀티 스레드 환경에서도 안전하게 사용할 수 있게 설계되었다.
이것만 틀림 -> 파일 입력을 위해 FileChannelReader, 파일 출력을 위해 FileChannelWriter를 사용한다.

* ★★★FileChannel 클래스로 파일 만들기
import … …
public class FileChannelWriteTest{
	public static void main(String args[ ]) throws IOException{ // ★IOException 주의
		String[ ] data = {"안녕하세요, 여러분",… …, "모든 방법에 대해 공부해봅시다."};
		Path path = Paths.get("c:\\Java\\temp\\file.txt");
		Files.createDirectories(path.getParent( )); // ★Files의 static 메소드인 createDirectories를 이용해서 부모 디렉터리 중 존재하지 않을 수 있는 디렉터리를 먼저 만들어주기
		FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE); // 파일 시스템에 파일 생성 // FileChannel.open()을 이용해서 객체 생성, option은 여러 개 줄 수 있음. CREATE는 path에 해당하는 파일이 없다면 생성하겠다는 것
		Charset charset = Charset.defaultCharset( ); // JVM의 기본문자세트를 리턴 받아옴(한글때문)
		ByteBuffer buffer;
		int byteCount = 0;
		for(int i = 0;i < data.length;i++) {
			buffer = charset.encode(data[i]); // 기본문자세트를 이용해서 인코드 메소드 호출, ByteBuffer를 리턴
			byteCount = fileChannel.write(buffer);
		}
		fileChannel.close( );
	}
}
안녕하세요, 여러분Java 프로그래밍 언어의
세계로 오신 것을 환영합니다. JDK를 설치하는
방법에서부터Java 프로그램을 compile하고
실행시키는 모든 방법에 대해 공부해봅시다.

* ★★★FileChannel 클래스로 파일 읽기
import … …
public class FileChannelReadTest {
	public static void main(String args[ ]) throws IOException {
		Path path = Paths.get("c:\\java\\temp\\file.txt");
		FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ); // 읽기용
		ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);
		Charset charset = Charset.defaultCharset( );
		StringBuffer sb = new StringBuffer( );
		int byteCount;
		while ((byteCount = fileChannel.read(buffer)) >= 0) { // read하면서 buffer의 position 값이 증가, // 버퍼 크기보다 파일 크기가 클 수 있기 때문에 fileChannel.read 작업을 여러 번 해야하기 때문에 while문 안에 보면 clear가 있어서 버퍼를 초기화
			buffer.flip( ); // ★버퍼에 기록된 것을 읽기. position 값을 0으로. flip 메소드 호출 당시의 position 값을 limit 값으로 설정 -> 기록된 만큼만 읽겠다는 말
			sb.append(charset.decode(buffer)); // 위의 예제에서 인코딩되어서 파일에 기록이 되었기 때문에 이번에는 디코딩해야함(문자열을 인코드해서 바이트 버퍼로 바꿨는데, 그걸 반대로 바이트 버퍼를 디코드해서 문자열로해서 받기) 
			buffer.clear( );
		}
			System.out.println(sb);
			fileChannel.close;
	}
}
안녕하세요, 여러분Java 프로그래밍 언어의
세계로 오신 것을 환영합니다. JDK를 설치하는
방법에서부터Java 프로그램을 compile하고
실행시키는 모든 방법에 대해 공부해봅시다.

* WatchService 인터페이스
어떤 대상(디렉터리)에 대해 변화나 이벤트가 생기는 것을 감시(watch)
디렉터리의 변화를 감지
디렉터리 내의 파일 또는 서브 디렉터리의 생성, 삭제, 수정
java.nio.file 패키지에 존재

감시자의 생성
먼저 WatchService 객체를 생성함
WatchService ws = FileSystems.getDefault( ).newWatchService( );

★FileSystems.getDefault( )의 활용
FileSystems.getDefault( ).newWatchService( );
FileSystems.getDefault( ).getPath()
FileSystems.getDefault( ).getFileStore()

* 감시 서비스를 구현하는 절차
1. 감시 대상 디렉터리를 WatchService에 등록
Path path = Paths.get("c:\\java\\temp");
알림을 받고자 하는 이벤트를 명시
path.register(ws, StandardWatchEventKinds.ENTRY_CREATE,
StandardWatchEventKinds.ENTRY_DELETE,
StandardWatchEventKinds.ENTRY_MODIFY);

2. WatchService는 take( ) 메소드를 호출하여 감시함
무한 루프 안에서, 이벤트가 발생할 때 까지 기다림
While(true) {
WatchKey key = ws.take( ); // WatchKey는 디렉터리 안에 관심 이벤트가 등록이 되어 있는데, 실제로 어떠 어떠한 이벤트가 발생했다는 상태 표현
WatchKey는 등록된 디렉터리에 어떤 관심 이벤트가 등록되어 있으며, 실제 어떤 이벤트가 일어났는지에 관한 상태 정보를 가지고 있다.

3. 이벤트가 발생하면, take( )가 리턴하는 WatchKey 객체를 이용하여 이벤트를 처리
WatchKey는 감시 대상 객체의 상태 정보를 가짐, pollEvents( )를 호출하여 WatchEvent 객체를 얻고(list 유형으로 얻을 수 있음) 어떤 변화가 생겼는지 알 수 있음
for (WatchEvent<?> event : key.pollEvents( )) {
	WatchEvent.Kind k = event.kind( ); // 이벤트 종류
	Path p = (Path)event.context( ); // 파일 이름
	… …
}
boolean valid = key.reset(); // 계속 감시하기 위해, WatchKey를 ready 상태로 돌림
if (!valid) break; // ★디렉터리가 삭제되는 등의 경우 false가 리턴되기 때문에 valid 상태가 아니기 때문. valid 하면 다시 돌고, valid가 아니면 if문을 타서 break이 된다.
}

* ★★WatchService 예제
public class WatchServiceTest {
	public static void main(String args[]) {
		try {
			WatchService ws;
			ws = FileSystems.getDefault().newWatchService();
			Path path = Paths.get("c:\\java\\temp"); // 감시 대상 디렉터리
			path.register(ws, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY); // WatchService인 ws에 등록. CREATE, DELETE, MODIFY가 관심목록. 참고로 디렉터리 내 파일의 이름을 바꾸면 DELETE 됐다가 CREATE 되는 것임
			while (true) { // 무한루프
				WatchKey key = ws.take(); // 기다리다가 이벤트가 발생하면 take가 리턴됨
				for (WatchEvent<?> event : key.pollEvents()) {
					WatchEvent.Kind k = event.kind();
					Path p = (Path) event.context();
					if (k == StandardWatchEventKinds.ENTRY_CREATE) {
						System.out.println("File " + p.getFileName() + " is created.");
… …
				}
				boolean valid = key.reset();
				if (!valid) break;
			}
… …
File 새 텍스트 문서.txt is deleted.
File 새 텍스트.txt is created.

* java.nio와 그것의 서브 패키지는 java.io 패키지를 개선한 새로운 입출력 패키지이다.
* java.nio.file 패키지의 Path 인터페이스는 java.io 패키지의 File 클래스보다 풍부한 기능을 제공한다.
* Files 클래스는 실제 파일(또는 디렉터리) 조작과 읽기/쓰기 기능을 수행하는 static 메소드를 제공한다.
* java.nio.file의 FileChannel은 입출력을 모두 제공하고 기본적으로 버퍼링을 사용하며 멀티 스레드 환경에서도 안전하도록 설계되어 있다.
* java.nio.file 패키지의 WatchService는 디렉터리에 발생하는 이벤트를 감시하는 서비스이다.
* AsynchronousFileChannel 클래스를 이용하면 논-블로킹 방식 입출력을 지원하여 read(), write() 작업이 완료되지 않더라도 다른 작업을 동시에 수행할 수 있다.









*****************************************************************************
11강. 컬렉션
*****************************************************************************

* 컬렉션
여러 원소를 하나의 그룹으로 묶어 관리해주는 객체

* Java Collections Framework(JCF)
컬렉션을 표현하고 다루기 위한 통합된 프레임워크로 클래스와 인터페이스의 집합
다양한 방식으로 저장, 정렬, 검색, 수정하는 도구를 제공

컬렉션을 일관된 방법으로 다룰 수 있음
표준화된 인터페이스: 컬렉션의 기능을 표현
어떻게 표현되는 지와 상관없이 일관성 있게 다룸
클래스: 인터페이스를 구현한 클래스를 제공

* JCF의 구조
JCF의 인터페이스
Set(집합): 순서는 의미가 없으며 중복을 허용하지 않는 자료구조
List: 중복을 허용하고 순서에 의미가 있는 자료구조
Queue: List와 유사하나 원소의 삽입/삭제가 FIFO 방식
Map: 원소가 <key, value>의 형태이며 키는 유일해야 함
Iterable <- Collection <- Set <- SortedSet(상위 인터페이스가 Iterable이기 때문에 forEach의 오른쪽에 들어갈 수 있음)
Iterable <- Collection <- List(상위 인터페이스가 Iterable이기 때문에 forEach의 오른쪽에 들어갈 수 있음)
Iterable <- Collection <- Queue <- Dequeue(상위 인터페이스가 Iterable이기 때문에 forEach의 오른쪽에 들어갈 수 있음)
Map <- SortedMap

* JCF의 인터페이스와 클래스
java.util 패키지에 포함되며 제네릭 타입
다루는 자료의 유형을 지정해야 함

해싱 : 저장공간 안에 데이터가 비교적 균일하게 골고루 저장되도록 하는 기법
LinkedList(연결리스트) : List 인터페이스와 Queue 인터페이스를 구현한 클래스. 변수 선언 시 List 유형으로 할지, Queue 유형으로 할지 정해야함
List<Integer> list = new LinkedList<>();
Queue<Integer> queue = new LinkedList<>();

		Set 		List 		Queue	 	Map
해싱 		HashSet 						HashMap

배열 				ArrayList
				Vector(Stack)

연결리스트 			LinkedList 	LinkedList

해싱+연결리스트	LinkedHashSet 					LinkedHashMap
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
		SortedSet 					SortedMap
트리 		TreeSet 						TreeMap

* ★컬렉션 객체의 선언
변수 선언은 해당 인터페이스 유형으로, 객체 생성은 인터페이스를 구현하는 클래스를 사용
Set<Integer> set = new HashSet<>();
List<Integer> list = new ArrayList<>();
List<Integer> list = new LinkedList<>();
Queue<Integer> queue = new LinkedList<>();
Map<String, Integer> map = new HashMap<>();

* Collection<E> 인터페이스
Collection<E> : Set, List, Queue의 슈퍼 인터페이스
Set, List, Queue에서 공통으로 지원해야 하는 기능을 정의

원소 삽입 / 삭제 메소드(아래 메소드 중 리턴 타입이 boolean인 것들은 컬렉션에 변화를 주면 true를 리턴함, 변화가 없으면 false)
boolean add(E e)
boolean addAll(Collection<? extends E> c)
boolean remove(Object o) : 내부적으로 equals가 쓰임
boolean removeAll(Collection<?> c)
boolean retainAll(Collection<?> c) : 인자로 주어지는 컬렉션에 있는 원소만 남겨두고 나머지는 삭제
void clear( ) : 컬렉션의 모든 원소 삭제

원소 탐색 메소드
boolean contains(Object o) : 인자로 주어지는 것이 있는지, 내부적으로 equals가 쓰임
boolean containsAll(Collection<?> c) : 인자의 모든 원소가 존재하는지
boolean isEmpty( )

기타 메소드
int size( ) : 원소의 개수
int hashCode( ) : 두 컬렉션의 size와 순서가 같으면 hashCode 값도 같다. (해당 유형별로 equals 메소드로 인해 같다면)
Object[ ] toArray( ) : 원소들을 객체 배열로 리턴
Iterator<E> iterator( )
boolean equals(Object) : 컬렉션 자체가 같은지 비교하는 메소드

** HashSet, ArrayList, LinkedList 클래스
* HashSet 클래스 예제
import java.util.*;
public class HashSetTest {
	public static void main(String args[]) {
		Set<String> set = new HashSet<String>( );
		set.add("one"); set.add("two");
		set.add("three"); set.add("four");
		System.out.println(set.add(new String("one"))); // ★false를 리턴. Set은 중복 허용 불가
		System.out.println(set.size( )); // 4
		System.out.println(set.contains("four")); // true 리턴, String의 equals 메소드로 비교한다.
		System.out.println(set.contains("one")); // true
		System.out.println(set.contains(new String("one"))); // true
		set.remove("four");
		set.remove(new String("one"));
		System.out.println(set.size()); // 2
		set.clear( );
		System.out.println(set.size( )); // 0
	}
}
false
4
true
true
true
2
0

* ArrayList 클래스
List 인터페이스를 구현한 클래스
★크기 조절이 가능한 배열로 구현(여러 원소를 저장하기 위해 배열을 사용한다.)
같은 자료가 중복될 수 있으며, 입력된 순서대로 관리됨
특정 위치의 자료를 참조할 수 있음
List 인터페이스를 살펴봐야 함

* ArrayList 클래스의 메소드
boolean add(E e)
void add(index, E element) : 해당 index에 element 추가
boolean remove(Object o) : 삭제 성공하면 true, 실패 시 false 리턴
E remove(int index) : 삭제 후 삭제한 값 리턴
E get(int index)
E set(int index, E element) : 해당 index 값을 element로 대체하고, 대체된 값이 리턴됨
int indexOf(Object o) : 앞에서부터 o를 찾아서 o의 위치 리턴, ★없으면 -1 리턴
int lastIndexOf(Object o) : 뒤에서부터 찾음, 없으면 -1 리턴

* List<E> 인터페이스
순서가 있고 중복을 허용하는 구조
원소를 순차적으로 처리하는 구조
첨자에 의한, 특정 위치의 원소 처리가 가능

* List<E> 인터페이스의 메소드
int indexOf(Object o)
int lastIndexOf(Object o)
E set(int index, E element)
List<E> subList(int from, int to) : ★from부터 to-1까지의 list를 리턴
E remove(int index) : 해당 index의 값 삭제 후 그 값을 리턴
boolean remove(Object o) : 해당 객체 o를 찾아서 삭제
ListIterator<E> listIterator( ) : Iterator의 서브 인터페이스인 ListIterator. 리스트에 존재하는 원소들을 while문으로 다룸. ListIterator는 hasPrevious, previous도 가지고 있음.
ListIterator<E> listIterator(int index)

* ArrayList 클래스 예제
import java.util.*;
public class ArrayListTest {
	public static void main(String args[]) {
		List <String> list = new ArrayList <String> ( );
		list.add("one"); list.add("two");
		list.add("three"); list.add(1, "one"); //삽입
		list.add("five");
		System.out.println(list.size( )); // 5
		System.out.println(list.indexOf("one")); // 0
		System.out.println(list.get(2)); // two
		System.out.println(list.lastIndexOf("one")); // 1
		System.out.println(list.set(3, "four")); // ★three // E set(int index, E element) : 해당 index 값을 element로 대체하고, 대체된 값이 리턴됨
		System.out.println(list.remove(4)); // five // ★E remove(int index) : 삭제 후 삭제한 값 리턴
		System.out.println(list.remove("one")); // true // ★boolean remove(Object o) : 삭제 성공하면 true, 실패 시 false 리턴
	}
}
5
0
two
1
three
five
true

import java.util.*;
public class ArrayListTest2 {
	public static void main(String args[ ]) {
		List<String> list = new ArrayList<String>( );
		list.add("one");
		list.add("two");
		list.add("three");
		list.add("four");
		list.add("five");
	// for 구문을 이용한 자료 탐색
		for (int i = 0; i < list.size( ); i++)
			System.out.println(list.get(i));
	// ★foreach 구문을 이용한 자료 탐색
		for (String s : list)
			System.out.println(s);
	// ★Iterator 인터페이스를 이용한 자료 탐색
		Iterator<String> it = list.iterator();
		while (it.hasNext( ))
			System.out.println(it.next( ));
	}
}

* ★★★람다식 이용
import java.util.*;
import java.util.function.Consumer;
public class ArrayListTest {
	public static void main(String args[ ]) {
		List <String> list = new ArrayList<String>( );
		list.add("one"); list.add("three");
		list.add("two"); list.add(1, "one");
		Consumer<String> con1 = new Consumer<>() { // ★익명 클래스
			public void accept(String t) { // accept 메소드를 구현함
				System.out.println(t); // 하나의 인자를 받아서 바로 출력
			}
		};
		list.forEach( con1 ); // ★★forEach : 개별 객체 다룰 수 있음. 인자로 Consumer 인터페이스를 구현한 클래스의 객체가 들어감, list는 Iterable 객체

		Consumer<String> con2 = t -> System.out.println(t); // ★★람다식, 위에걸 좀 더 축약한 것
		list.forEach( con2 );

		list.forEach( t -> System.out.println(t) ); // ★★위에 것을 더 축약한 것
	}
}

* Iterator<E> 인터페이스
컬렉션에 저장된 원소를 차례대로 다룰 수 있음
다음 메소드를 제공 / boolean hasNext( ), E next( ), void remove( ) : 마지막 원소 삭제
HashSet, ArrayList, LinkedList 등(★Iterable)에서 Iterator 객체를 리턴하는 메소드가 정의됨

List <String> list = new ArrayList <String> ( ); // ★Iterable
Iterator <String> it = list.iterator( );
while(it.hasNext( ))
	System.out.println(it.next( ));
Scanner 객체도 Iterator 인터페이스를 구현한 유형

* LinkedList(연결 리스트) 클래스
1. ArrayList와 마찬가지로 List 인터페이스를 구현한 클래스
앞의 예제에서 ArrayList를 LinkedList로 바꿔도 됨

2. Queue 인터페이스를 구현함
스택 자료구조에서 필요한 메소드도 제공함
void push(E), E pop( ) //앞에서 넣거나 뺌

★Queue 인터페이스의 메소드
boolean offer(E) // 뒤에 넣고(삽입), poll과 짝. add와 다른 점은 Queue가 꽉차서 더 이상 삽입할 수 없을 때도 예외를 발생시키는 것이 아니라 false를 리턴함
boolean add(E) // 뒤에 넣고(삽입), remove와 짝, Queue가 꽉차면 Exception 발생
E poll( ) // 앞에서 빼고(삭제), offer와 짝, 더 이상 삭제할 것이 없으면 null을 리턴하고, 정상적으로 삭제되면 삭제된 원소가 리턴
E remove( ) // 앞에서 빼고(삭제), add와 짝, 더 이상 삭제할 것이 없으면 예외 발생(NoSuchElementException)
E peek( ), E element( ) : 대기열의 맨 앞에 있는 원소를 삭제하는 것이 아니라 해당 값만 리턴함

* LinkedList를 이용하여 큐를 구현한예제
import java.util.*;
public class QueueTest {
	public static void main(String args[]) {
		LinkedList<String> queue = new LinkedList<String>( ); // ★이거 잘못됨. 아래와 같이 써야함
		Queue<String> queue = new LinkedList<String>();
		queue.offer("one"); queue.offer("two");
		queue.offer("three"); queue.offer("four");
		String s = queue.poll( );
		while (s != null) {
			System.out.println(s);
			s = queue.poll( ); // ★★마지막에 null을 리턴하여 while문을 빠져나감
		}
	}
}
one
two
three
four

** HashMap 클래스
* Map<K, V> 인터페이스
(key, value)을 갖는 원소로 구성되는 컬렉션을 다루기 위한 인터페이스
key는 중복되지 않으며, 하나의 key에 하나의 value만 대응됨

메소드
V put(K key, V value) : ★만약 이미 해당 key가 있으면 그 key에 해당하는 value값이 put으로 전달한 value 값으로 바뀌게 된다.
V get(Object key)
V remove(Object key)
boolean containsKey(Object key)
Collection<V> values( ) : ★컬렉션이 아니기 때문에 탐색 방법이 다름. value들로만 이루어진 컬렉션을 리턴
Set<K> keySet( ) : ★키들로 이루어진 Set을 리턴. key들은 중복되지 않기 때문에 Set이 리턴

* HashMap 클래스
해싱을 이용하여 Map 인터페이스를 구현한 클래스
자료 탐색 방법이 ArrayList나 LinkedList 클래스와 다름
복잡한 자료 관리(교재의 예)
1. 명단
names = ArrayList<이름> 객체
김철수, 이영희

2. 성적부
scores = HashMap<이름, 성적 객체
<김철수, 개별 성적 Map>
<이영희, 개별 성적 Map>

3. 개별 성적
lectures = HashMap<과목, 점수> 객체
국어 100
영어 95
등
자세한 것은 아래 코드를 보자

* 복잡한 자료관리-HashMap 클래스 예제
import java.util.*;
public class HashMapTest {
	public static void main(String args[ ]) {
		List <String> names = new ArrayList<String> ( ); // 명단
		Map <String, Integer> lectures; // 개별 성적
		Map <String, Map> scores = new HashMap<>( ); // 성적부
		names.add("김철수"); names.add("이영희");
		Iterator <String> it = names.iterator();
		while(it.hasNext( )) {
			String name = it.next();
			if (name.equals("김철수")) {
				lectures = new HashMap<String, Integer>( );
					lectures.put("국어", 100);
				lectures.put("영어", 95);
				lectures.put("수학", 80);
				scores.put(name, lectures);
			} else if (name.equals("이영희")) {
				lectures = new HashMap<String, Integer>( );
				… … …
				scores.put(name, lectures);
			}
		}

		Iterator <String> it2 = names.iterator( );
		while(it2.hasNext()) {
			String name = it2.next();
			System.out.println(name);
			System.out.print("국어 : ");
			System.out.println(
			scores.get(name).get("국어"));
			System.out.print("영어 : ");
			System.out.println(
			scores.get(name).get("영어"));
			System.out.print("수학 : ");
			System.out.println(
			scores.get(name).get("수학"));
			System.out.println( );
		}
	}
}
김철수
국어 : 100
영어 : 95
수학 : 80
이영희
… …
★위에서
Iterator <String> it2 = names.iterator( );
		while(it2.hasNext()) {
		}
부분을 아래와 같이 변경 가능
for (String name : scores.keySet()) {}


* 컬렉션은 여러 원소를 하나의 그룹으로 묶은 객체를 통칭하는 용어이며, JCF는 컬렉션을 표현하고 다루기 위한 통합 프레임워크이다.
* Set은 순서는 상관없지만 중복을 허용하지 않는 자료를 다루기 위한 인터페이스이다.
* List와 Queue는 자료의 중복을 허용하고 순서를 고려하여 관리하는 인터페이스이다. 특히 Queue는 FIFO 방식으로 자료를 관리하는 인터페이스이다.
* Map 인터페이스는 <키, 값>의 쌍으로 구성되는 자료를 관리하는 메소드를 제공한다.
* LinkedList 클래스는 List 인터페이스와 Queue 인터페이스를 모두 구현한 클래스로서, 스택 자료구조의 구현에 사용할 수도 있고, 큐 자료구조의 구현에 사용할 수도 있다.


