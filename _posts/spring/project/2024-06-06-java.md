---
layout: single
title: "java"
categories: project
tag: project
toc: true
---

## 자바 요약

※ Java프로그래밍

*****************************************************************************
1강. Java와 객체지향 프로그래밍
*****************************************************************************

* 바이트 코드
-. Java 소스를 컴파일한 결과물(기계어는 아님. 자바 플랫폼인 자바 가상 머신에서 실행가능)
-. 확장자는 .class이며 클래스 파일이라고도 함
-. 자바 플랫폼의 Java VM에서 실행 가능한 코드
-. Write once, run anywhere.

* 자바 프로그램 = 애플리케이션(자바 플랫폼에서 실행되는 프로그램으로 실행을 위해 main() 함수가 필요) + 애플릿(HTML 웹 페이지에 포함되어 웹 브라우저를 통해 실행)
자바 언어는 플랫폼 독립적, 아키텍처 중립적임

* 애플리케이션
-. Java 플랫폼에서 실행되는 프로그램
-. 실행을 위해 main() 함수가 필요함

* 애플릿
-. HTML 웹 페이지에 포함되어 웹 브라우저를 통해 실행

* Java 플랫폼의 구성(JDK라고도 할 수 있음) = JAVA VM + JAVA API
-. Java VM
-. Java API
	: 프로그램의 개발에 필요한 클래스 라이브러리
	: 패키지(클래스 묶음)들이 계층 구조로 분류되어 있음

* Hello, World 출력
public class Test {
    public static void main(String[ ] args) {
        System.out.println("Hello, World!");
    }
}

* public class는 파일에 최대 1개

4. 객체지향 프로그래밍
1) 클래스와 객체
* 추상화(필요한 일부만을 간단히 표현하는 것)
-. 구체적인 모든 사실이 아니라 전형적이고 필요한 부분만을 발췌하여 사물을 이해하고 표현하는 것
-. 클래스(추상화를 통해 프로그램상에서 표현된 것)
	: 클래스는 객체를 만들기 위한 모형 또는 틀
	: 공통적인 특징을 가지는 객체들을 추상화하기 위한 수단
	: 객체의 상태는 필드(데이터)로, 행위는 메소드로 구현됨
	: 객체는 특정 클래스의 인스턴스(실체화된 것)

2) 객체지향 프로그램
* Java 프로그램
-. 클래스가 프로그램 구성의 기본 단위(C언어는 함수)
-. 데이터(필드)와 알고리즘(메소드)이 클래스에 캡슐화되어 있음
-. 클래스 정의로부터 객체들이 만들어지고, 객체들간의 상호작용으로 프로그램이 동작함









*****************************************************************************
2강. Java 기본 문법(1)
*****************************************************************************

* 식별자 : 클래스, 변수, 메소드, 레이블 등의 이름
대소문자 구분, 길이 제한 없음, 숫자 시작 불가, 키워드인 true, false, null 등은 불가, 공백 불가,
영 대소문자, 한글, 숫자, '_', '$' 사용 가능

* 변수 종류
인스턴스 변수 : 객체가 소유하는 변수(클래스 정의에서 static이 아닌 데이터 필드)
클래스 변수 : 객체가 공유하는 변수(클래스 정의에서 static 데이터 필드)
지역 변수 : 메소드 내부(또는 블럭 내부)에서 선언된 변수
파라미터 : 메소드 호출 시 전달하는 값을 저장하기 위한 변수

* 지역 변수와 파라미터 / 데이터 필드(인스턴스 변수 or 클래스 변수)
지역 변수는 초기값을 지정한 후 사용해야 함(데이터 필드는 초기값 지정 안 하면 기본값이 주어짐)
지역 변수 선언에서 접근 제어자를 사용하지 않음(데이터 필드에서만 접근 제어자 사용)

* 리터럴 : 실제 데이터 값

* 0b11010 : 2진수, 032 : 8진수, 0x1a : 16진수

* 기본형 변수는 저장 공간에 값 자체를 저장, 참조형(기본형을 제외한 모든 자료형) 변수는 저장 공간에 참조 값을 저장함(실제 데이터는 별도의 공간에 저장됨)

* if와 else 짝짓기 : else는 자기 짝이 없는 가장 가까운 if와 짝을 이룸

* for-each문 : 형식은 for(변수선언 : 배열) { 문장 ... }
int[] arrayOfInts = {32, 87, 3};
for (int element : arrayOfInts) {
	System.out.print(element + " ");
}

int[ ] a = {32, 87, 3, 589, 12 }; 
for (int i = 0; i < a.length ; i++)   
        System.out.print( a[i] + " " );
↓
for (int element : a)   
        System.out.print( element + " " );

* break문을 포함하는 가장 가까운 switch문, for문, while문, do-while문의 실행을 끝냄
* continue문 : 가장 가까이 있는 반복문의 다음 반복을 위한 조건식으로 즉시 제어를 이동하기 위한 것

* Java의 기본형을 나타내는 키워드는 byte, short, int, long, float, double, char, boolean의 8가지이다.
* 클래스와 배열은 대표적 참조형으로, 참조형 변수에는 참조 값(주소)이 저장된다.
* 명령행 매개변수란 main( ) 함수에 전달되는 인자로서, 프로그램을 실행시킬 때 프로그램의 이름 뒤에 나열하는 인자를 말한다.
* 제어문은 프로그램의 실행 흐름을 제어하는 문장이다.
* break문, continue문, return문은 제어문 중 점프문(분기문)에 해당한다.





*****************************************************************************
3강. Java 기본 문법(2)
*****************************************************************************

* 배열
같은 자료형의 원소를 정해진 개수만큼 가지고 있는 객체
배열의 크기는 선언 이후 배열이 초기화 또는 생성될 때 정해짐(선언할 때는 크기를 지정할 수 없음)
형식은 자료형[] 변수이름; 또는 자료형 변수이름[];

* 배열도 참조형(클래스 유형, 인터페이스 유형, 배열 등 기본형이 아닌 다른 것들) 변수이기 때문에(참조값, 즉 주소값을 가지고 있음, 배열의 경우 배열 원소가 들어가는 공간에 대한 주소값을 가지고 있음) 선언 후 실제 데이터가 들어갈 공간을 할당 받아 사용한다.

* 배열의 선언(선언할 때는 크기를 지정할 수 없음)
int[]a;
int b[];
int[][]c;
int d[][];
int[]e[];
int f[10]; -> 오류

* 배열의 초기화 : 선언과 동시에 중괄호를 이용하여 초기값을 지정(★중괄호로 배열을 초기화하는 것은 선언과 함께 수행되어야 한다.)
자동으로 메모리 공간이 확보됨
int a[] = {2, 3, 4}; -> 선언과 동시에 초기화
int b[]; b = {5, 6, 7}; -> 오류(두 문장으로 초기화하면 오류)


* 배열 초기화 되는 것들
----------------------------------------
int[] numbers = {1, 2, 3};
----------------------------------------
int[] numbers = new int[] {1, 2, 3};
----------------------------------------
int[] numbers = new int[10];
----------------------------------------
int[] numbers = new int[3];
numbers[0] = 1;
numbers[1] = 2;
numbers[2] = 3;
----------------------------------------

* 배열 문법 틀린 것들
----------------------------------------
int[] numbers;
numbers = {1, 2, 3}; // ★중괄호로 배열을 초기화하는 것은 선언과 함께 수행되어야 한다.
----------------------------------------
int b[ ] = new int(10);
----------------------------------------
int a[10] = new int[ ];
----------------------------------------
int[5] d = {1, 2, 3, 4, 5};
----------------------------------------

* 배열의 생성 : 배열의 원소가 사용할 메모리 공간의 생성
new 연산자를 이용
배열의 크기를 정하고 메모리 공간을 확보
new 연산자는 메모리 공간을 확보한 후 그 메모리 주소값을 리턴함
원소가 숫자인 경우 0, 참조형인 경우 null로 자동 초기화
int a[] = new int[3]; -> 선언과 생성
int b[]; b = new int[10];
int anArray4[][] = new int[3][2]; -> 이 경우 new int[3][]과 같이 행 먼저 생성 후 나중에 각 열에 대해 다르게 생성작업을 할 수 있음. [3][2]와 같이 할 경우 3행 2열로 고정이지만 [3][]과 같이 하면 우선 3행이 만들어지고 각 열에 다른 개수(다른 크기로)로 원소를 넣을 수 있음

* null : 해당 참조형 변수가 어떤 객체도 참조하고 있지 않다.

* 문자열의 +연산자
System.out.println('A' + 0); -> 65(char형 A는 65로 간주됨)
System.out.println("A" + 0); -> A0(문자열의 경우는 +연산자를 사용할 때 기본형 또는 참조형 값이 문자열로 자동 형변환 된다.)

* print()나 println()은 1개 매개변수를 문자열로 바꾸어 출력함

* 표준 입력 : 키보드, 표준 출력 : 모니터(화면)

* 키보드에서 입력을 받는 Scanner 객체(키보드로 xxx yyy zzz 이렇게 공백으로 구분하고 엔터를 쳐서 입력을 하는데, 여기서 xxx, yyy, zzz를 토큰이라고 함)
System.in을 이용하여 Scanner 객체를 만들고 사용함
Scanner sc = new Scanner(System.in);
String name = sc.next(); -> String의 경우 next()를 사용

Scanner 클래스의 입력용 메소드
boolean hasNext() : 다음 단어가 있으면 true를 반환
String next() : 단어를 읽어 String으로 반환
boolean hasNextInt(), int nextInt()
boolean hasNextDouble(), double nextDouble()
boolean hasNextLine(), String nextLine() -> 한 문장으로 된 문자열을 입력 받는 것

* 클래스
class Circle {

}

* 클래스 접근 제어자
public, protected, 생략, private
비접근 제어자 : abstract(붙이면 객체 생성이 불가능한 클래스 즉, new로 객체 생성 불가. 그래도 자식 클래스에 상속이 될 수 있음), final(붙이면 부모가 될 수 없는 클래스)
public : 모든 클래스에서 사용 가능
protected : class A { class B {} }에서 class B 앞에만 붙을 수 있다.
생략 : 같은 패키지에 있는 다른 클래스에서 사용 가능(패키지 접근 수준)
private : class A { class B {} }에서 class B 앞에만 붙을 수 있다.

* 데이터 필드 접근 제어자(메소드도 마찬가지)
데이터 필드를 사용할 수 있는 범위를 제한하여 정보를 은닉
public 필드 : 모든 클래스에서 사용 가능
protected 필드 : 같은 패키지와 자식 클래스에서 사용 가능
생략 필드 : 같은 패키지에 있는 다른 클래스에서 사용 가능
private 필드 : 같은 클래스에서만 사용 가능

데이터 필드와 메소드를 멤버라고 부름

* 객체가 가지는 인스턴스 변수(객체가 생성되고 나서 만들어짐), 인스턴스 메소드(인스턴스 변수를 다루기 위한 함수)
클래스가 가지는 클래스 변수(해당 클래스의 객체들이 공유하는 변수로 데이터 값은 하나만 존재, static 변수, 정적 변수라고도 함), 클래스 메소드(클래스 변수를 이용해서 기능을 수행)

* 배열은 선언 후에 초기화 과정이나 생성의 과정을 거쳐야만 사용할 수 있다.
* ‘배열이름.length’을 사용하여 배열의 크기를 표현할 수 있다.
* 문자열 변수나 리터럴에 대해 +연산을 적용한 결과는 두 문자열이 연결된 문자열이다.
* Scanner 클래스를 이용하면 키보드나 파일로부터 편리하게 문자열(또는 기본형 값)을 입력받을 수 있다.
* 클래스를 정의할 때, 특별한 경우가 아니면 클래스의 접근 제어자로서 생략과 public만 지정할 수 있다.
* 클래스를 정의할 때, 접근 제어자가 생략된 데이터 필드는 ‘해당 클래스’와 ‘같은 패키지의 다른 클래스’에서 사용할 수 있다.

int형 변수 i와 j의 값을 각각 출력하기 위해 적당한 출력문은 무엇인가?
System.out.println( i + " " + j ); -> 정답
오답
System.out.println( i , j );
System.out.println( i + j );
System.out.println( i + ‘=’ + j ); -> 작은 따옴표로 되어 있어서









*****************************************************************************
4강. 클래스와 상속
*****************************************************************************

* 생성자 : 객체가 생성될 때 자동으로 실행되는 메소드(특별한 메소드로 임의로 호출해서 실행되는 것이 아니라 new를 통해 객체가 생성될 때만 자동 호출 됨)
객체의 필드 값을 초기화하거나 메모리 할당 등의 작업
Circle c = new Circle(5);
new : new 연산자를 이용하여 객체를 생성(메모리 할당)
Circle(5) : 생성자가 호출(데이터 필드의 초기화)
= : 객체의 참조값을 변수에 대입

* 생성자는 보통의 메소드와 정의 방법이 다름(생성자는 new로 객체를 생성할 때 자동 호출됨)
생성자 이름은 클래스 이름과 같음
반환형을 선언하지 않음
여러 생성자를 정의할 수 있음(생성자 오버로딩 : 인자의 개수와 인자의 자료형으로 구분)
접근 제어자는 보통 public

하나의 소스 파일에 있으면 컴파일 시 같은 패키지에 존재하게 된다.
class Circle {
	double r;
	public Circle(double a) {
		r = a;
	}
	public double getArea() {
		return r * r * 3.14;
	}
}

public class CircleArea {
	public static void main(String args[]) {
		Circle c = new Circle(5.0);
		System.out.println(c.r); // Circle 클래스에서 r의 접근제어자가 생략되어 있기 떄문에 사용 가능(접근제어자가 생략되면 같은 패키지의 다른 클래스에서 사용 가능)
		System.out.println(c.getArea());
	}
}

* 기본 생성자 : 인자가 없는 생성자, 디폴트 생성자(default constructor)
클래스 정의에 한 개의 생성자 정의도 없으면 컴파일러가 public Circle() {}과 같이 자동으로 만들어 줌

* ★기본 생성자와 상관없이, 자식 클래스의 생성자 정의에서 생성자 몸체의 첫 줄에 부모 생성자의 명시적 호출이 없다면 super(); 코드가 자동으로 들어감
super(); : 부모 클래스의 기본 생성자를 호출
따라서 부모 클래스에서 기본 생성자의 존재를 확인해야 함(없으면 에러)

* 클래스의 사용
클래스형 변수를 선언할 때(클래스는 객체의 자료형) : Circle c; (클래스 참조형 변수의 선언)
객체를 생성할 때 : c = new Circle();
상속받아 클래스를 정의할 때 : class CSub extends CSuper {}

* 클래스의 재사용
합성 : 기존 클래스를 새로운 클래스에서 데이터 필드의 자료형으로 사용
has-a 관계
class Line { Point begin, end; }
상속 : 기존 클래스(부모)를 사용하여 새로운 클래스(자식)를 정의
코드의 중복 작성을 줄이고 프로그램의 확장성이 좋아짐
상속은 기존 클래스를 확장 or 특화하는 것
자식 is-a 부모의 관계

* 객체의 사용
객체 변수와 점(.) 연산자를 사용하여 멤버에 접근

* static 필드
정적 필드 or 클래스 변수
클래스의 모든 객체가 공유하는 데이터
객체의 생성이 없이도 항상 사용 가능
★어떤 객체도 값을 변경할 수 있음
사용 방법은 클래스 이름.정적필드(객체변수.정적필드도 가능)

* static 메소드
정적 메소드 or 클래스 메소드
객체와 무관하게 호출되고 실행됨
★메소드 몸체에서 this를 사용할 수 없음(static 메소드는 객체와 무관하게 실행되는 메소드이므로 this와 super는 static 메소드에서 사용할 수 없다.)
static 필드와 인자를 가지고 작업함
사용 방법은 클래스이름.정적메소드()
Math.sqrt(2.0);
Integer.parseInt("120");

* final 필드
상수 데이터를 선언
선언할 때 초기값을 지정해야 함
자주 static과 함께 사용됨
final static double PI = 3.141592;

* final 메소드
자식 클래스로 상속은 가능하나 재정의 할 수 없는 메소드

* 객체 초기화
객체를 생성할 때 데이터 필드에 초기값을 지정하는 것
클래스 변수는 프로그램 시작 시에 자동 초기화됨
데이터 필드는 자동으로 초기값이 주어질 수 있음
* 순서
static 필드의 선언문에서 초기화
static 초기화 블록 실행

① non-static 필드의 선언문에서 초기화
② non-static 초기화 블록 실행
클래스 몸체 내 임의 위치에 포함
초기값 지정을 위한 코드
static 필드는 static 블록을 사용
③ 생성자 실행
class IniTest {
	int nValue = 1; // ①
	{
		nValue = 2; // ②
	}
	public IniTest() {
		nValue = 3; // ③
	}
}
-> 최종적으로 nValue 값은 3이 된다.
static 초기화 블록은 블록 앞에 static을 붙인다.

* 메소드의 signature
메소드 이름, 매개변수 리스트
메소드의 signature로 메소드 구분 가능(반환형은 제외)

* 메소드 오버로딩
인자의 개수나 인자의 자료형이 다르면 같은 이름의 메소드를 한 클래스에서 여러 개 정의할 수 있음
인자의 개수와 자료형이 정확히 일치하면 중복 정의 불가
★반환형은 구분의 기준이 아니다.
메소드를 호출할 때, 가장 가까운 매개변수 목록을 가진 메소드가 호출됨

* 클래스의 상속은 단일 상속만 가능
★인터페이스의 상속은 다중 상속 가능

* 메소드 오버라이딩
부모로부터 상속받은 메소드의 몸체를 자식 클래스에서 재정의 하는 것
★자식 입장에서 보면 부모 클래스에서 상속받은 메소드도 있는 것이고, 그것을 재정의 했다면, 재정의한 메소드도 있는 것
★오버라이딩 방법 : 메소드의 이름, 인자의 개수와 자료형, 반환형이 같은 메소드를 정의
★반환형은 서브 타입(상속 관계에서 자식 클래스)도 가능함
★접근 제어자의 가시성(접근 범위)은 같거나 커져야 함
protected인 경우 protected 또는 public, public인 경우 public만 가능

* this
메소드 호출 시, 숨은 인자로 this가 메소드에 전달됨
this는 현재 객체에 대한 참조값을 가지고 있음(c1.display()과 c2.display()의 결과가 다른 이유임)
★인스턴스 메소드나 생성자에서만 사용 가능(static 메소드는 객체와 무관하게 실행되는 메소드이므로 this와 super는 static 메소드에서 사용할 수 없다.)

* super
this와 같으나 자료형이 부모 클래스 유형임
자식 클래스의 인스턴스 메소드나 생성자에서 사용됨(this와 마찬가지로 static 메소드에서 사용 불가)
부모 클래스에서 오버라이딩 당한 메소드를 호출하거나 상속되었으나 감춰진 필드에 접근할 때 필요
super.메소드(인자)
super.필드
★아래의 경우 CSub에는 x가 2개임
class CSuper {
	public double x;
}
class CSub extends CSuper {
	public double x;
	public CSub(double new_x) {
		this.x = new_x; // 이 경우 CSub의 x를 가리키며, this는 생략 가능
		super.x = new_x * 10; // 이 경우 CSuper의 x를 가리킴
	}
	public double getSupter() {
		return super.x;
	}
	public double getSub() {
		return this.x;
	}
}
public class ThisSuperTest {
	public static void main(String args[]) {
		CSub sub = new CSub(10.0);
		System.out.println(sub.x); // 10 출력
		System.out.println(sub.getSuper());
		System.out.println(sub.getSub());
	}
}
★★★ Super sup = new Sub();에서
메소드 실행은 동적 바인딩에 의해 변수(sup)가 참조하는 실객체의 유형(Sub)이 가지고 있는 메소드를 실행한다는 것이고, 변수의 경우는 정적 바인딩에 의해 참조 변수의 선언 유형(Super)이 가지고 있는 변수를 참조하게 된다.
★★★★ 데이터필드는 선언유형만 봄
동적 바인딩(Dynamic Binding)
다형성을 사용하여 메소드를 호출할 때, 발생하는 현상이다.
실행 시간(Runtime) 즉, 파일을 실행하는 시점에 성격이 결정된다.
실제 참조하는 객체는 서브 클래스이니 서브 클래스의 메소드를 호출한다.
정적 바인딩(Static Binding)
컴파일(Compile) 시간에 성격이 결정된다.
변수의 타입이 수퍼 클래스이니 수퍼 클래스의 메소드를 호출한다.
★위에서 CSuper sub = new CSub(10.0); 으로 할 경우 아래에서 100 출력
sub가 데이터 유형이 CSuper 유형으로 되어 있기 때문에 sub 변수가 실제로 가리키는 객체가 new CSub()로 인해 자식 객체를 만들어 놓고 그것을 포인팅 하고 있더라도, sub.x와 같이 데이터 필드에 접근하게 될 때는 sub의 선언 유형인 CSuper에서 정의되어 있는 x값을 출력하게 된다.(100)
sub.getSuper()는 컴파일 시 sub의 선언 유형이 CSuper이기 때문에 CSuper에서 getSuper를 호출할 수 있는가를 체크하는데, CSuper에 getSuper 메소드가 없기 때문에 컴파일 오류가 난다.

* ()는 메소드 선언 혹은 호출과 관련있는 것
★this() : 같은 클래스의 다른 생성자를 호출하는 것(생성자가 여러 개 있을 때, 어떤 생성자에서 다른 생성자를 이용해서 데이터를 초기화할 때 다른 생성자를 호출)
super() : 부모 클래스의 생성자를 호출하는 것
★상속받은 데이터 필드를 초기화하기 위한 것(상속받은 데이터 필드를 초기화 할 때는 부모 클래스에 있는 생성자를 이용해서 초기화해야함)
생성자 몸체에서 부모 클래스 생성자의 명시적 호출이 없다면, 인자가 없는 생성자인 super()가 자동 호출됨
★this(), super() 둘 다 생성자 몸체의 첫 번째 문장에서만 사용 가능

Circle 클래스에 radius 데이터 필드가 있다고 가정하고 아래 코드를 보자.
아래의 두 Cylinder 생성자에서 할 일은 데이터 필드 height와 radius를 초기화하는 것
그래서 Cylinder()에서는 Circle 클래스의 기본 생성자에서 정의된대로 radius를 초기화 할 것이고, Cylinder (double radius, double h)에서는 인자로 받은 radius와 super(radius)를 통해 radius가 초기화 될 것임
~~~
public class Cylinder extends Circle{
	private double height;
	public Cylinder() {
		super();
		height=1.0;
	}
	public Cylinder (double radius, double h) {
		super(radius);
		this.height =h;
	}
	public double getHeight() {
		return height;
	}
	public void setHeight(doubleh ){
		this.height =h;
	}

	public double getArea() {
		return2 * PI * getRadius() * height + 2 * super.getArea();
		// 여기서 getRadius()는 this.getRadius()의 축약형
		// getArea()는 오버라이딩한 것이고 super.getArea()가 아닌 this.getArea()면 자기 자신을 호출하는 것이기 때문에 부모의 getArea()를 호출하도록 super.getArea()가 쓰임
	}
	public double getVolume() {
		return super.getArea() * height;
	}
	public String toString() {
		return "Cylinderofradius=" + getRadius()+ "height=" + height;
		// 여기서 getRadius()는 this.getRadius()의 축약형
	}
}
~~~

* 생성자를 정의하려면 이름을 클래스 이름과 같게 하고 반환형을 지정하지 않는다.
* 클래스 정의에 있는 데이터 필드의 선언문, 초기화 블록, 생성자를 통해서 객체 생성 시 필요한 데이터 필드의 초기 값을 지정할 수 있다.
* 클래스를 정의할 때, 객체마다 각각 데이터가 필요하면 인스턴스 변수(non-static 데이터 필드)로, 모든 객체가 공유하는 데이터는 static 데이터 필드로 정의한다.
* 메소드 오버로딩이란 한 클래스에서 이름이 같은 여러 메소드가 존재하는 상황을 말한다. 이때 오버로딩된 메소드끼리는 매개변수 목록이 달라 구별될 수 있다.
* 부모로부터 상속받은 메소드의 몸체를 자식 클래스에서 다시 정의하는 것을 메소드 오버라이딩이라 한다.
* 인스턴스 메소드와 생성자에서 숨은 인자인 this와 super를 사용할 수 있다.






*****************************************************************************
5강. 인터페이스와 다형성
*****************************************************************************

* 추상 메소드
메소드 선언에 abstract 키워드를 사용함
몸체의 구현이 없이 형식만 존재
자식 클래스에 상속될 때 몸체의 구현이 필요
final과 함께 사용 불가
추상 메소드를 가진 클래스는 추상 클래스 혹은 인터페이스여야만 함
abstract public class Shape {
	abstract public double getArea();
}

* 추상 클래스(반대 의미가 구체 클래스, 일반 클래스)
클래스 정의에 abstract 키워드를 사용함
★데이터 필드나 일반 메소드를 포함할 수 있음
★객체 생성을 할 수 없음(구체적이지 못한 불완전한 클래스라는 의미)

* 추상 클래스의 사용
★의미적으로 유사한 클래스(의미적으로 유사한 클래스는 자식 클래스가 됨)들을 묶고자 할 때 사용(하나의 추상 클래스 아래에 의미적으로 유사한 클래스들을 자식으로 둠, 의미적으로 비슷하기 때문에 자식들이 공통으로 사용할 데이터 필드와 메소드를 부모 추상 클래스에 정의해둔다.)
도형이란 부모 추상 클래스가 있고, 그 안에 면적을 구하는 추상 메소드가 있다고 할 때, 자식 클래스(삼각형, 사각형 등)에서 각 면적을 구하는 메소드를 구현하여 사용한다.
공통으로 사용할 데이터 필드와 메소드를 정의
추상 클래스는 일반 클래스와 인터페이스의 중간적 성격을 가짐(추상 클래스보다 더 추상적인게 인터페이스)
(기능적으로 유사한 것은 인터페이스)

* 인터페이스(abstract는 생략하는 것이 보통임(abstract interface인데 interface만 씀. ★interface 소문자인 것 주의)
100% 추상적 클래스
★인터페이스의 모든 메소드는 추상 메소드(public abstract, 생략 가능, 각각도 생략 가능)
★단, 몸체가 구현된 default 메소드와 static 메소드도 포함 가능, 접근 제어자는 public(생략 가능)
★모든 메소드의 기본 접근 제어자는 public
★★★데이터 필드는 클래스 상수만 가능(public static final, 생략 가능) -> 객체 생성 없이 참조할 수 있는 데이터 필드만 가능(객체를 생성할 수 없으니 클래스 상수만 가능한듯)
참조 자료형이며 직접적 객체 생성은 불가(추상 클래스보다 더 추상적인게 인터페이스)
인터페이스의 이름은 보통 형용사(Runnable, Serializable, Comparable)

* 인터페이스의 사용
추상 클래스와 마찬가지로 자식 클래스에 상속되어 사용됨
인터페이스를 구현하는 자식 클래스는 모든 추상 메소드를 구현해 주어야 함
★의미적으로는 관련이 없으나 기능적으로 유사한 클래스들을 묶을 때 인터페이스를 사용할 수 있음
사각형 클래스, 운동 선수 클래스, TV 클래스, 아파트 클래스 -> 의미적으로는 관련 없지만 크기 비교가 가능하다는 클래스로 볼 수 있음. 부모 인터페이스에 comparable과 같이 대소비교가 가능한 추상 메소드를 둘 수 있음
인터페이스를 상속받아 자식 인터페이스를 정의할 수 있음 -> 인터페이스의 상속(또는 확장)

* 인터페이스의 상속(자식 인터페이스가 부모 인터페이스를 상속받는 경우)
인터페이스를 상속받아 인터페이스를 정의할 때 키워드 extends를 사용
★★여러 인터페이스를 상속받는 다중 상속도 가능(콤마로 구분)
★interface 자식인터페이스 extends 부모인터페이스1, 부모인터페이스2
★인터페이스가 부모 역할을 할 때는 다중 상속이 가능
* 인터페이스의 구현(자식 클래스가 부모 인터페이스를 상속받는 경우)
자식은 부모가 나열한 기능(추상 메소드)을 구현해야 함
구현을 통해 클래스를 정의할 때 implements를 사용
class 자식클래스 extends 부모클래스 implements 부모인터페이스1, 부모인터페이스2

* 상속과 인터페이스의 차이점은 강제성의 유무
인터페이스는 implments를 선언하고 구현을 하지 않으면 오류가 남
상속은 오버라이딩을 해서 구현을 해도 그만 안 해도 그만
~~~
interface Movable{
	void moveUp(); // ★public abstract 생략되어 있음
	void moveDown(); // ★public abstract 생략되어 있음
	void moveLeft(); // ★public abstract 생략되어 있음
	void moveRight(); // ★public abstract 생략되어 있음
}
public class MovableTest {
	public static void main(String[]args) {
		Movable m1 = new MovablePoint(5,5); // ★인터페이스 Movable 유형으로 선언
		System.out.println(m1); // ★자동으로 m1.toString()이 호출된다.
		m1.moveUp();
		System.out.println(m1);
		m1.moveRight();
		System.out.println(m1);
	}
}

class MovablePoint implements Movable {
	private int x,y;
	public Movable Point(intx,inty) {
		this.x =x;
		this.y =y;
	}
	public String toString() {
		return "Pointat("+x+","+y+")";
	}
	public voidmoveUp(){y++;}
	public voidmoveDown(){y--;}
	public voidmoveLeft(){x--;}
	public voidmoveRight(){x++;}
}
~~~

* 디폴트 메소드
인터페이스에서 선언하는 메소드에 기본 구현을 넣을 수 있음
자식 클래스에서 상속받을 때 디폴트 메소드를 그대로 사용하거나 몸체를 다시 정의해 줄 수 있음
메소드 선언시 default를 사용하고 몸체를 구현해 줌
★인터페이스에 나열된 기능을 확장할 때 기존 코드의 수정을 피하기 위함
★단순히 추상 메소드가 추가된다면 이전 인터페이스를 구현한 클래스 모두를 수정해야 함
interface DoIt {
	void doSomething();
	int doSomethingElse(String s);
	// ★시간이 한참 지난 뒤 추상 메소드가 추가된다면 이전 인터페이스를 구현한 클래스 모두를 수정해야 함. 그래서 아래와 같이 기본몸체가 구현된 default 메소드를 추가하여 원하는 곳에서만 아래 메소드를 재정의하면 됨
	default boolean didItWork(int i, String s) {
	}
}

* 추상 클래스, 인터페이스, 클래스의 형변환
인터페이스와 클래스는 모두 사용자 정의형(사용자 자료유형)
상위 유형의 변수는 하위 객체의 참조값을 가질 수 있음
상위 유형의 변수가 가리키는 객체의 실제 유형에 따라 수행되는 메소드가 결정됨(동적 바인딩, 동적 바인딩은 실행 시점에 결정됨)
메소드 호출 시 변수의 선언 유형으로 정하지 않음
★SuperClass super = new SubClass(); // 업캐스팅
super.method(); // SubClass에서 찾음
★★★ Super sup = new Sub();에서
메소드 실행은 동적 바인딩에 의해 변수(sup)가 참조하는 실객체의 유형(Sub)이 가지고 있는 메소드를 실행한다는 것이고, 변수의 경우는 정적 바인딩에 의해 참조 변수의 선언 유형(Super)이 가지고 있는 변수를 참조하게 된다.

* 다형성과 형변환
상속 관계에 있는 클래스 간에는 타입 변환이 가능
~~~
Animal animal = (animal)new Dog(); // (animal) 생략 가능

class A { 
	public void func( ) {
		System.out.println(“a”); 
	}
}
class B extends A {
	public void func( ) {
		System.out.println(“b”);
	}
}
class C extends B {
	public void func( ) {
		System.out.println(“c”);
	}
}

public class PolymorphTest {
	public static void main(String args[ ]) {
		A a = new B( );
		a.func( ); // ★실행 시점에 B를 가리키고 있기 때문에 class B에서 func()
		a = new C( );
		a.func( ); // ★실행 시점에 C를 가리키고 있기 때문에 class C에서 func()
	}
}
~~~
위의 결과는 b, c인데, 만약 class C에 func()가 없으면 c가 아닌 b가 답이다.
★컴파일 시점에 class A에 func()가 없다면 컴파일 오류가 남
★컴파일 시점에는 a.func( ); 시 선언 유형을 봄. A a = new B( ); 그래서 선언 유형이 A이기 때문에 A에 func()가 있어야 함
★★컴파일할 때는 선언 유형을 보고 거기에 해당 메소드가 있는지 확인을 하고, 문제가 없으면 넘어간다. 실행할 때는 실유형을 본다.
★★★★ 데이터필드는 선언유형만 봄

* 열거형 정의
열거형은 미리 정의된 상수값을 만들기 위한 자료형
enum을 사용하여 정의
열거형으로 선언된 변수에는 미리 지정된 값만 대입 가능
상수값을 배열로 리턴하는 static 메소드로 values()를 제공
Enum Day {
	SUNDAY, MONDAY, TUESDAY
}
// main 함수에서
Day day = Day.MONDAY;
for (Day d : Day.values()) {
	System.out.println(d);
}

* 열거형의 생성자와 메소드
열거형 정의에 필드와 메소드를 포함할 수 있음
상수 선언이 필드나 메소드보다 먼저 정의되어야 하며 세미콜론(;)으로 끝나야 함
생성자는 열거형과 같은 이름을 가지며 접근 제어자는 생략 또는 private이어야 함
열거형에서 상수값은 마치 하나의 객체와 같음
열거형의 생성자는 상수값을 설정(객체 생성)할 때 자동 호출됨
~~~
enum BaseballTeam {
	LG(40, 30), SS(30, 40), KT(20, 50), 
	SK(35, 35), NC(55, 15); // 세미콜론으로 끝남

	private final int win;
	private final int lose;

	private BaseballTeam(int win, int lose) {
		this.win = win;
		this.lose = lose;
	}
	public double winsRate( ) { 
		return (win * 100.0) / (win + lose); 
	}
}

public class EnumTest2 {
	public static void main(String args[ ]) {                       
		BaseballTeam bt = BaseballTeam.LG; // ★enum BaseballTeam에서 LG를 찾아가면 LG(40, 30) 이렇게 괄호가 있기 때문에 생성자가 호출되고 생성자를 통해 데이터 필드가 초기화 된다.
		System.out.println(bt.winsRate( ));
	}
}
~~~

* 익명 클래스
일회성으로 1개의 객체를 생성하기 위한 클래스
클래스 정의와 동시에 객체를 생성할 수 있음
슈퍼 클래스를 상속받거나 인터페이스를 구현하도록 익명 클래스를 정의함
new 슈퍼클래스() {...} // 여기서 {...} 이게 익명 클래스 정의고, 슈퍼클래스를 부모로 하는, 즉, 슈퍼클래스를 상속받는 익명클래스 정의(슈퍼클래스의 자식 객체 생성. 앞에 new가 있으므로)
new 인터페이스() {...} // 인터페이스를 구현하는 자식 객체 생성 
★CSuper sub = new CSuper( ) {  } ; 의미 : CSuper를 상속받는 익명 클래스를 정의하고, 동시에 객체를 생성한다.

★53분(동적바인딩, 정적바인딩)

* 몸체가 없는 메소드를 추상 메소드라고 하고, 추상 메소드를 하나라도 가지고 있는 클래스는 추상 클래스이어야 한다.
* 인터페이스는 추상 메소드로만 구성된다. 단, default 메소드와 static 메소드는 몸체가 있어야 한다.
* 의미적으로 유사한 클래스를 묶을 때는 추상 클래스로, 기능적으로 유사한 클래스를 묶을 때는 인터페이스를 사용한다.
* 다형성은 메소드 오버라이딩과 오버로딩, 클래스 간 상속과 형변환, 인터페이스의 구현과 형변환, 메소드 동적 바인딩을 통해 구현될 수 있다.
* 열거 자료형은 여러 상수값을 미리 정의하기 위한 자료형이며, 각 상수값은 하나의 객체와 같다.
* 익명 클래스는 이름이 없는 클래스로, 일회성으로 객체를 생성하는 용도로만 사용되는 클래스를 의미한다.






*****************************************************************************
6강. 제네릭과 람다식
*****************************************************************************

* 제네릭 : 캐스트(형변환) 연산자의 사용 불필요
class ArrayList<E> implements List<E> { // ArrayList를 사용할 때, 즉, ArrayList 유형으로 변수 선언을 하거나, 객체 생성을 할 때 <E> 여기다가 자료형을 전달해 줘야 한다는 의미(타입 매개변수(타입 파라미터)를 전달해 줘야 한다.) -> 예를 들어 Integer가 전달되면 E 부분이 Integer가 된다.
	boolean add(E e) {}
	E get(int index) {}
	E remove(int index) {}
}

List list1 = new ArrayList(); // ★ArrayList에서 관리되는 원소 하나하나를 Object 유형으로 보면 됨
list1.add("hello"); // ★hello가 Object 유형으로 자동형변환(업캐스팅)되서 add된다.
String s1 = (String)list1.get(0); // ★형변환 필요(get할 경우 Object 유형으로 return이 되기 때문에 문자열 변수에 대입하려면 String으로의 형변환(다운캐스팅)이 필요한 것이다.)

List<String> list2 = new ArrayList<String>(); // ★문자열을 원소로 하는 ArrayList 객체가 만들어짐
list2.add("hello");
String s2 = list2.get(0); // ★형변환 불필요

* 제네릭 클래스
클래스 정의에서 타입 파라미터를 선언함
클래스를 사용할 때는 타입을 명시해야함
타입 파라미터는 참조형만 가능
★필드의 자료형, 메소드 반환형, 인자의 자료형으로 사용할 수 있음

* 제네릭 클래스 필요성
제네릭 타입을 사용하지 않으면 컴파일 시점에서 오류를 검출하지 못함
★의미가 명확하면 생성자 호출 시 괄호만 사용할 수 있음

Data2<String> b3 = new Data2<>();
Pair<String, Integer> p1;
p1 = new OrderedPair<>("Even", 8);

* 제네릭 인터페이스를 구현하는 제네릭 클래스
interface Pair<K, V> {
	public K getKey();
	public V getValue();
}

class OrderedPair<K, V> implements Pair<K, V> {
	...
}

* 제네릭 타입을 상속/구현하는 일반 클래스
제네릭 인터페이스를 구현하는 일반 클래스 : 클래스를 정의할 때 제네릭 인터페이스의 <> 안에 자료형을 지정하면 됨
class MyPair implements Pair<String, Integer> {
	private String key;
	private Integer value;
	public MyPair(String key, Integer value) {
		this.key = key;
		this.value = value;
}

* Raw타입
제네릭 타입이지만 일반 타입처럼 사용하는 경우, 제네릭 타입을 지칭하는 용어
타입 매개변수 없이 사용되는 제네릭 타입
자료형을 Object로 처리함
Data2 data = new Data2("hello");
이 때 Data2는 제네릭 타입 Data2<T>의 raw 타입

* 제네릭 메소드
자료형을 매개변수로 가지는 메소드
하나의 메소드 정의로 여러 유형의 데이터를 처리할 때 유용
메소드 정의에서 반환형 왼편에 각괄호<> 안에 타입 매개변수 표시
타입 매개변수를 메소드의 반환형이나 메소드의 매개변수의 자료형, 지역 변수의 자료형으로 사용 가능
public static <T> T getLast(T[] a) {
	return a[a.length-1];
}
인스턴스 메소드와 static 메소드 모두 제네릭 메소드로 정의 가능
★제네릭 메소드를 호출할 때 타입을 명시하지 않아도 인자에 의해 추론이 가능(생략 가능하다는 말)
class Util {
	public static<K,V>boolean compare(Pair<K, V> p1,Pair<K, V> p2) {
		return p1.getKey().equals(p2.getKey())&&p1.getValue().equals(p2.getValue());
	}
}

public class GenericsTest5 {
	public static void main(Stringargs[]) {
		Pair<Integer, String> p1 = new OrderedPair<>(1,"apple"); // ★ <>처럼 생략됨
		Pair<Integer, String> p2=new OrderedPair<>(2,"pear");
		boolean same=Util.<Integer,String>compare(p1, p2); // ★★여기서 <Integer,String> 생략 가능(p1, p2를 추적해보면 Pair<Integer, String> 유형이니)
		System.out.println(same);
	}
}

* 제네릭의 타입 제한
자료형을 매개변수화하여 클래스/인터페이스/메소드를 정의할 때 적용가능한 자료형에 제한을 두는 것
★<T extends Number>와 같이 하면 Number를 상한으로 정할 수 있음
T에 주어지는자료형은Number의서브 클래스라야함

* 제네릭 타입과 형변환
★Integer나 Double은 Number와 상관관계가 있지만, Data<Number>와 Data<Integer>는 상하위 관계가 없음
class Data<T> {}
class FormatterdData<T> extends Data<T> {} // 상속 관계

public class GenericTypeConversion1 {
	public static void main(String args[]) {
		Data<Number>data=new Data<Number>();
		data.set(new Integer(10)); // ★OK 여기서 set 메소드에 Number 유형이 들어가야하는데 Integer나 밑에 Double은 Number의 자식 유형이기 때문에 Integer나 밑에 Double이 업캐스팅이 됨
		data.set(new Double(10.1)); // OK
		Data<Number>data1=new Data<Integer>(); // 컴파일 오류. 여기서 Data<Integer>가 Data<Number> 유형으로 형변환되어야 하는데 서로 관계가 없으므로 오류
		Data<Integer>data=new FormattedData<Integer>();
	}
}

* 제네릭 타입 사용 시 유의사항
기본 자료형은 타입 매개변수로 지정할 수 없음
Data<int>d=new Data<>(); // 오류
타입 매개변수로 객체 생성을 할 수 없음
class Data<T> {private Tt1=new T();} // 오류
타입 매개변수의 타입으로 static 데이터 필드를 선언할 수 없음(static 필드는 모든 객체가 공유하는 하나의 변수이기 때문)
class Data<T>{private static T t2;} // 오류
제네릭 타입의 배열을 선언할 수 없음
Data<Integer>[]arrayOfData; // 오류

* ★람다식 : 인터페이스를 구현하는 익명 클래스의 객체 생성 부분을 수식화 한 것
구현할 것이 1개의 추상 메소드 뿐일 때 간단히 표현할 수 있음
람다식 구문은 메소드 매개변수의 괄호, 화살표, 메소드 몸체로 표현
인터페이스 객체변수 = (매개변수 목록) -> {실행문 목록};
Runnable runnable = new Runnable() {
	public void run() {...}
};
위가 아래로 바뀔 수 있다.
Runnable runnable = () -> {...};
위에서 Runnable을 타겟 타입이라고 함
1개의 추상 메소드를 포함하는 인터페이스를 함수적 인터페이스라고 함(default, static 메소드는 고려하지 말자)

인터페이스 객체변수 = (매개변수목록)->{실행문목록 };
매개변수 목록에서 자료형은 인터페이스(타깃 타입) 정의에
서 알 수 있으므로 자료형을 생략하고 변수 이름만 사용 가능
매개변수가1개면 괄호도 생략 가능하며변수 이름 하나만 남음
매개변수를 가지지 않으면 괄호만 남음
화살표 사용
실행문 목록에서 실행문이 1개이면 중괄호 생략 가능
★실행문이 return문 뿐이라면 return과 세미콜론, 중괄호를 동시 생략해야 하고 1개의 수식만 남게 됨

* 패키지 java.util.function에서 표준 함수적 인터페이스가 제네릭 인터페이스로 제공됨
★★★표준 함수적 인터페이스의 예(리턴하는게 없으면, 즉 void면 실행문이 있음)
Consumer<T>는 void accept(T t)를 가짐(받기만 하고 return은 없음)
u Supplier<T>는 T get() 메소드를 가짐(받는건 없는데 return은 있음)
u Function<T,R>은 R apply(T t)를 가짐(하나를 받아서 하나를 return)

★아래와 같은 인터페이스가 있다고 가정할 때, 보기에서 람다식 사용이 잘못된 것은?
interface Addable {
        int add(int a, int b);
}
Addable ad = (int a, int b) -> { return (a + b); };
Addable ad = (a, b) -> { return (a + b); };
Addable ad = (a, b) -> (a + b);
아래 보기가 잘못된 것(★★★실행문이 return문 뿐이라면 return과 세미콜론, 중괄호를 동시 생략해야 하고 1개의 수식만 남게 됨)
Addable ad = (int a, int b) -> return (a + b);

* ★6강 40분부터 다시보기

* 자료형을 매개변수로 가지는 클래스와 인터페이스를 제네릭 타입이라고 한다.
* 제네릭 클래스를 사용할 때 제공되는 타입 파라미터는 필드의 자료형, 메소드의 반환형, 인자의 자료형으로 사용될 수 있다.
* 자료형을 매개변수로 가지는 메소드를 제네릭 메소드라고 한다.
* 제네릭을 활용하면 컴파일 시점에 명확한 자료형 검사를 수행할 수 있다.
* 함수적 인터페이스를 구현하는 클래스의 객체를 생성할 때 람다식을 사용하는 것이 효율적이다.
* 람다식의 실행 결과가 대입되는 인터페이스를 람다식의 타깃 타입이라고 한다.









*****************************************************************************
7강. 패키지와 예외처리
*****************************************************************************

* Java 언어에서 가장 기본적 클래스는 java.lang 패키지에 존재
그래서 Java 프로그램에서 import java.lang.*; 구문은 자동 포함됨

* package com.vehicle;
public class Car {
} 
javac Car.java - d D:\javaClasses
위의 경우 D:\javaClasses\com\vehicle\Car.class

* ★컴파일러는 환경변수 CLASSPATH에 지정된 경로에서 사용자 클래스를 찾을 수 있음
CLASSPATH의 경로는 jar 파일을 포함할 수 있음
예: 프로그램에서 graphics.Circle 클래스를 사용
CLASSPATH=경로1;경로2;a.jar라고 가정
이때, 경로1\graphics\Circle.class 또는
경로2\graphics\Circle.class 가 있거나
a.jar에 \graphics\Circle.class가 있어야 함

* 메소드를 수행할 때 예외가 발생하면 예외 객체가 만들어지고 던져짐
예외 객체는 Exception 클래스(또는 하위 클래스)로 표현되며 예외 발생 정보를 가지고 있음

* Object - Throwable - Exception / Error
Exception - RuntimeException(Unchecked Exception) / IOException 외(Checked Exception)

* Checked Exception은 예외처리 코드를 강제함(예외처리 코드가 없으면 컴파일 오류)
* RuntimeException(Unchecked Exception)은 예외처리를 안 해도 됨(ArithmeticException, NullpointerException, IndexOutOfBoundsException 등)
RuntimeException은 컴파일 시 통과, 런타임 시 예외 발생
그 외의 Exception은 컴파일 시 예외 발생

public class A {
	public void problem() throws RuntimeException {
		throw new RuntimeException(); // ★
	}
}

* catch 블럭은 하나만 실행됨

* 사용자 정의 예외
사용자가 직접 예외 클래스를 작성할 수 있음
일반적으로 Exception 클래스를 상속받음
throw 구문을 사용하여, 필요할 때 예외 객체를 던질 수 있음

class MyException extends Exception {
	public MyException( ) { super( ); }
	public String toString( ) { return "MyException"; }
}
class MyExceptionTest {
	public void testFunc(int x) throws MyException {
		if (x > 10) throw new MyException( ); // 예외 객체 생성(예외 발생)
	}
} 

* 다음 코드에 관한 설명으로 올바른 것은?
try {
... ...
} catch (Exception ex1) {
... ...
} catch (IOException ex2) {
... ...
}
-> 어떠한 종류의 예외가 발생해도 첫 번째 catch 블록에서 잡히고 두 번째 catch 블록에는 도달할 수 없으므로 오류가 있다.


* Java의 패키지는 관련이 있는 클래스와 인터페이스의 묶음이며 계층 구조로 구성된다.
* 다른 패키지에 있는 클래스를 사용할 때는 import 구문을 사용하는 것이 편리하다.
* Java 프로그램에서 필요한 클래스나 패키지는 환경변수 CLASSPATH에 포함되어 있는 경로상에서 찾을 수 있어야 한다.
* Java 프로그램의 실행 도중 심각하지는 않지만 정상적 흐름을 벗어난 비정상적 상황이 발생할 수 있으며 이것을 예외라고 한다.
* checked Exception에 속하는 예외가 발생할 수 있는 경우, 반드시 예외처리 구문을 작성해야 한다.
* 예외의 직접 처리를 위해 try-catch 구문을 사용하고, 예외를 전파하려면 메소드 선언에 ‘throws 예외유형’을 표시한다.









*****************************************************************************
8강. java.lang 패키지
*****************************************************************************

* 주요 클래스
Object, System, Math
, String, StringBuffer
, Thread
, Exception, Throwable, Error
포장 클래스(Number, Integer, Double, Character, Boolean 등)

* Object
자동으로 모든 클래스의 조상이 되는 클래스
주요 메소드
protected Object clone() : 객체를 복제하여 반환
public boolean equals(Object obj)
public int hashCode() : 객체를 식별하는 정수값을 반환
public String toString()

* String toString()
Object 클래스에 있는 toString은 객체의 문자열 표현을 반환(클래스 이름@16진수 해시코드)
문자열의 +연산, System.out.print() 등에서 필요(System.out.print(a.toString()))
자식 클래스에서 재정의 할 수 있음
★String, Integer 클래스 등에서 재정의되어 있음 : '클래스 이름@16진수 해시코드'와 같이 리턴하지 않는다는 말
객체를 출력, 즉, System.out.println(my_class1); 이렇게 하면 괄호 안에 .toString()이 붙음

* boolean equals(Object obj)
★두 객체 변수를 비교해서 두 변수의 참조값이 같을 때 true를 반환
★Object 클래스에서 equals()의 의미 : obj1.equals(obj2)의 결과는 (obj1 == obj2)와 같음
String, Integer 클래스 등에서 재정의 되어 있음(Object의 것과 다름을 주의하자)
★Integer에서는 보관하고 있는 int 값이 같으면 true를 리턴하도록 재정의 되어 있음(다른 참조값을 가지고 있어도 보관하고 있는 int 값이 같으면 true. 유형은 같아야함. 보관하고 있는 값이 같아도 유형이 Integer와 Short이면 false)
★obj1 == obj2의 경우는 참조값이 같아야함

* Object clone()
객체를 복제하여 리턴함
'Cloneable 인터페이스를 구현한 클래스'의 객체만 clone() 메소드를 호출할 수 있음
예외 처리를 해야함(CloneNotSupportedException)
동영상 16분 보자
Box b1 = new Box(20, 30);
Box b2 = (Box)b1.clone(); // Object로 리턴하기 때문에 형변환 필요
★b2는 b1에서 복제됐지만 다른 해시코드를 가지고 있다.(참조값이 다르다.)

* String 클래스
문자열을 표현하고 처리하기 위한 클래스
참조형이지만 기본 자료형처럼 다룰 수 있음
String s1 = "Java"; // 리터럴을 대입
★같은 리터럴은 1개만 만들어져 공유됨
★String 객체는 내용이 변하지 않는(Immutable) 상수 객체

* String 클래스의 생성자
public String() : 빈 문자열 객체 생성
public String(String original) : 기존에 있던 것을 String 객체를 이용해서 새로운 String 객체 생성
public String(char[] value)
public String(char[] value, int offset, int count) : 문자 배열 중 일부만 쓰는 것

* 문자열 비교 메소드
int compareTo(String anotherString)
같으면 0을 리턴하고, 다르면 0이 아닌 정수값을 리턴함
s1.compareTo(s2) : s1이 작으면 음수가 리턴(사전식 순서로 비교)
int compareToIgnoreCase(String anotherString) : 대소문자를 구분하지 않고 비교
boolean equalsIgnoreCase(String anotherString)
★boolean equals(Object anObject) : Object 클래스의 equals 메소드가 재정의 된 것으로 문자열(값)이 같으면 true를 리턴하고, 다르면 false를 리턴함
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");
String s4 = new String("Java");
여기서 s1 == s2는 true이고 나머지들을 ==하면 다 false. ==은 참조값이 같아야함
s1.equals(s3)도 true이고 나머지들 모두 true

* 문자열의 검색 메소드
int indexOf(String str), int indexOf(String str, int fromIndex)
처음 위치부터 문자열 str을 찾아 처음 등장하는 위치(인덱스)를 리턴함.
없으면 -1을 리턴함
★System.out.println( "hamburger".indexOf("urge") ); // 4리턴
int lastIndexOf(String str), int lastIndexOf(String str, int fromIndex)
마지막 위치부터 앞 방향으로 찾음

* 문자열 추출 메소드
char charAt(int index)
index 위치에 있는 문자를 리턴한다.
String substring(int beginIndex)
beginIndex 위치부터 마지막까지의 문자열을 리턴함
★System.out.println( "hamburger".substring(3) ); // burger 리턴
String substring(int beginIndex, int endIndex)
beginIndex 위치부터 (endIndex-1)까지의 문자열을 리턴함(리턴되는 문자열 길이를 계산하려면 beginIndex - endIndex하면 됨)

* 문자열의 변환 메소드
★★★원본 문자열은 변경되지 않고 새로운 객체가 만들어짐
String replace(char oldChar, char newChar)
oldChar 문자를 newChar 문자로 변환하여 리턴함(★원본 문자열은 그대로 있는거고, replace 결과의 새로운 문자열이 만들어지는 것임)
String trim( )
문자열 앞과 뒤에 나오는 화이트 스페이스 문자를 제거하여
리턴함
String toUpperCase( ) : 소문자를 대문자로
String toLowerCase( )
String concat(String str) : 두 문자열을 연결함
s1.concat(s2)하면 s1과 s2 문자열은 그대로 있고, 두 문자열을 연결한 새로운 문자열이 생기는 것

★★다음 프로그램의 출력 결과는 무엇인가?
public class Test {
        public static void main(String args[]) {
                String s = new String("Jovo");
                s.replace('o','a');
                s.concat("Exam");
                System.out.println(s);
        }
}
★★정답은 Jovo
★★만약 아래와 같이 한다면 JavaExam이 출력됨
public class Test {
        public static void main(String args[]) {
                String s = new String("Jovo");
                s = s.replace('o','a');
                s = s.concat("Exam");
                System.out.println(s);
        }
}


* 다른 자료형을 문자열로 변환하는 메소드
System.out.println(String.valueOf(123)); // 123
System.out.println(String.valueOf(5 > 3)); // ★true
System.out.println(String.valueOf(3.0)); // 3.0
System.out.println(String.valueOf('c')); // c("c"로 스트링이 되는 것임)
char[ ] a = { 'J', 'a‘, 'v', 'a' };
System.out.println(String.valueOf(a)); // Java

* 기타 메소드
boolean startsWith(String prefix)
prefix로 시작하면 true를 리턴함
boolean endsWith(String suffix)
suffix로 끝나면 true를 리턴함
char[ ] toCharArray( ) : 문자열을 문자 배열로 리턴

* StringBuffer 클래스와 생성자
객체 생성 이후 문자열을 수정할 수 있는 기능을 제공
StringBuffer는 내용 변경이 가능한 mutable 클래스
내부적으로 문자열을 저장하기 위해 크기가 조절되는 버퍼(문자 배열)를 사용함
생성자
StringBuffer( ) : ★초기 버퍼의 크기는 16
StringBuffer(int length) : length 길이의 버퍼를 가진 StringBuffer 객체가 만들어짐
StringBuffer(String str) : 초기 버퍼의 크기는 (str의 길이+16)
new StringBuffer("Java") : 초기 버퍼 크기 20

* StringBuffer 주요 메소드
int capacity( ) : 버퍼 크리 리턴
int length( ) : 문자열의 길이 리턴
char charAt(int index) : 해당 위치의 문자를 리턴
int indexOf(String str) : 해당 문자열을 찾아서 index를 리턴
String substring(int start, int end) : start 위치부터 end-1 위치까지의 부분 문자열 리턴
★StringBuffer append(char c) : 인자를 String 표현으로 바꾸고 원 문자열 끝에 추가하여 반환함, 인자는 char[ ], Object, String, 기본 자료형도 가능함 -> 원본 문자열이 바뀌는 것임
★StringBuffer s1 = new StringBuffer("start");
System.out.println(s1.capacity( )); // 21
System.out.println(s1.length( )); // 5
System.out.println(s1.append("le" )); // "startle"(원본 문자열이 바뀌는 것임. s1이 String 유형이었으면 원본은 그대로이고, 새로운 "startle"이 생기는 것임)

StringBuffer delete(int start, int end) : start 위치에서 (end-1)까지의 문자열을 삭제
StringBuffer insert(int offset, String s) : offset 위치부터 s를 삽입
StringBuffer replace(int start, int end, String s) : start 위치부터 (end-1)까지의 문자열을 s로 교체
StringBuffer reverse( ) : 문자열을 역순으로 변경

public class StringTest2 {
	public static void main(String args[]) {
		final String tmp = "abcde"; long start, end;
		String str = new String( );
		StringBuffer sb1 = new StringBuffer( );
		StringBuilder sb2 = new StringBuilder( );
		start = System.nanoTime( );
		for(int i = 0; i < 10000; i++) str = str + tmp;
		end = System.nanoTime( );
		System.out.println((end-start)/1000000.0 +" msecs");
		start = System.nanoTime( );
		for(int i = 0; i < 10000; i++) sb1.append(tmp);
		end = System.nanoTime( );
		System.out.println((end-start)/1000000.0 +" msecs");
		start = System.nanoTime();
		for(int i = 0;i < 10000; i++) sb2.append(tmp);
		end = System.nanoTime();
		System.out.println((end-start)/1000000.0 +" msecs");
	}
}
StringBuffer와 StringBuilder는 mutable 클래스인데(원본 문자열이 변경되는), 다만 StringBuffer는 멀티쓰레트 프로그램에서 동시성 제어를 고려해서 구현되어 있기 때문에 StringBuilder보다 약간 느리다.
(StringBuffer 클래스의 경우가 StringBuilder 클래스의 경우보다 시간이 더 걸리는 이유는 동시성 제어를 고려하여 메소드가 구현되었기 때문)

* 포장 클래스
★기본형을 참조형으로 표현하기 위한 클래스
기본형의 값을 가지고 객체로 포장(boxing)함
사용 목적
메소드의 인자로 객체가 필요할 때(★제네릭 클래스가 제공하는 거의 모든 메소드가 기본형이 아닌 객체 유형, 즉 참조형의 인자가 필요)
클래스가 제공하는 상수를 사용할 때(Integer.MIN_VALUE, Integer.MAX_VALUE 등, Double.MIN_VALUE : 양수로써 최소값, Double.MAX_VALUE : 양수로써 최대값)
클래스가 제공하는 다양한 메소드를 사용할 때

* Number 클래스
Number는 Byte, Short, Integer, Long, Float, Double의 추상 부모 클래스
Number의 자식 클래스에서 구현된 주요 메소드
byte byteValue( ), short shortValue( ), … : 객체를 해당 기본형의 숫자로 변환(unboxing)
Integer객체.intValue() 이렇게 하면 int값으로 리턴
int compareTo(Byte anotherByte), … : this와 인자를 비교하여 같으면 0을 리턴(this가 작으면 음수 리턴, 크면 양수 리턴) XXX.compareTo(YYY)
boolean equals(Object obj) : 같은 유형이고, 값이 같으면 true를 리턴

* String과 기본형 데이터 간의 변환
포장 클래스가 제공하는 static 메소드를 사용함
String을 int(또는 long)형으로 변환할 때
int n = Interger.parseInt("123");
long l = Long.parseLong("1234");
int형(또는 long)을 String 형으로 변환
String s1 = Integer.toString(4); // "4"
String s2 = Long.toString(5); // "5"
String s3 = String.valueOf(123); // "123"

* Integer 클래스
Integer, String, int 사이의 변환 기능을 제공
다른 클래스들도 유사한 기능을 제공함
static int parseInt(String s) : String을 int로
static String toString(int i) : int를 String으로
static Integer valueOf(int i) : int를 Integer로
static Integer valueOf(String s) : String을 Integer로
String toString( ) : Integer를 String으로

* 박싱
기본형 데이터를 포장 클래스의 객체로 변환하는 것
Double radius = new Double(2.59); // 생성자 사용, 구식, 2.59가 double 값인데 Double 객체를 만들기 위한 생성자를 통해 Double을 만듦(double -> Double 이게 박싱) -> 잘 안 쓰임
Double radius = Double.valueOf(10.4); // valueOf( ) 사용
Double radius = 2.59; // 자동 boxing(요즘엔 이렇게 씀)
double -> Double 박싱, Double -> double 언박싱
자동 박싱
기본형에서 포장 클래스의 객체로 자동 변환되는 것
인자에 전달되거나 변수에 대입될 때 적용됨

* 언박싱
포장 클래스의 객체를 기본형 데이터로 변환하는 것
포장 클래스에서 기본형Value( ) 메소드를 사용
radius는 Double형 객체라 가정
double r = radius.doubleValue( ); // 객체.기본형Value( ) // Double -> double
double r = radius; // 자동 unboxing
System.out.println(new Integer(3) % 2); // 자동 unboxing // 여기서 new Integer는 Integer인데 이게 int로 자동 언박싱되어 3이 된다.
자동 언박싱
포장 클래스의 객체에서 기본형으로 자동 변환되는 것
인자에 전달되거나 변수에 대입될 때 적용됨

* System 클래스
Java 플랫폼 및 시스템과 관련된 기능 제공
유용한 클래스 필드와 메소드를 가짐
★모든 멤버는 static, 사용 시 객체를 생성할 필요 없음(out : System 클래스에 정의되어 있는 static 데이터 필드)
주요 기능
표준 입출력
JVM 또는 운영체제 속성과 시스템 환경 변수의 사용
배열 복사

* System 클래스의 표준 입출력 필드
System.in
표준 입력 스트림으로 InputStream 유형
키보드로부터 입력을 받을 때 사용
★System.in.read( )는 키보드로부터 1바이트 문자를 입력 받음(한글을 입력하면 처리 불가)
System.out
표준 출력 스트림으로 PrintStream 유형
화면에 데이터를 출력할 때 사용
System.err
표준 에러 출력 스트림으로 PrintStream 유형
오류 메시지를 화면에 출력할 때 사용

System.in.read()는 아스키코드 / int값을 리턴
0을 입력하면 0의 아스키코드 값인 48을 리턴

System.in.available() : 현재 아직도 유효한 입력된 문자 개수를 따짐
★윈도우에서 엔터키를 치면 캐리지 리턴키(CR)와 라인피드(LF) 문자로 조합되서 전달이 된다.(Carriage Return & Line Feed, Carriage Return의 아스키코드값은 13이고 Line Feed의 아스키코드 값은 10) 리눅스나 다른 운영체제에서는 다를 수 있음
import java.io.*;
public class ExInput {
	public static void main(String args[ ]) throws IOException {
		char cInput = 0;
		int i;
		System.out.print("Input a character: ");
		cInput = (char)System.in.read( );
		System.out.println(cInput);
		i = System.in.read( );
		System.out.println(i);
		i = System.in.read( );
		System.out.println(i);
		System.out.println(System.in.available( ));
	}
}
Input a character: a입력 후 엔터를 치면 결과가
a
13
10
0

import java.io.*;
public class ExInout4 {
	public static void main(String args[]) throws IOException {
		String szInputLine;
		int nValue;
		InputStreamReader isr = new InputStreamReader(System.in); // 1바이트 단위 입력을 할 수 있는 System.in 객체를 InputStreamReader를 이용해서 문자 단위 입력이 가능하게
		BufferedReader is = new BufferedReader(isr);
		System.out.print("Input a number: ");
		szInputLine = is.readLine( );
		nValue = Integer.parseInt(szInputLine);
		System.out.println(nValue);
		is.close();
	}
}

* java.lang 패키지는 import 구문을 쓰지 않더라도 모든 Java 소스 코드에 자동으로 포함된다.
* String은 문자열 처리를 위한 다양한 메소드를 제공하지만 immutable 클래스로, String 객체는 생성 이후에 내용 변경이 불가능하다.
* toString() 메소드와 equals() 메소드는 Object 클래스에서 정의되어 있으며, 몇몇 하위 클래스들에서 적절히 재정의되어 있다.
* 자주 변경되는 문자열을 다루어야 할 경우에는 String 클래스보다 StringBuffer나 StringBuilder 클래스를 사용하는 것이 보다 효율적이다.
* 기본형 값을 객체로 다루기 위해, 모든 기본형마다 상응하는 포장 클래스가 존재한다.
* System 클래스는 표준 입력과 출력, 표준 오류 출력을 위해 in, out, err 객체를 제공한다.









*****************************************************************************
9강. java.io 패키지와 스트림
*****************************************************************************

* 스트림
Java 언어에서 스트림을 통해 입출력을 수행할 수 있음
입력 스트림은 데이터 생산자(소스)와 연결
출력 스트림은 데이터 소비자(목적지)와 연결
다양한 입출력 종류(디스크, 문자 배열, 네트워크 소켓, 다른 프로그램 등)에 상관없이 동일한 방법으로 프로그램을 작성
스트림을 통해 입출력을 제어함
스트림 : 순서가 있는 일련의 데이터 흐름을 의미, 데이터 생산자(소스)와 데이터 소비자(목적지) 사이의
데이터가 지나는 통로

* 스트림의 분류
바이트 스트림과 캐릭터 스트림
바이트 스트림은 1 byte 단위로 데이터를 다룸
xxxInputStream(입력)과 xxxOutputStream(출력)
캐릭터 스트림은 char(2 바이트 문자) 단위로 데이터를 다룸
xxxReader(입력)과 xxxWriter(출력)
기본 스트림과 보조 스트림
기본 스트림은 입출력 기능을 제공하는 스트림
보조 스트림은 자체적으로 입출력 기능을 수행할 수는 없어서 기본 스트림과 함께 사용되어야 하며, 보조 기능을 제공하는 스트림

* 스트림 관련 클래스
java.io 패키지의 스트림 클래스
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	처리 방향		입력 스트림		출력 스트림
처리 단위
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	바이트 스트림	InputStream		OutputStream
기본			FileInputStream		FileOutputStream
스트림	ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	문자 스트림	Reader			Writer
			FileReader		FileWriter
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ	
	바이트 스트림	BufferedInputStream	BufferedOutputStream
보조						PrintStream
스트림			DataInputStream		DataOutputStream
			ObjectInputStream		ObjectOutputStream
	ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	문자 스트림	BufferedReader		BufferedWriter
						PrintWriter
	ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
	기타		InputStreamReader		OutputStreamWriter
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
★ 뒤에 Stream이 붙으면 바이트 스트림
★ Input / Output 바이트 스트림
★ Reader / Writer 문자 스트림
FileInputStream fis = new FileInputStream();
BufferedInputStream bis = new BufferedInputStream fis;
입력 스트림이면 데이터 생산자를 결정해야하고, 출력 스트림이면 소비자를 결정해야함

** 바이트 스트림
* InputStream 클래스(추상 클래스)
바이트 단위 입력 스트림 클래스의 최상위 클래스
주요 메소드
abstract int read( ) :★입력 스트림으로부터 1 바이트를 읽어 정수(★아스키 코드 / Reader 클래스 설명에서는 유니코드라고 함)로 리턴함(한글은 못 읽음. 한글은 2바이트, 즉, 문자 단위로 읽어야함) System.in.read()에서 System.in(키보드 입력을 받기 위한 표준 입력 스트림)이 InputStream 유형
int read(byte[ ] b) : 입력 스트림으로부터 읽어서 byte 배열에 저장, 읽어 들인 바이트 개수를 리턴함
int read(byte[ ] b, int off, int len) : 바이트 배열의 off 위치부터 byte 단위 개수인 len(바이트 길이) 만큼 읽는다.
int available( ) : 다음 read( )할 때, 블로킹 없이(지연 작업 없이)  입력 스트림에서 읽을 수 있는 데이터 길이
long skip(long n) : 입력 스트림에서 n 바이트를 건너 뜀. 실제 건너뛴 바이트 수가 리턴됨
void mark(int readlimit), void reset( ) : 입력 스트림에서 현재 읽을 위치(현재의 포지션 값)를 기억해둠. reset()이 호출되면 mark해놨던 포지션으로 이동(읽을 위치를 이동)

* OutputStream 클래스(추상 클래스)
바이트 단위 출력 스트림 클래스의 최상위 클래스
하위 클래스는 xxxOutputStream
주요 메소드
★void write(int b) : 1 바이트의 데이터를 출력 스트림에 씀(인자로 주어지는 것은 int b. 즉 4바이트. 그 중에서 1바이트만 취해서 데이터 출력을 함)
void write(byte[ ] b) : byte 배열의 내용을 출력 스트림에 씀
void write(byte[ ] b, int off, int len)
void close( ) : 출력 스트림을 닫고 할당받은 자원을 시스템에 반납
void flush( ) : 출력을 하면 출력 스트림에 출력을 하는 것인데, flush()를 하면 스트림에 남아있는 바이트 데이터를 강제로 데이터 목적지로 내보낸다.

** 캐릭터 스트림
* Reader 클래스
입력용 캐릭터 단위 스트림 클래스의 최상위 클래스
추상 클래스이며 이것의 하위 클래스는 xxxReader
주요 메소드
int read( ) : 1개 문자(2 바이트)를 읽어 리턴함(한글 읽을 수 있음)
int read(char[ ] cbuf) : 문자를 읽어 char 배열에 저장함, 읽어 들인 문자의 개수를 리턴함
boolean ready( ) : 스트림이 읽힐 준비가 되었으면(블러킹 없이, 지연 없이) true를 리턴함
abstract void close( ) : 입력 스트림을 닫고 자원을 반납함

* Writer 클래스
출력용 캐릭터 단위 스트림 클래스의 최상위 클래스
추상 클래스이며 이것의 하위 클래스는 xxxWriter
주요 메소드
void write(int c) : 1개의 문자(2 바이트)를 출력함
void write(char[ ] cbuf) : 캐릭터 배열에 있는 내용을 출력(출력 스트림에 내보낸다.)
void write(String str) : String을 출력
void write(String str, int off, int len) : off 위치에서 문자 단위로 len 길이만큼 출력
abstract void close( )

** 파일 입출력(가장 많이 쓰인다고 볼 수 있음)
* File 클래스(파일 자체 혹은 디렉터리 하나를 표현하기 위한 클래스)
★jdk7부터는 java.io 패키지의 File 클래스를 쓰지말고 java.nio.file 패키지에 있는 Path 인터페이스를 쓰기를 권장하고 있음
파일이나 디렉터리를 표현
상대 또는 절대 경로를 가짐
파일/디렉터리를 조작할 수 있는 메소드 제공
이름과 경로의 조회
파일과 디렉토리의 생성과 삭제
★파일에다가 직접 입력하거나 출력하는 입출력 메소드는 제공되지 않음(파일 클래스는 파일 자체 혹은 디렉터리 하나를 표현하기 위한 클래스. 파일의 입출력을 하려면 FileInputStream, FileOutputStream, FileReader, FileWriter를 써야함)
생성자
File(String pathname)
pathname은 상대 또는 절대 경로로 표현될 수 있음
★File myFile = new File("c:\\temp\\data.txt"); // \\두개 주의

* File 클래스의 주요 메소드
boolean exists( ) : 파일 객체.exists() / 존재하느냐
boolean isDirectory( ), boolean isFile( ) : 디렉토리냐, 파일이냐
String getName( ) : 경로의 맨 마지막 이름
String getPath( ) : 경로를 문자열로 바꾸어 리턴
long length( ) : 파일이면 데이터의 바이트 수 리턴
boolean createNewFile( ) : 해당 파일 객체를 create(존재하지 않으면 파일을 생성후 true 리턴)
boolean delete( ) : 파일이나 디렉터리 삭제. 디렉터리의 경우 그 디렉터리가 empty인 경우에만 삭제가 된다.
boolean mkdir( ) : 지정된 경로에서 맨 마지막 디렉터리만 만듦(확인해봐야함)
boolean mkdirs( ) : 중간 경로까지 만듦
String[ ] list( ) : File 객체에 지정된 디렉터리 안에 들어 있는 파일과 서브 디렉터리들의 이름을 문자열 배열로 반환, 에러일 경우 null을 리턴
File[ ] listFiles( ) : File 객체에 지정된 디렉터리 안에 들어 있는 파일과 서브 디렉터리들의 경로를 File 배열로 반환, 에러일 경우 null을 리턴
String getParent( ), File getParentFile( ) : 상위 경로의 이름(또는 File 객체)을 반환
static File[ ] listRoots( ) : 루트 디렉터리들을 File 배열로 반환(static 메소드이기 때문에 File.listRoots();)

* 디렉터리의 내용을 보여주는 예제
import java.io.*;
public class ListDirectory2 {
	public static void main(String args[]) {
		File file = new File("c:\\windows"); // \\두개 주의, ★디렉터리가 아닌 경우 null이 리턴되어 file에 null이 대입되고 그 다음 행부터 문제가 된다.
		File files[ ] = file.listFiles( );
		int i = 0;
		while(i < files.length) {
			System.out.print(files[i].getPath( ));
			System.out.println("\t" + files[i].length( ));
			i++;
		}
	}
}
c:\windows\addins 0
c:\windows\afreeca.ico 353118
c:\windows\AhnInst.log 121513

* RandomAccessFile 클래스
랜덤 엑세스 파일
파일의 임의 위치에서 읽기/쓰기가 가능
파일을 오픈하고, 위치를 지정하고, 읽기/쓰기를 함
★읽고 쓰는 위치는 파일 포인터가 가리킴, 읽기(또는 쓰기)는 파일 포인터가 가리키는 위치부터 바이트
단위로 읽음(또는 씀)
byte 단위로 읽고 쓰며, 파일 포인터가 이동됨
랜덤 엑세스 파일을 커다란 byte 배열로 볼 수 있음

* RandomAccessFile 클래스의 메소드
생성자
RandomAccessFile(File file, String mode),
RandomAccessFile(String name, String mode)
mode는 읽기 전용의 ＂r＂ 또는 읽기/쓰기 겸용의 "rw"(★r로 했는데 쓰기 연산을 시도하면 IOException 발생, r로 했는데 해당 파일이 존재하지 않으면 FileNotFoundException 발생)
주요 메소드
int read( )
int read(byte[ ] b), int read(byte[ ] b, int off, int len)
void seek(long pos) : 인자로 포지션. 읽기나 쓰기를 할 위치를 파일 포인터가 가리키고 있는데, seek은 파일 포인터의 위치를 설정해준다. 파일 포인터를 이동
void write(byte[ ] b),
void write(byte[ ] b, int off, int len)

import java.io.*;
public class RAFTest {
	public static void main(String args[ ]) {
		try {
			RandomAccessFile raf;
			raf = new RandomAccessFile("c:\\java\\test.txt", "rw"); // ★RandomAccessFile을 생성한다. 해당 파일을 오픈한다는 의미. rw 모드일 경우, 해당 파일이 없으면, 해당 파일을 생성한다.
			for( int i = 0; i < 10; i++)
				raf.write(i);
			for(int i = 9;i >= 0;i--) {
				raf.seek(i); // 해당 파일 포인터를 옮긴 다음에
				System.out.print(raf.read( )); // 해당 위치에서 read
			}
			raf.close();
		} catch (Exception e) { System.out.println(e); }
	}
}

* FileInputStream, FileOutputStream 클래스
파일로부터 데이터를 읽기/쓰기 위한 입력/출력용 기본 스트림
바이트 단위의 입력/출력

FileInputStream 클래스의 생성자
기존 파일과 연결된 입력 스트림 객체를 생성
FileInputStream(File file), FileInputStream(String name)
바이트 단위로 입력을 받을 수 있기 때문에 이미지나 오디오 파일을 읽을 때 유용
없으면 FileNotFoundException 발생

FileOutputStream 클래스의 생성자
기존 파일(없다면 생성)과 연결된 출력 스트림 객체를 생성
FileOutputStream(String name)
FileOutputStream(File file, boolean append) : append 값을 true를 하면 기존 파일 맨 뒤에 붙여쓰기
없으면 FileNotFoundException 발생
바이트 단위로 파일에 출력을 함

* FileOutputStream 예제(복사 예제)
import java.io.*;
public class FileOutputStreamTest {
	public static void main(String args[ ]) {
		try {
			File inFile, outFile;
			inFile = new File("c:\\Java\\FileInputStreamTest.java"); // 이 파일을 아래 경로에 복사할 예정
			outFile = new File("c:\\Java\\FileTemp.java"); // 출력용 파일의 경우 해당 파일이 존재하지 않으면 생성함, 존재하면 덮어씀
			InputStream is = new FileInputStream(inFile);
			OutputStream os = new FileOutputStream(outFile);
			int nData;
			nData = is.read( );
			while(nData != -1) { // ★파일의 끝이면 -1 리턴
				os.write(nData);
				nData = is.read( );
			}
			is.close( ); os.close( ); }
		catch (Exception e) {
			System.out.println(e); }
		}
}

* FileReader, FileWriter 클래스
텍스트 파일을 다루기 위한 기본 스트림
문자 단위의 입력 / 출력
FileReader(File file)
FileReader(String fileName)
FileWriter(File file)
FileWriter(String fileName)
FileWriter(File file, boolean append)

** 콘솔 입출력과 보조 스트림
콘솔 입출력을 제공하는 클래스
키보드 입력과 화면 출력을 편리하게 지원
1. 표준 스트림 이용 System.in : 콘솔 입력(키보드 입력), System.out : 모니터 출력
2. 콘솔 클래스 이용. System.in이나 System.out 보다 편리
★명령 프롬프트 창에서 실행해야 함
★System.console( )을 사용하여 콘솔 객체를 생성함
주요 메소드
String readLine( ) : 한 라인을 읽음
char[ ] readPasssword( ) : 입력할 때 화면에 보이지 않음
PrintWriter writer( ), Reader reader( )

import java.io.*;
public class ConsoleTest {
	public static void main(String args[]) {
		String name;
		char[ ] pw; // 문자 배열
		Console con = System.console( ); // 콘솔 객체를 생성함
		System.out.print("name : ");
		name = con.readLine( ); // 한 라인을 읽음
		System.out.print("password : ");
		pw = con.readPassword( );
		PrintWriter pr = con.writer( );
		pr.println("name : " + name);
		pr.println("password : " + pw);
	}
}
>java ConsoleTest
name : kildong↲
password : ↲
name : kildong
password : [C@16d3586 // 암호화된 내용으로 출력된 것임

* 보조 스트림
기본 스트림의 성능을 높이거나 보조 기능을 제공하는 스트림
입출력 기능을 직접 수행하지는 못함
보조 스트림을 생성할 때, 기본 스트림 객체를 생성자의 인자로 이용함
‘기본 스트림을 보조 스트림으로 감싼다’라고 함
프로그램에서는 보조 스트림을 사용해 입출력하면 됨
FileInputStream fis = new FileInputStream( );
BufferedInputStream bis = new BufferedInputStream(fis);

* 보조 스트림 종류
버퍼링 기능의 제공
BufferedInputStream, BufferedOutputStream
BufferedReader, BufferedWriter

Java의 기본 자료형을 그대로 읽기/쓰기 위한 기능의 제공 : DataInputStream, DataOutputStream
DataOutputStream을 통해 writeInt()하고 DataInputStream을 통해 readInt()

다양한 출력 형식의 제공 : PrintStream(System.out이 PrintStream유형, printf()나 format(), printLine() 같은거), PrintWriter
텍스트 파일을 라인 단위로 읽는 메소드를 제공 : LineNumberReader
★바이트 스트림과 캐릭터 스트림의 호환 : InputStreamReader, OutputStreamWriter

* LineNumberReader 클래스
텍스트 파일을 라인 단위로 읽어 들이는 메소드 제공
BufferedReader의 서브 클래스
주요 메소드
String readLine( )
int getLineNumber( ) : 라인 번호를 리턴

File file = new File("src\\LineNumberTest.java");
FileReader fr = new FileReader(file);
LineNumberReader rd = new LineNumberReader(fr);
String line;
while ((line = rd.readLine( )) != null) { // ★한 줄씩 라인 단위로 읽어서 라인 끝을 의미하는 캐리지 리턴이나 라인 피드를 제외한 나머지를 문자열로 리턴
	System.out.print(rd.getLineNumber( )+" ");
	System.out.println(line);
}

* InputStreamReader 클래스
★★바이트 입력 스트림을 캐릭터 입력 스트림으로 바꾸기 위한 클래스
바이트 단위로 읽은 후 문자로 바꾸어 처리함
생성자는 InputStreamReader(InputStream in)
int read( )
1개 문자를 읽어 리턴함
int read(char[] cbuf, int offset, int length)

★★InputStreamReader isr = new
	InputStreamReader(System.in); // System.in, 즉, InputStream 객체(1 바이트만 읽을 수 있는 것)를 감쌈
try {
	while((i = isr.read( )) != '끝') { // isr.read( ) 하면 2바이트 문자 단위로 읽기 가능(한글 가능)
		System.out.print((char) i);
}
} catch ( … … 

* Java 프로그램에서는 스트림을 통해 데이터 생산자(또는 소비자)의 종류와 무관하게 동일한 방법으로 입력(또는 출력)을 수행할 수 있다.
* File 클래스는 파일(또는 디렉터리)를 표현하는 클래스로 파일(또는 디렉터리)를 조작할 수 있는 메소드를 제공하나 입출력 메소드는 제공하지 않는다.
* RandomAccessFile 클래스는 파일의 읽기/쓰기를 지원하며 파일 포인터가 가리키는 임의의 위치에 읽기/쓰기가 가능하다.
* BufferedInputStream(OutputStream)과 BufferedReader(Writer)는 보조 스트림으로 버퍼링 기능을 제공하여 입출력 성능을 향상시킨다.
* 기본 스트림의 객체를 먼저 생성하고, 그 객체를 인자로 하여 보조 스트림 객체를 생성한다.
* InputStreamReader는 바이트 스트림으로 읽어들인 데이터를 캐릭터 스트림으로 변환시킨다.









*****************************************************************************
10강. java.nio 패키지의 활용
*****************************************************************************

* java.nio 패키지
NIO는 ‘New Input Output의 약자’
기존 java.io 패키지를 개선한 새로운 입출력 패키지
JDK 7부터는 파일 I/O를 개선한 NIO2도 등장
java.nio와 그것의 서브 패키지 형태(java.nio.file , java.nio.channels, java.nio.charset 등)
File 클래스보다 다양한 기능을 제공하는 Path 인터페이스
Files의 static 메소드를 통한 파일/디렉터리의 조작, 파일의 읽기/쓰기
입력과 출력이 모두 가능한 FileChannel 클래스 : 버퍼링 기능, 멀티스레드에 안전
★비동기식 입출력을 위한 AsynchronousFileChannel 클래스 : non-blocking 방식 파일 입출력. 입출력을 별도의 쓰레드로 관리하고 프로그램은 다른 작업을 수행하게끔 함. 즉 멀티쓰레드

* Path 인터페이스
 java.nio.file 패키지에 존재하며 java.io.File 클래스를 대신함
파일시스템에 존재하는 파일이나 디렉터리에 해당하는 경로를 표현함 : 절대 경로 또는 상대 경로로 표현됨
경로의 생성, 경로의 비교, 경로 정보 추출, 경로 요소 조작 기능 등을 제공
★java.nio.file.Files 클래스의 static 메소드를 이용해 Path 객체에 대한
다양한 실제 조작(읽기, 쓰기, 복사, 이동 등)이 가능함

Path 객체의 생성 방법
★java.nio.file.Paths.get(＂C:\\tmp\\foo＂) // Path 인터페이스를 구현한 클래스의 객체(FileSystems.getDefault( ) 후에 JVM이 다루는 기본 파일 시스템이 리턴이 되고, FileSystem 객체.getPath()의 축소 버전이 java.nio.file.Paths.get(＂C:\\tmp\\foo＂)임)
파일이나 디렉터리 경로(절대 또는 상대 경로)를 명시해야 함

* Path 인터페이스의 메소드(아래는 모두 인스턴스 메소드 객체.compareTo(또 다른 객체) 이런식으로 사용)
int compareTo(Path other) : 두 경로를 비교
Path getFileName( ) : 파일 또는 디렉터리 이름을 Path 객체로 리턴
FileSystem getFileSystem( ) : Path 객체를 생성해준 파일 시스템 객체를 리턴(상대 경로 리턴).★FileSystems.getDefault( )과 동일(FileSystems.getDefault( )은 기본 파일 시스템을 리턴함)
Path getName(int index) : C:\\temp\\foo 여기서 temp의 인덱스는 0, foo는 1, Path 객체 리턴
int getNameCount( ) : 경로에 포함된 디렉터리나 파일의 개수. Path에 존재하는 요소의 개수. 위의 경우 2가 리턴
Path getParent( ) : 경로의 맨 오른쪽을 제외한 것. 절대 경로 리턴
Path getRoot( ) : 루트 리턴. 절대 경로 리턴
Iterator<Path> iterator( ) : Path 요소를 다룰 수 있도록. Iterator는 인터페이스. 이걸 구현한게 Scanner 클래스
File toFile( ) : java.io 패키지의 파일과의 호환성을 위해. Path 객체.toFile() 이렇게 하면 io 패키지의 파일 객체를 리턴 받을 수 있다.
String toString( )

* ★★Path 인터페이스 사용 예
import java.util.*;
import java.nio.file.*;
public class PathTest {
	public static void main(String args[ ]) {
		try {
			Path path = Paths.get("C:\\windows\\system32\\drivers\\etc\\hosts"); // Path 객체 만들기
			System.out.println("파일 이름 : " + path.getFileName( )); // hosts 리턴
			System.out.println("상위 폴더 : " + path.getParent( ).getFileName( )); // getParent()로 인해 처음부터 etc까지 나오고, 거기에 getFileName()이니까 etc 리턴(Path 객체 리턴)
			System.out.println("경로 길이 : " + path.getNameCount( ));
			System.out.print("현재 경로 : ");★★★
			for (int i = 0; i < path.getNameCount( ); i++)
				System.out.print(path.getName(i) + "\\");
			Iterator<Path> it = path.iterator( );
			System.out.print("\n현재 경로 : ");
			while (it.hasNext( ))
				System.out.print(it.next( ).getFileName( ) + "\\");
		} catch (Exception e) {
			System.out.println(e);
		}
	}
}
파일 이름 : hosts
상위 폴더 : etc
경로 길이 : 5
현재 경로 : windows\system32\drivers\etc\hosts\
현재 경로 : windows\system32\drivers\etc\hosts\

* FileSystem과 FileStore 클래스
FileSystem의 메소드(FileSystem은 java.nio.File 패키지에 있는 클래스)
FileSystem은 파일 시스템에 대한 인터페이스를 제공
하나 이상의 파일 스토어로 구성됨
FileSystems.getDefault( )은 기본 파일 시스템을 리턴함
★Iterable <FileStore> getFileStores( ) : Iterable 유형의 파일스토어들로 이루어진 객체가 리턴됨. 여기서 Iterable은 향상된 for문에서 오른쪽에 들어갈 수 있음(Iterable은 for문으로, Iterator는 while안에 hasNext()로)
WatchService newWatchService( )

FileStore의 메소드
FileStore는 파티션(또는 볼륨)을 표현함
String name( ), String type( )
long getTotalSpace( ),
long getUnallocatedSpace( ), long getUsableSpace( )

import java.nio.file.*;
public class FileSystemTest {
	public static void main(String args[]) throws Exception { // ★파일입출력, 파일시스템, 파일스토어 관련해서는 보통 IOException 처리해야함
		FileSystem fs = FileSystems.getDefault( );
		for (FileStore store : fs.getFileStores( )) { // ★Iterable <FileStore> getFileStores( ), Iterable은 for문으로, Iterator는 while안에 hasNext()로
			System.out.println("드라이브 이름 : " + store.name( ));
			System.out.println("파일시스템 타입 : " + store.type( ));
			long total = store.getTotalSpace( );
			long free = store.getUnallocatedSpace( );
			System.out.println("전체 공간 : " + total + " bytes");
			System.out.println("사용 중인 공간 : " + (total - free) + "bytes");
			System.out.println("사용 가능한 공간 : " + free + " bytes");
			System.out.println( );
		}
	}
}
드라이브 이름 : C드라이브
파일시스템 타입 : NTFS
전체 공간 : 2000290836480 bytes
사용 중인 공간 : 97686507520 bytes
사용 가능한 공간 : 1902604328960 bytes

* Files 클래스
파일 조작 기능을 제공하는 static 메소드를 제공함
★메소드는 Path 객체를 인자로 가지고 작업함

파일의 읽기와 쓰기
byte[ ] readAllBytes(Path)
Path write(Path, byte[ ]) : 파일 출력, byte[ ] 배열에 있는 내용을 Path가 표현하는 파일에 write

파일이나 디렉터리의 검사/생성/삭제/복사/이동/속성관리
boolean isDirectory(Path)
boolean isRegularFile(Path) : 정규 파일이냐
이 밑에서부터는 IOException 처리 해야함
Path createFile(Path)
void delete(Path) : 디렉터리를 delete할 경우 디렉터리가 empty인 경우만 delete 가능
Path copy(Path, Path)
Path move(Path, Path) : 이동 또는 이름 바꾸기
long size(Path), UserPrincipal getOwner(Path)

import java.nio.file.*;
public class FilesTest2 {
	public static void main(String args[ ]) throws Exception {
		Path path = Paths.get("C:\\Java");
		DirectoryStream<Path> ds = Files.newDirectoryStream(path); // ★newDirectoryStream(path) : 인자로 들어간 path가 디렉터리라고 보고, 이 디렉토리에 포함된 목록들, 즉, 파일들이나 서브 디렉터리들을 확인하기 위한 메소드, ★DirectoryStream는 Iterable의 서브 인터페이스로 보면 됨. 그래서 향상된 for문 오른쪽에 들어갈 수 있음
		for (Path p : ds) {
			if (Files.isDirectory(p)) { // 디렉터리인 경우
				System.out.println("[디렉터리] " + p.getFileName( ));
			} else { // 파일인 경우
				System.out.print("[파일] " + p.getFileName( ));
				System.out.println(" (" + Files.size(p) + ")");
			}
		}
	}
}
[디렉터리] Example
[파일] FileInputStreamTest.java (434)
[파일] FilesTest1.java (800)
[디렉터리] temp
[파일] winhlp.exe (9728)
[파일] winhlp32.exe (9728)

* 버퍼
데이터 생산자와 프로그램(입력), 프로그램과 데이터 소비
자(출력) 간 속도 차로 인해 지연이 발생할 수 있음
버퍼를 사용하면 지연 현상을 방지할 수 있음
프로그램은 버퍼로부터 데이터를 읽음(입력)
프로그램은 버퍼로 데이터를 출력함(출력)
Java 프로그램 <- Input Buffer <- 데이터 생산자
Java 프로그램 -> Output Buffer -> 데이터 소비자

* Buffer 클래스
★버퍼는 기본형 값을 저장하는 데이터 보관소
채널 입출력에 사용되며 버퍼 단위로 입출력할 수 있음
java.nio 패키지에 존재하며, ★Buffer는 추상 클래스
자식 클래스에서 구현해야 할 공통의 메소드를 선언
실제 사용을 위해 boolean을 제외한 모든 기본형에 대해 서브 클래스가 존재함(자식 클래스)
ByteBuffer, CharBuffer , DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer

* 버퍼의 생성
버퍼의 생성
1. Buffer buffer = ByteBuffer.allocate(1024*1024); // allocate는 static 메소드
자바 가상기계가 관리하는 메모리에 버퍼를 생성 :  allocate()
운영체제가 관리하는 메모리에 버퍼를 생성 :  allocateDirect()
2. byte[ ] barray = new byte[100]; Buffer bbuffer = ByteBuffer.wrap(barray);

* 버퍼의 속성
★(0 <= mark <= position <= limit <= capacity)
capacity : 버퍼의 크기(데이터의 개수)로 생성될 때 정해짐, 변하지 않음. 버퍼에 저장되는 데이터의 개수(바이트 수가 아니고 저장될 수 있는 데이터 수)
position : 읽기나 쓰기가 적용되는 위치 (position <= limit). 최초의 position은 0. 처음 write한다고 했을 때, 처음 position이 0이니까 0번부터 write 됨
limit : 읽거나 쓸 수 없는 최초 위치 (limit <= capacity). 버퍼가 처음 만들어질 때 limit은 설정되어 있지 않음(근데 뒤에서는 또 처음에 설정된다고 함). 즉, undefined 상태. ★flip 메소드는 버퍼에 담겨있는 데이터를 내보낼 때 사용되는데, flip 메소드 후 position은 0이 되고, 그 때 당시(flip메소드 호출 시점)의 position 값이 limit로 설정됨(limit값-1까지만 유효함. 유효한 데이터의 저장위치 바로 다음 위치가 limit)
mark : 버퍼가 reset( ) 되었을 때 position이 가리킬 위치. mark가 호출되면 그 시점에서의 포지션 값이 mark 값으로 설정됨. reset하면 mark를 호출했을 때의 position값으로 position 값이 재설정됨

* Buffer 클래스의 메소드
Buffer mark( ) : mark를 position의 값으로 설정
Buffer reset( ) : position을 mark의 값으로 설정
Buffer rewind( ) : position을 0으로 바꾸고 mark를 삭제, 처음부터 다시 읽기를 준비하는 것
Buffer flip( ) : limit를 position 값으로 설정(★쓰기 작업을 한 만큼만 읽어야 하니까), position은 0으로 변경. 버퍼에 쓰기를 끝내고, 버퍼 읽기를 준비하는 것. 실제 유효한 데이터는 limit-1까지임
Buffer clear( ) : 버퍼를 초기 상태로 돌림. 새로운 쓰기를 준비하는 것(position은 0으로, capacity와 limit은 버퍼의 크기로)

0부터 9까지 있다고 할 때, 처음 버퍼가 생성되면 position은 0이고, capacity와 limit은 9인데, 실제 유효한 버퍼는 8까지. mark는 undefined 상태

* 버퍼 읽기와 쓰기(스트림에서는 바이트나 캐릭터 단위로 읽거나 썼다면, nio에서는 버퍼 단위로 읽고 씀)
Buffer의 서브클래스에서 제공
ByteBuffer, CharBuffer, DoubleBuffer, …

상대적 읽기/쓰기 메소드(ByteBuffer에서)
현재 position에서 읽기 또는 쓰기를 수행하며, 읽거나 쓴 요소 만큼 position 값이 증가함

읽기
★byte get() : 읽거나 쓴 요소만큼 1증가(1byte)
★ByteBuffer get(byte[ ]) : 읽거나 쓰고나면 ByteBuffer의 개수만큼 증가

쓰기
ByteBuffer put(byte), ByteBuffer put(byte[ ])

★절대적 읽기/쓰기 메소드(데이터 하나만. 아래에서는 1byte만 읽거나 쓸 수 있음)
position 값에 영향을 주지 않음
byte get(int index) : 여기서 index는 어느 위치에서 읽을것이냐
ByteBuffer put(int index, byte b) : 어느 위치에 기록할 것이냐

* FileChannel 클래스(스트림에서는 바이트나 캐릭터 단위로 읽거나 썼다면, nio에서는 버퍼 단위로 읽고 씀)
java.io 패키지의 파일 관련 입출력 스트림을 대체
java.nio.channels 패키지에 존재
파일에 대한 읽기와 쓰기를 모두 제공
멀티 스레드 환경에서도 안전하게 사용할 수 있음
읽기와 쓰기 메소드
int read(ByteBuffer dst) : 실제 파일로부터 읽어서 ByteBuffer에 기록
int write(ByteBuffer src) : ByteBuffer에 있는 내용을 실제 데이터 소비자에 속하는 파일 채널에 전달

FileChannel 객체의 생성 방법
1. FileChannel.open(Path path, OpenOption … options)
옵션은 StandardOpenOption.READ 등(열거형으로 파일을 오픈할 때 읽기용으로 오픈한다는 의미)
WRITE는 쓰기용, CREATE는 생성하겠다
2. FileInputStream 이나 RandomAccessFile 객체에서 getChannel( ) // 기존 java.io와의 호환성을 위함

* FileChannel 클래스에 관한 설명으로 틀린 것은 무엇인가?
java.io 패키지의 파일 관련 스트림 클래스를 대체하기 위한 클래스이다.
FileChannel.open(path)으로 객체 생성을 하면 해당 파일을 읽기용으로 열게 된다.
멀티 스레드 환경에서도 안전하게 사용할 수 있게 설계되었다.
이것만 틀림 -> 파일 입력을 위해 FileChannelReader, 파일 출력을 위해 FileChannelWriter를 사용한다.

* ★★★FileChannel 클래스로 파일 만들기
import … …
public class FileChannelWriteTest{
	public static void main(String args[ ]) throws IOException{ // ★IOException 주의
		String[ ] data = {"안녕하세요, 여러분",… …, "모든 방법에 대해 공부해봅시다."};
		Path path = Paths.get("c:\\Java\\temp\\file.txt");
		Files.createDirectories(path.getParent( )); // ★Files의 static 메소드인 createDirectories를 이용해서 부모 디렉터리 중 존재하지 않을 수 있는 디렉터리를 먼저 만들어주기
		FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.CREATE, StandardOpenOption.WRITE); // 파일 시스템에 파일 생성 // FileChannel.open()을 이용해서 객체 생성, option은 여러 개 줄 수 있음. CREATE는 path에 해당하는 파일이 없다면 생성하겠다는 것
		Charset charset = Charset.defaultCharset( ); // JVM의 기본문자세트를 리턴 받아옴(한글때문)
		ByteBuffer buffer;
		int byteCount = 0;
		for(int i = 0;i < data.length;i++) {
			buffer = charset.encode(data[i]); // 기본문자세트를 이용해서 인코드 메소드 호출, ByteBuffer를 리턴
			byteCount = fileChannel.write(buffer);
		}
		fileChannel.close( );
	}
}
안녕하세요, 여러분Java 프로그래밍 언어의
세계로 오신 것을 환영합니다. JDK를 설치하는
방법에서부터Java 프로그램을 compile하고
실행시키는 모든 방법에 대해 공부해봅시다.

* ★★★FileChannel 클래스로 파일 읽기
import … …
public class FileChannelReadTest {
	public static void main(String args[ ]) throws IOException {
		Path path = Paths.get("c:\\java\\temp\\file.txt");
		FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.READ); // 읽기용
		ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024);
		Charset charset = Charset.defaultCharset( );
		StringBuffer sb = new StringBuffer( );
		int byteCount;
		while ((byteCount = fileChannel.read(buffer)) >= 0) { // read하면서 buffer의 position 값이 증가, // 버퍼 크기보다 파일 크기가 클 수 있기 때문에 fileChannel.read 작업을 여러 번 해야하기 때문에 while문 안에 보면 clear가 있어서 버퍼를 초기화
			buffer.flip( ); // ★버퍼에 기록된 것을 읽기. position 값을 0으로. flip 메소드 호출 당시의 position 값을 limit 값으로 설정 -> 기록된 만큼만 읽겠다는 말
			sb.append(charset.decode(buffer)); // 위의 예제에서 인코딩되어서 파일에 기록이 되었기 때문에 이번에는 디코딩해야함(문자열을 인코드해서 바이트 버퍼로 바꿨는데, 그걸 반대로 바이트 버퍼를 디코드해서 문자열로해서 받기) 
			buffer.clear( );
		}
			System.out.println(sb);
			fileChannel.close;
	}
}
안녕하세요, 여러분Java 프로그래밍 언어의
세계로 오신 것을 환영합니다. JDK를 설치하는
방법에서부터Java 프로그램을 compile하고
실행시키는 모든 방법에 대해 공부해봅시다.

* WatchService 인터페이스
어떤 대상(디렉터리)에 대해 변화나 이벤트가 생기는 것을 감시(watch)
디렉터리의 변화를 감지
디렉터리 내의 파일 또는 서브 디렉터리의 생성, 삭제, 수정
java.nio.file 패키지에 존재

감시자의 생성
먼저 WatchService 객체를 생성함
WatchService ws = FileSystems.getDefault( ).newWatchService( );

★FileSystems.getDefault( )의 활용
FileSystems.getDefault( ).newWatchService( );
FileSystems.getDefault( ).getPath()
FileSystems.getDefault( ).getFileStore()

* 감시 서비스를 구현하는 절차
1. 감시 대상 디렉터리를 WatchService에 등록
Path path = Paths.get("c:\\java\\temp");
알림을 받고자 하는 이벤트를 명시
path.register(ws, StandardWatchEventKinds.ENTRY_CREATE,
StandardWatchEventKinds.ENTRY_DELETE,
StandardWatchEventKinds.ENTRY_MODIFY);

2. WatchService는 take( ) 메소드를 호출하여 감시함
무한 루프 안에서, 이벤트가 발생할 때 까지 기다림
While(true) {
WatchKey key = ws.take( ); // WatchKey는 디렉터리 안에 관심 이벤트가 등록이 되어 있는데, 실제로 어떠 어떠한 이벤트가 발생했다는 상태 표현
WatchKey는 등록된 디렉터리에 어떤 관심 이벤트가 등록되어 있으며, 실제 어떤 이벤트가 일어났는지에 관한 상태 정보를 가지고 있다.

3. 이벤트가 발생하면, take( )가 리턴하는 WatchKey 객체를 이용하여 이벤트를 처리
WatchKey는 감시 대상 객체의 상태 정보를 가짐, pollEvents( )를 호출하여 WatchEvent 객체를 얻고(list 유형으로 얻을 수 있음) 어떤 변화가 생겼는지 알 수 있음
for (WatchEvent<?> event : key.pollEvents( )) {
	WatchEvent.Kind k = event.kind( ); // 이벤트 종류
	Path p = (Path)event.context( ); // 파일 이름
	… …
}
boolean valid = key.reset(); // 계속 감시하기 위해, WatchKey를 ready 상태로 돌림
if (!valid) break; // ★디렉터리가 삭제되는 등의 경우 false가 리턴되기 때문에 valid 상태가 아니기 때문. valid 하면 다시 돌고, valid가 아니면 if문을 타서 break이 된다.
}

* ★★WatchService 예제
public class WatchServiceTest {
	public static void main(String args[]) {
		try {
			WatchService ws;
			ws = FileSystems.getDefault().newWatchService();
			Path path = Paths.get("c:\\java\\temp"); // 감시 대상 디렉터리
			path.register(ws, StandardWatchEventKinds.ENTRY_CREATE, StandardWatchEventKinds.ENTRY_DELETE, StandardWatchEventKinds.ENTRY_MODIFY); // WatchService인 ws에 등록. CREATE, DELETE, MODIFY가 관심목록. 참고로 디렉터리 내 파일의 이름을 바꾸면 DELETE 됐다가 CREATE 되는 것임
			while (true) { // 무한루프
				WatchKey key = ws.take(); // 기다리다가 이벤트가 발생하면 take가 리턴됨
				for (WatchEvent<?> event : key.pollEvents()) {
					WatchEvent.Kind k = event.kind();
					Path p = (Path) event.context();
					if (k == StandardWatchEventKinds.ENTRY_CREATE) {
						System.out.println("File " + p.getFileName() + " is created.");
… …
				}
				boolean valid = key.reset();
				if (!valid) break;
			}
… …
File 새 텍스트 문서.txt is deleted.
File 새 텍스트.txt is created.

* java.nio와 그것의 서브 패키지는 java.io 패키지를 개선한 새로운 입출력 패키지이다.
* java.nio.file 패키지의 Path 인터페이스는 java.io 패키지의 File 클래스보다 풍부한 기능을 제공한다.
* Files 클래스는 실제 파일(또는 디렉터리) 조작과 읽기/쓰기 기능을 수행하는 static 메소드를 제공한다.
* java.nio.file의 FileChannel은 입출력을 모두 제공하고 기본적으로 버퍼링을 사용하며 멀티 스레드 환경에서도 안전하도록 설계되어 있다.
* java.nio.file 패키지의 WatchService는 디렉터리에 발생하는 이벤트를 감시하는 서비스이다.
* AsynchronousFileChannel 클래스를 이용하면 논-블로킹 방식 입출력을 지원하여 read(), write() 작업이 완료되지 않더라도 다른 작업을 동시에 수행할 수 있다.









*****************************************************************************
11강. 컬렉션
*****************************************************************************

* 컬렉션
여러 원소를 하나의 그룹으로 묶어 관리해주는 객체

* Java Collections Framework(JCF)
컬렉션을 표현하고 다루기 위한 통합된 프레임워크로 클래스와 인터페이스의 집합
다양한 방식으로 저장, 정렬, 검색, 수정하는 도구를 제공

컬렉션을 일관된 방법으로 다룰 수 있음
표준화된 인터페이스: 컬렉션의 기능을 표현
어떻게 표현되는 지와 상관없이 일관성 있게 다룸
클래스: 인터페이스를 구현한 클래스를 제공

* JCF의 구조
JCF의 인터페이스
Set(집합): 순서는 의미가 없으며 중복을 허용하지 않는 자료구조
List: 중복을 허용하고 순서에 의미가 있는 자료구조
Queue: List와 유사하나 원소의 삽입/삭제가 FIFO 방식
Map: 원소가 <key, value>의 형태이며 키는 유일해야 함
Iterable <- Collection <- Set <- SortedSet(상위 인터페이스가 Iterable이기 때문에 forEach의 오른쪽에 들어갈 수 있음)
Iterable <- Collection <- List(상위 인터페이스가 Iterable이기 때문에 forEach의 오른쪽에 들어갈 수 있음)
Iterable <- Collection <- Queue <- Dequeue(상위 인터페이스가 Iterable이기 때문에 forEach의 오른쪽에 들어갈 수 있음)
Map <- SortedMap

* JCF의 인터페이스와 클래스
java.util 패키지에 포함되며 제네릭 타입
다루는 자료의 유형을 지정해야 함

해싱 : 저장공간 안에 데이터가 비교적 균일하게 골고루 저장되도록 하는 기법
LinkedList(연결리스트) : List 인터페이스와 Queue 인터페이스를 구현한 클래스. 변수 선언 시 List 유형으로 할지, Queue 유형으로 할지 정해야함
List<Integer> list = new LinkedList<>();
Queue<Integer> queue = new LinkedList<>();

		Set 		List 		Queue	 	Map
해싱 		HashSet 						HashMap

배열 				ArrayList
				Vector(Stack)

연결리스트 			LinkedList 	LinkedList

해싱+연결리스트	LinkedHashSet 					LinkedHashMap
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
		SortedSet 					SortedMap
트리 		TreeSet 						TreeMap

* ★컬렉션 객체의 선언
변수 선언은 해당 인터페이스 유형으로, 객체 생성은 인터페이스를 구현하는 클래스를 사용
Set<Integer> set = new HashSet<>();
List<Integer> list = new ArrayList<>();
List<Integer> list = new LinkedList<>();
Queue<Integer> queue = new LinkedList<>();
Map<String, Integer> map = new HashMap<>();

* Collection<E> 인터페이스
Collection<E> : Set, List, Queue의 슈퍼 인터페이스
Set, List, Queue에서 공통으로 지원해야 하는 기능을 정의

원소 삽입 / 삭제 메소드(아래 메소드 중 리턴 타입이 boolean인 것들은 컬렉션에 변화를 주면 true를 리턴함, 변화가 없으면 false)
boolean add(E e)
boolean addAll(Collection<? extends E> c)
boolean remove(Object o) : 내부적으로 equals가 쓰임
boolean removeAll(Collection<?> c)
boolean retainAll(Collection<?> c) : 인자로 주어지는 컬렉션에 있는 원소만 남겨두고 나머지는 삭제
void clear( ) : 컬렉션의 모든 원소 삭제

원소 탐색 메소드
boolean contains(Object o) : 인자로 주어지는 것이 있는지, 내부적으로 equals가 쓰임
boolean containsAll(Collection<?> c) : 인자의 모든 원소가 존재하는지
boolean isEmpty( )

기타 메소드
int size( ) : 원소의 개수
int hashCode( ) : 두 컬렉션의 size와 순서가 같으면 hashCode 값도 같다. (해당 유형별로 equals 메소드로 인해 같다면)
Object[ ] toArray( ) : 원소들을 객체 배열로 리턴
Iterator<E> iterator( )
boolean equals(Object) : 컬렉션 자체가 같은지 비교하는 메소드

** HashSet, ArrayList, LinkedList 클래스
* HashSet 클래스 예제
import java.util.*;
public class HashSetTest {
	public static void main(String args[]) {
		Set<String> set = new HashSet<String>( );
		set.add("one"); set.add("two");
		set.add("three"); set.add("four");
		System.out.println(set.add(new String("one"))); // ★false를 리턴. Set은 중복 허용 불가
		System.out.println(set.size( )); // 4
		System.out.println(set.contains("four")); // true 리턴, String의 equals 메소드로 비교한다.
		System.out.println(set.contains("one")); // true
		System.out.println(set.contains(new String("one"))); // true
		set.remove("four");
		set.remove(new String("one"));
		System.out.println(set.size()); // 2
		set.clear( );
		System.out.println(set.size( )); // 0
	}
}
false
4
true
true
true
2
0

* ArrayList 클래스
List 인터페이스를 구현한 클래스
★크기 조절이 가능한 배열로 구현(여러 원소를 저장하기 위해 배열을 사용한다.)
같은 자료가 중복될 수 있으며, 입력된 순서대로 관리됨
특정 위치의 자료를 참조할 수 있음
List 인터페이스를 살펴봐야 함

* ArrayList 클래스의 메소드
boolean add(E e)
void add(index, E element) : 해당 index에 element 추가
boolean remove(Object o) : 삭제 성공하면 true, 실패 시 false 리턴
E remove(int index) : 삭제 후 삭제한 값 리턴
E get(int index)
E set(int index, E element) : 해당 index 값을 element로 대체하고, 대체된 값이 리턴됨
int indexOf(Object o) : 앞에서부터 o를 찾아서 o의 위치 리턴, ★없으면 -1 리턴
int lastIndexOf(Object o) : 뒤에서부터 찾음, 없으면 -1 리턴

* List<E> 인터페이스
순서가 있고 중복을 허용하는 구조
원소를 순차적으로 처리하는 구조
첨자에 의한, 특정 위치의 원소 처리가 가능

* List<E> 인터페이스의 메소드
int indexOf(Object o)
int lastIndexOf(Object o)
E set(int index, E element)
List<E> subList(int from, int to) : ★from부터 to-1까지의 list를 리턴
E remove(int index) : 해당 index의 값 삭제 후 그 값을 리턴
boolean remove(Object o) : 해당 객체 o를 찾아서 삭제
ListIterator<E> listIterator( ) : Iterator의 서브 인터페이스인 ListIterator. 리스트에 존재하는 원소들을 while문으로 다룸. ListIterator는 hasPrevious, previous도 가지고 있음.
ListIterator<E> listIterator(int index)

* ArrayList 클래스 예제
~~~
import java.util.*;
public class ArrayListTest {
	public static void main(String args[]) {
		List <String> list = new ArrayList <String> ( );
		list.add("one"); list.add("two");
		list.add("three"); list.add(1, "one"); //삽입
		list.add("five");
		System.out.println(list.size( )); // 5
		System.out.println(list.indexOf("one")); // 0
		System.out.println(list.get(2)); // two
		System.out.println(list.lastIndexOf("one")); // 1
		System.out.println(list.set(3, "four")); // ★three // E set(int index, E element) : 해당 index 값을 element로 대체하고, 대체된 값이 리턴됨
		System.out.println(list.remove(4)); // five // ★E remove(int index) : 삭제 후 삭제한 값 리턴
		System.out.println(list.remove("one")); // true // ★boolean remove(Object o) : 삭제 성공하면 true, 실패 시 false 리턴
	}
}
5
0
two
1
three
five
true

import java.util.*;
public class ArrayListTest2 {
	public static void main(String args[ ]) {
		List<String> list = new ArrayList<String>( );
		list.add("one");
		list.add("two");
		list.add("three");
		list.add("four");
		list.add("five");
	// for 구문을 이용한 자료 탐색
		for (int i = 0; i < list.size( ); i++)
			System.out.println(list.get(i));
	// ★foreach 구문을 이용한 자료 탐색
		for (String s : list)
			System.out.println(s);
	// ★Iterator 인터페이스를 이용한 자료 탐색
		Iterator<String> it = list.iterator();
		while (it.hasNext( ))
			System.out.println(it.next( ));
	}
}

* ★★★람다식 이용
import java.util.*;
import java.util.function.Consumer;
public class ArrayListTest {
	public static void main(String args[ ]) {
		List <String> list = new ArrayList<String>( );
		list.add("one"); list.add("three");
		list.add("two"); list.add(1, "one");
		Consumer<String> con1 = new Consumer<>() { // ★익명 클래스
			public void accept(String t) { // accept 메소드를 구현함
				System.out.println(t); // 하나의 인자를 받아서 바로 출력
			}
		};
		list.forEach( con1 ); // ★★forEach : 개별 객체 다룰 수 있음. 인자로 Consumer 인터페이스를 구현한 클래스의 객체가 들어감, list는 Iterable 객체

		Consumer<String> con2 = t -> System.out.println(t); // ★★람다식, 위에걸 좀 더 축약한 것
		list.forEach( con2 );

		list.forEach( t -> System.out.println(t) ); // ★★위에 것을 더 축약한 것
	}
}
~~~

* Iterator<E> 인터페이스
컬렉션에 저장된 원소를 차례대로 다룰 수 있음
다음 메소드를 제공 / boolean hasNext( ), E next( ), void remove( ) : 마지막 원소 삭제
HashSet, ArrayList, LinkedList 등(★Iterable)에서 Iterator 객체를 리턴하는 메소드가 정의됨

List <String> list = new ArrayList <String> ( ); // ★Iterable
Iterator <String> it = list.iterator( );
while(it.hasNext( ))
	System.out.println(it.next( ));
Scanner 객체도 Iterator 인터페이스를 구현한 유형

* LinkedList(연결 리스트) 클래스
1. ArrayList와 마찬가지로 List 인터페이스를 구현한 클래스
앞의 예제에서 ArrayList를 LinkedList로 바꿔도 됨

2. Queue 인터페이스를 구현함
스택 자료구조에서 필요한 메소드도 제공함
void push(E), E pop( ) //앞에서 넣거나 뺌

★Queue 인터페이스의 메소드
boolean offer(E) // 뒤에 넣고(삽입), poll과 짝. add와 다른 점은 Queue가 꽉차서 더 이상 삽입할 수 없을 때도 예외를 발생시키는 것이 아니라 false를 리턴함
boolean add(E) // 뒤에 넣고(삽입), remove와 짝, Queue가 꽉차면 Exception 발생
E poll( ) // 앞에서 빼고(삭제), offer와 짝, 더 이상 삭제할 것이 없으면 null을 리턴하고, 정상적으로 삭제되면 삭제된 원소가 리턴
E remove( ) // 앞에서 빼고(삭제), add와 짝, 더 이상 삭제할 것이 없으면 예외 발생(NoSuchElementException)
E peek( ), E element( ) : 대기열의 맨 앞에 있는 원소를 삭제하는 것이 아니라 해당 값만 리턴함

* LinkedList를 이용하여 큐를 구현한예제
import java.util.*;
public class QueueTest {
	public static void main(String args[]) {
		LinkedList<String> queue = new LinkedList<String>( ); // ★이거 잘못됨. 아래와 같이 써야함
		Queue<String> queue = new LinkedList<String>();
		queue.offer("one"); queue.offer("two");
		queue.offer("three"); queue.offer("four");
		String s = queue.poll( );
		while (s != null) {
			System.out.println(s);
			s = queue.poll( ); // ★★마지막에 null을 리턴하여 while문을 빠져나감
		}
	}
}
one
two
three
four

** HashMap 클래스
* Map<K, V> 인터페이스
(key, value)을 갖는 원소로 구성되는 컬렉션을 다루기 위한 인터페이스
key는 중복되지 않으며, 하나의 key에 하나의 value만 대응됨

메소드
V put(K key, V value) : ★만약 이미 해당 key가 있으면 그 key에 해당하는 value값이 put으로 전달한 value 값으로 바뀌게 된다.
V get(Object key)
V remove(Object key)
boolean containsKey(Object key)
Collection<V> values( ) : ★컬렉션이 아니기 때문에 탐색 방법이 다름. value들로만 이루어진 컬렉션을 리턴
Set<K> keySet( ) : ★키들로 이루어진 Set을 리턴. key들은 중복되지 않기 때문에 Set이 리턴

* HashMap 클래스
해싱을 이용하여 Map 인터페이스를 구현한 클래스
자료 탐색 방법이 ArrayList나 LinkedList 클래스와 다름
복잡한 자료 관리(교재의 예)
1. 명단
names = ArrayList<이름> 객체
김철수, 이영희

2. 성적부
scores = HashMap<이름, 성적 객체
<김철수, 개별 성적 Map>
<이영희, 개별 성적 Map>

3. 개별 성적
lectures = HashMap<과목, 점수> 객체
국어 100
영어 95
등
자세한 것은 아래 코드를 보자

* 복잡한 자료관리-HashMap 클래스 예제
~~~
import java.util.*;
public class HashMapTest {
	public static void main(String args[ ]) {
		List <String> names = new ArrayList<String> ( ); // 명단
		Map <String, Integer> lectures; // 개별 성적
		Map <String, Map> scores = new HashMap<>( ); // 성적부
		names.add("김철수"); names.add("이영희");
		Iterator <String> it = names.iterator();
		while(it.hasNext( )) {
			String name = it.next();
			if (name.equals("김철수")) {
				lectures = new HashMap<String, Integer>( );
					lectures.put("국어", 100);
				lectures.put("영어", 95);
				lectures.put("수학", 80);
				scores.put(name, lectures);
			} else if (name.equals("이영희")) {
				lectures = new HashMap<String, Integer>( );
				… … …
				scores.put(name, lectures);
			}
		}

		Iterator <String> it2 = names.iterator( );
		while(it2.hasNext()) {
			String name = it2.next();
			System.out.println(name);
			System.out.print("국어 : ");
			System.out.println(
			scores.get(name).get("국어"));
			System.out.print("영어 : ");
			System.out.println(
			scores.get(name).get("영어"));
			System.out.print("수학 : ");
			System.out.println(
			scores.get(name).get("수학"));
			System.out.println( );
		}
	}
}
김철수
국어 : 100
영어 : 95
수학 : 80
이영희
… …
~~~
★위에서
Iterator <String> it2 = names.iterator( );
		while(it2.hasNext()) {
		}
부분을 아래와 같이 변경 가능
for (String name : scores.keySet()) {}


* 컬렉션은 여러 원소를 하나의 그룹으로 묶은 객체를 통칭하는 용어이며, JCF는 컬렉션을 표현하고 다루기 위한 통합 프레임워크이다.
* Set은 순서는 상관없지만 중복을 허용하지 않는 자료를 다루기 위한 인터페이스이다.
* List와 Queue는 자료의 중복을 허용하고 순서를 고려하여 관리하는 인터페이스이다. 특히 Queue는 FIFO 방식으로 자료를 관리하는 인터페이스이다.
* Map 인터페이스는 <키, 값>의 쌍으로 구성되는 자료를 관리하는 메소드를 제공한다.
* LinkedList 클래스는 List 인터페이스와 Queue 인터페이스를 모두 구현한 클래스로서, 스택 자료구조의 구현에 사용할 수도 있고, 큐 자료구조의 구현에 사용할 수도 있다.



*****************************************************************************
12강. 멀티 스레드 프로그래밍
*****************************************************************************

* 스레드
프로세스와 스레드
Java 프로그램은 하나의 프로세스로 만들어져 실행됨
프로세스는 실행 중인 프로그램(여러 프로그램이 실행되는 것은 멀티 태스킹)
지금까지는 프로세스에서 하나의 스레드가 생성되고 main( ) 메소드가 호출되어 실행됨(단일 스레드)
스레드는 실행 중인 프로그램 내에 존재하는 소규모 실행 흐름
스레드는 경량 프로세스

* 멀티 스레드(하나의 프로세스 안에서 동시에 실행되는 여러 개의 실행 흐름(실행 흐름 하나를 스레드). 이번 강의에서 다루는 것은 여러 프로세스가 아니고, 하나의 프로세스 안의 멀티 스레드)
하나의 프로세스 내부에서 여러 스레드가 만들어져 동시 실행될 수 있음
Java 프로그램은 하나의 스레드(main 스레드)로 시작됨
main 스레드에서 자식 스레드를 만들어 시작시킬 수 있음
그러면 여러 스레드가 동시에 독립적으로 실행되고 종료됨

* Thread 클래스
스레드의 생성과 관리를 위한 메소드를 제공
스레드 생성을 위해 Thread 유형의 객체가 필요함

생성자
Thread( )
Thread(String name) : 스레드 이름(이름 안 줘도 되고, 안 주면 Thread-0 이런 식으로 이름 붙음)
Thread(Runnable target) : Runnable객체
Thread(Runnable target, String name) : Runnable객체, 스레드 이름
Runnable 인터페이스를 구현하려면 run( )을 구현해야 함

* 스레드 생성과 실행
Thread 유형의 객체 t를 생성
★t.start( )를 호출하면 스레드 실행이 시작됨(start()는 run( ) 메소드를 호출함, 스레드를 실행한다는 것은 결국 run메소드를 실행한다는 거이 됨. run메소드 내용이 스레드의 실행코드임)
void run( ) 메소드에 스레드의 실행 코드가 있음
run( )을 정의하는 두 가지 방법이 있음. 즉, 스레드를 실행시키는 두 가지 방법이 있음

* ★★스레드실행방법1 –Thread 클래스의상속
Thread 클래스를 상속받는 클래스 A를 정의
★여기서 run( ) 메소드를 재정의 // Thread 클래스에서 run메소드가 정의되어 있지만 하는 일은 없음
A 유형의 객체를 생성하고 start( )를 호출함
class MyThread1 extends Thread {
	public void run( ) {
		for (int i = 0; i < 10; i++)
			System.out.println(getName( )); // 스레드의 이름을 출력
	}
}
public class ThreadTest1 {
	public static void main(String args[ ]) {
		Thread t1 = new MyThread1( ); t1.start( ); // 결론적으로 MyThread1에 있는 run메소드가 실행됨, 객체 생성 시 스레드 이름을 주지 않았기 때문에 Thread-0
		Thread t2 = new MyThread1( ); t2.start( ); // Thread-1
		System.out.println("main"); // main스레드가 아닌 main스레드에서 추가로 생성한 스레드가 자신의 이름을 10번 출력하고, 또 생성한 다른 스레드 역시 자신의 이름을 10번 출력. 그리고 "main" 출력. 그런데 이 3개의 스레드는 순서를 예상할 수 없음. 별개의 흐름이기 때문. 그래서 "main"이 맨 마지막에 출력된다는 보장이 없음
	}
}

* ★★스레드실행방법2 –Runnable 인터페이스를구현 // 1번과 차이점은 ★추가로 다른 클래스를 extends 가능
Runnable 인터페이스를 구현하는 클래스 B를 정의
여기서 run( ) 메소드를 구현
B의 객체를 인자로 사용하여 Thread 유형의 객체를 생성하고 start()를 호출함
class MyThread2 implements Runnable {
	public void run( ) {
		for (int i = 0; i < 10; i++)
			System.out.println(Thread.currentThread( ).getName( )); //★현재 스레드의 참조값을 얻어와서 getName() // 스레드실행방법1처럼 Thread 클래스를 상속받는 경우에는 그냥 getName()
	}
}
public class ThreadTest2 {
	public static void main(String[ ] args) {
		Thread t1 = new Thread(new MyThread2( ), “thd0”); t1.start( ); // Thread 클래스의 생성자 중 Thread(Runnable target, String name) 쓰임. Runnable target : Runnable을 구현한 클래스의 객체
		Thread t2 = new Thread(new MyThread2( ), “thd1”); t2.start( );
		System.out.println(“main”);
	}
}

* 멀티스레드의 실행
멀티 스레드 프로그램의 실행 결과는 예측할 수 없음, 실행 결과가 매번 다를 수 있음
각 스레드는 정해진 순서 없이 독립적으로 실행됨
main 스레드는 다른 스레드를 시작시키나 다른 스레드의 실행과 무관하게 실행되고 종료됨

* 스레드의 상태
보통 1개의 CPU를 사용하여 여러 스레드가 수행됨
★★여러 스레드 중 하나의 스레드만 CPU를 얻어(확보해서) 실행되고 최종적으로 종료될 때까지 여러 상태 변화를 겪음. 여러 스레드가 하나의 CPU를 확보하기 위해 서로 경쟁하기 때문에 아래와 같이 스레드의 상태변화가 있음
Startable : 객체가 생성되었으나 start( )의 실행 전
Runnable : start( ) 메소드가 호출되었으나 CPU 획득 전
Running : CPU를 얻어 실행 중
Not Running : CPU를 잃고 중단된 상태(Blocked, Waiting, Timed_Waiting // 입력출 때문에 Blocked가 될 수도 있고, Waiting이 될 수도 있고, 시간이 다 되서 CPU를 내놓고 기다리고 있는 Timed_Waiting)
Dead : run( ) 메소드가 종료된 상태

* ★스레드의 상태 전이
Thread 클래스 -> 객체 생성 -> Startable 상태 -> start() -> Runnable 상태 -> CPU 얻음 -> Running -> wait() / sleep() : static메소드 / join() -> Not Running 상태 -> Dead 상태

Thread 클래스 -> 객체 생성 -> Startable 상태 -> start() -> Runnable 상태 -> CPU 얻음 -> Running -> CPU 잃음 / yield() : static메소드 -> Runnable 상태

Thread 클래스 -> 객체 생성 -> Startable 상태 -> start() -> Runnable 상태 -> CPU 얻음 -> Running -> wait() / sleep() / join() -> Not Running 상태 -> notify() / interrupt() -> Runnable 상태

Thread 클래스 -> 객체 생성 -> Startable 상태 -> start() -> Runnable 상태 -> CPU 얻음 -> Running -> run()의 종료 -> Dead 상태

위에서 static 메소드들은 Thread.sleep(), Thread.yield() 같이 쓰이고, join() 같은 건 t.join()과 같이 쓰임(t는 스레드 객체, t가 끝날때까지 기다리겠다는 의미)
wait()은 Object 클래스에서 정의되어 있는 메소드로 공유데이터를 다루고 있다가 어떤 이유로 점유권을 내놓고 Not Running 상태가 되는 것 / 공유데이터.wait()
notify() / notifyAll()도 Object 클래스에서 정의되어 있는 메소드

* ★스레드의 상태제어를위한 메소드(Thread 클래스의 메소드들)
void setPriority(int newPriority) : / 인스턴스 메소드 / 스레드의 우선순위를 변경. 높은 우선순위를 가지는 스레드가 CPU를 얻을 확률이 높음 // 10(높은 우선순위) / 5 / 1 / 정해주지 않으면 5가 됨

static void sleep(long millis) throws InterruptedException : 현재 실행 중인 스레드가 정해진 시간 동안 실행을 멈추고 Not Running 상태로 들어감. 인자에 1000을 주면 1초. 1초가 지나면 Runnable 상태로 감. 중간에 다른 스레드가 interrupt해서(InterruptedException) 바로 이 스레드가 Not Running에서 Runnable 상태로 갈 수 있음

static void yield( ) : 현재 실행중인 스레드가 잠시 실행을 잠시 멈추고 Runnable 상태로 들어감. CPU를 다른 스레드에게 양보하는 것

void join( ) throws InterruptedException // 인스턴스 메소드
메소드 join()은 this 스레드가 종료될 때까지 현재 스레드가 기다린다.
스레드가 종료될 때까지 기다림 / t.join();가 있으면 main 스레드가 t가 종료될 때까지 기다림
현재 실행 중이었던 스레드는 Not Running 상태로 들어감
void join(long millis)는 최대 millis 시간 동안 기다림 // ★위처럼 join()으로 하거나 join(0)으로 하면 무한히 기다림
기다리는 중에 다른 스레드가 이 스레드를 깨워주면(interrupt) InterruptedException을 받으면서 리턴되어 Not Running에서 Runnable로 감

void interrupt( )
스레드를 인터럽트시킴
스레드가 wait( ), join( ), sleep( )에 의해 중단된 상태였다면 그 상태에서 깨어나 Runnable 상태가 됨

* ★스레드상태제어를위한Object 클래스의메소드
void wait( ) throws InterruptedException // 무한히 기다리겠다는 말
void wait(long millis) throws InterruptedException
객체를 처리 중인 스레드를 정해진 시간 동안 중지시킴
다른 스레드가 해당 객체에 대해 notify( ) 메소드를 실행시켜 주면 이 스레드가 깨어날 수 있음
★이 메소드는 synchronized 메소드의 내부에서만 호출 가능 -> 객체의 감독권을 가지고 있는 스레드만 wait()를 호출할 수 있다는 얘기.  synchronized 메소드를 호출하고 있었다는 것은 공유데이터에 대한 감독권을 가지고 있는 상태라는 말.
synchronized 메소드를 어떤 스레드가 호출하고 있었다는 얘기는 그 스레드가 해당 데이터에 대해서, 다시 말해서
synchronized 메소드가 정의된 클래스가 있고 그 클래스 유형의 데이터를 작업중이었다고 하면, 그 스레드가 그 데이터에 대한 소유권을 가지고 있는데, 어떠한 이유로 그 소유권을 내놓고 다른 스레드가 그 데이터에 대해 작업할 수 있게 하는 것이 wait()
0~5까지의 재고량이 있다고 할 때, 생산 스레드는 재고가 5가 되면 wait를 해서 Not Running 상태가 되어야 하고, 소비자 스레드는 재고가 0이 되면 wait를 해서 Not Running 상태가 되어야 함. 재고가 생겨서 0보다 커지면, 즉 생산자가 생산을 해서 재고가 0보다 커지면 생산자가 notify를 해줘서 소비자를 깨워서 재고를 소진함. 그러면 다시 재고가 줄고 소비자가 생산자에게 notify하고. 반복 -> 생산자 / 소비자 동기화 모델
~~~
void notify( )
wait( )를 호출하여 중단된 스레드를 깨워줌(wait과 notify는 짝)
★이 메소드는 synchronized 메소드의 내부에서만 호출 가능

* 스레드의 상태 제어 예
class MyThread1 extends Thread {
	public void run( ) {
		for (int i = 0; i < 1000; i++) {
			System.out.println(getName( ));
			Thread.yield( ); // ★한 번 이름 출력하고 잠깐 쉬고. // 이거 때문에 t1과 t2의 이름이 yield를 쓰지 않은 것에 비해 골고루 섞여서 출력된다.
		}
	}
}

public class JoinTest2 {
	public static void main(String args[ ]) throws InterruptedException {
		Thread t1 = new MyThread1( ); t1.start( );
		Thread t2 = new MyThread1( ); t2.start( );
		t1.join( ); // t1이 종료될 때까지 기다리겠다. // ★이게 main 메소드에서 실행됐으니까, main 스레드가 t1이 종료될 때까지 기다리겠다는 말.
		t2.join( ); // t2가 종료될 때까지 기다리겠다. // 이게 main 메소드에서 실행됐으니까, main 스레드가 t2가 종료될 때까지 기다리겠다는 말.
		System.out.println("main"); // t1, t2가 종료된 이후 main이 출력됨
	}
}



class MyThread extends Thread {
	Thread thdNext = null;
	public MyThread(String szName)
		{ super(szName); }
	public void run() {
		for(int i = 0;i < 100;i++) {
			try {
				Thread.sleep(1000000);
			} catch(InterruptedException e) {
			System.out.print(getName( ) + " ");
			if(thdNext.isAlive( ))
				thdNext.interrupt( );
			}
		}
	}
	public void setNextThread(Thread t) { // 다음 스레드를 지정하는 메소드
		thdNext = t;
	}
}
public class Test6 {
	public static void main(String args[]) {
		MyThread my_thread1 = new MyThread("thd1");
		MyThread my_thread2 = new MyThread("thd2");
		MyThread my_thread3 = new MyThread("thd3");
		my_thread1.setNextThread(my_thread2);
		my_thread2.setNextThread(my_thread3);
		my_thread3.setNextThread(my_thread1);
		my_thread1.start(); my_thread2.start();
		my_thread3.start( );
		try {
			my_thread1.interrupt(); // InterruptedException을 받으면서 깨어남. 그리고 catch블럭이 실행됨
			my_thread1.join();
			my_thread2.join();
			my_thread3.join();
		} catch (InterruptedException e) {
			System.out.println(e);
		}
			System.out.println("main");
	}
}
~~~

** 스레드 동기화
* 스레드 간의 간섭
여러 개의 스레드들이 하나의 공유 객체에 동시 접근하는 경우 일관성이 깨짐

* ★★스레드 간의 간섭 예
~~~
class Counter {
	private int c = 0;
	public void increment( ) { c++; }
	public void decrement( ) { c--; }
	public int value( ) { return c; }
}

class MyThread3 implements Runnable {
	Counter c;
	public MyThread3(Counter c) {
		this.c = c;
	}
	public void run( ) {
		for(int i = 0;i < 100000;i++)
		c.increment( );
	}
}

class MyThread4 implements Runnable {
	Counter c;
	public MyThread4(Counter c) { this. c= c; }
	public void run( ) {
		for(int i = 0;i < 100000;i++)
			c.decrement( );
	}
}

public class ThreadTest3 {
	public static void main(String args[ ]) throws InterruptedException {
		Counter c = new Counter( );
		Thread t1 = new Thread(new MyThread3(c)); // new MyThread3(c) 객체가 가지고 있는 Counter 객체와 MyThread4 유형의 객체가 가지고 있는 Counter 객체가 같음 // MyThread3의 run메소드의 c와 MyThread4의 run메소드 c가 같음 -> c가 공유 자원이라는 말
		Thread t2 = new Thread(new MyThread4(c)); // new MyThread3(c) 객체가 가지고 있는 Counter 객체와 MyThread4 유형의 객체가 가지고 있는 Counter 객체가 같음 // MyThread3의 run메소드의 c와 MyThread4의 run메소드 c가 같음 -> c가 공유 자원이라는 말
		t1.start( ); t2.start( );
		t1.join( ); t2.join( );
		System.out.println(c.value( )); // ★최종적으로 c.value()해서 0이 나와야하는데, 두 개의 스레드 간에 간섭이 발생하기 때문에 0이 아닌 다른 값이 출력된다. -> 그래서 동기화가 필요하다. -> increment() 하는 동안은 다른 스레드가 c에 접근하지 못하게 막아야함.
	}
}
~~~

* 스레드 동기화
서로 다른 스레드들이 공유 자원을 다룰 때, 일관성을 유지하도록 하는 것
한 번에 오직 한 개의 스레드만이 해당 공유 객체에 접근하도록 동기화 함

방법(상호 배제 원칙)
키워드 synchronized
동기화 메소드 또는 동기화 블록을 제공
공유 자원을 수정할 때, 다른 스레드에서 같은 코드를 수행할 수 없게 함

* synchronized 메소드
한번에 하나의 스레드에 의해서만 실행 가능
synchronized 메소드를 실행하려면 메소드를 호출한 객체에 대한 lock을 얻어야 함
다른 스레드는 동일 객체에 대해 synchronized 메소드를 실행할 수 없게 됨

① public synchronized void func( ) { ... } // 메소드 전체

② 일부 블록만 동기화하는 것도 가능함 // 메소드 몸체 전체가 아니라 일부만
synchronized (객체) { ... } // 객체는 공유자원으로 대개 this

* ★★synchronized 메소드 사용 예
class Counter {
	private int c = 0;
	public synchronized void increment( ) { c++; } // ①
	public synchronized void decrement( ) { c--; } // ①
	public int value( ) { return c; }
}

class Counter {
	private int c = 0;
	public void increment( ) {
		synchronized(this) { c++; } // ②
	}
	public void decrement( ) {
		synchronized(this) { c--; } // ②
	}
	public int value( ) { return c; }
}

* 멀티 스레드 프로그래밍이란 하나의 프로세스에서 여러 스레드가 생성되어 동시 실행되게 하는 것을 말한다.
* 스레드의 실행 코드는 Thread를 상속받는 자식 클래스(또는 Runnable 인터페이스를 구현한 클래스)의 정의에 포함된 public void run() 메소드에 있다.
* Thread 클래스에서 스레드의 상태를 제어하는 메소드로 start(), join(), interrupt()가 있으며, static 메소드인 yield()와 sleep()도 있다. 한편 Object 클래스에 정의된 메소드로는 notify()와 wait()가 있다.
* 스레드 동기화는 데이터의 일관성을 유지하도록 한 번에 한 스레드만이 스레드 간 공유 객체에 접근하도록 하는 것이며, synchronized 메소드는 동기화를 보장한다.









*****************************************************************************
13강. AWT 컨트롤 클래스
*****************************************************************************

*** 윈도 프로그램 만들기
* 그래픽사용자인터페이스(GUI) : 윈도 프로그램 만들기라는 것은 결국 GUI 프로그래밍을 말함
그래픽 요소를 이용하여 사용자가 프로그램과 대화하는 방식의 인터페이스
텍스트 기반 or 명령 행 인터페이스(CLI)와 비교됨
GUI 프로그래밍을 위해 필요한 것
GUI 컴포넌트(★크게 컨트롤과 컨테이너로 나뉨. 컨트롤은 실제 사용자와 상호작용하는 GUI 컴포넌트. 컨테이너는 배치 관리를 담당) : 윈도우, 메뉴, 버튼, 레이블, 콤보박스, 체크박스, 텍스트필드, 스크롤바, 대화상자 등
컨트롤, 이벤트 발생과 처리 : 사용자 상호작용
컨테이너와 배치 관리자

* JFC(Java Foundation Class) : 자바기반으로 GUI 프로그래밍을 하기 위한 프레임워크
GUI를 만들거나 그래픽 처리를 위한 클래스 라이브러리로 AWT, Swing, Java2D, 룩앤필 지원 API 등을 제공 : JavaFX, 3D, Sound, Image 관련 API도 있음

* AWT(Abstract Window Toolkit) : AWT는 Java Foundation Class의 하나
AWT는 자바에서 처음 제공한 GUI용 API
주 패키지는 java.awt
운영체제의 윈도우 시스템을 사용함 : 중량 컴포넌트로 외양이 운영체제마다 다름(돌아가기는 하는데 외양이 다를 수 있다는 말이고, 위에 나왔던 Swing 같은 것은 경량 컴포넌트인데, 이건 어디에서도 외양도 같음)

* 윈도프로그램예
import java.awt.*;
class MyFrame extends Frame {
	public MyFrame(String title) { // 생성자
		super(title); // Frame의 제목 표시줄에 들어갈 문구 지정
		this.setSize(400, 300); // this는 new MyFrame("Hello AWT")을 의미
		this.setVisible(true); // ★이건 반드시 해야함. 이걸 해야 화면에 보임
	}
	public void paint(Graphics g) {
		g.drawString("Hello AWT", 150, 150); // Frame 안에 들어갈 문구
	}
}
public class HelloAWT2 {
	public static void main(String args[ ]) {
		MyFrame myFrame = new MyFrame("Hello AWT");
	}
}
------------------------------------
Hellow AWT	          _ ㅁ X
------------------------------------


	Hello AWT

------------------------------------
// 위와 같은게 Frame

* 윈도 프로그램 만들기
1. Frame 클래스를 상속받아 클래스를 정의
프레임은 제목표시줄, 경계(border 혹은 테두리라고도 함), 최소/최대/종료 버튼과 같은 윈도우 장식을 가짐

2. 생성자에서 윈도우의 주요 속성을 지정
제목을 인자로 받아 지정 : super(title);
가로와 세로 크기를 지정 : setSize(400, 300); // (너비, 높이), 단위는 픽셀
화면에 표시 : setVisible(true); // Frame의 경우 이걸 꼭 해야함

3. paint( ) 메소드에서 문자열을 출력 : paint( )는 일부러 호출하는 메소드가 아니라 해당 컴포넌트(여기서는 Frame)에 ‘다시 그리기’ 이벤트가 발생할 때 자동 호출되는 메소드(이런걸 콜백 메소드라고 함)

** ★GUI 컴포넌트
* AWT 패키지의 GUI 컴포넌트(클래스 형태로 제공. 즉 미리 만들어져 있다는 말)
1. 컨트롤 : 사용자와 실제 의사소통하는 GUI 컴포넌트(Button, Label, Canvas, Choice, Checkbox, Menu 등)
2. 컨테이너 : 하나 이상의 컨트롤을 포함하고 레이아웃을 관리(Panel, Frame, Window, Dialog 등. 컨테이너 안에 서브 컨테이너나 컨트롤들을 포함하기 때문에 컨테이너로 분류되는 컴포넌트는 컨트롤과 다르게 레이아웃이라는 속성을 가짐)
3. 기타 클래스
컴포넌트 배치 : BorderLayout, FlowLayout, GridLayout, CardLayout 등(배치관리자에 해당하는 클래스)
그래픽 출력 : Color, Font, Point, Graphics, Image 등

* 컴포넌트 클래스 계층구조(Menu관련 컴포넌트는 따로 클래스 계층 구조가 있음)
Component(추상 클래스) 밑에
Button, Canvas, Container, Checkbox, Choice, Label, TextComponent, List, Scrollbar(여기서 Container 빼고 다 Control)

Container 밑에
ScrollPane Panel Window

Window 밑에
Dialog(이거 밑에 FileDialog 있음), Frame

TextComponent 밑에
TextArea, TextField(얘네도 컨트롤)

* Component 클래스
메뉴를 제외한 AWT 컴포넌트들의 최상위 추상 클래스
이름, 기준 좌표, 크기, 배경색/전경색, 폰트, visible 속성, Graphics 객체와 같은 속성을 가짐
컴포넌트의 기본 메소드들을 정의
void paint(Graphics)
Container getParent( )
void setVisible(boolean b)
void setSize(int, int)
void setBackground(Color c)
… …

* 컨테이너
다른 컴포넌트를 포함하는 컴포넌트 : 컨트롤은 컨테이너에 포함되어야 함
최상위 클래스는 추상 클래스인 Container : 하위 컨테이너를 위한 기본 메소드를 제공
자식 컴포넌트들의 배치(위치와 크기)를 담당 : 컨테이너 안에 서브 컨테이너나 컨트롤들을 포함하기 때문에 컨테이너로 분류되는 컴포넌트는 컨트롤과 다르게 레이아웃이라는 속성을 가짐. 즉 배치 관리를 해야한다는 말
★컨테이너의 유형에 따라서 기본 배치 관리자를 가짐 : Frame의 경우 BorderLayout, Panel은 FlowLayout
★기본 배치 관리자가 있지만 배치 관리자를 변경할 수 있음 : void setLayout(LayoutManager)
자식 컴포넌트를 리스트 형태로 관리함 : 컨테이너에 추가되는 컴포넌트들은 순서지정이 없다면 맨 뒤에 들어감
Container 클래스에 자식 컴포넌트를 추가하는 메소드
Component add(Component comp) : 마지막에 추가 // 컨테이너.add(자식 컴포넌트)
Component add(Component comp, int index) : 지정된 위치(index)에 추가. index에 -1을 주면 맨 마지막에 추가됨. 즉 Component add(Component comp)은 index로 -1을 준것과 같다는 말
void add(Component comp, Object constraints) : 마지막에 추가, 두번째 인자는 배치 관리자에게 주는 정보. constraint는 제약, 제한이라는 뜻(사전적 의미)으로, 예를 들어 보더레이아웃을 쓸 경우, BorderLayout.CENTER 같은 값을 줘서 center에 배치되게끔 하는 것

* 최상위 수준 컨테이너
컴포넌트 간 포함 관계에서 루트가 되는 컨테이너 : 최상위 컨테이너를 제외한 모든 GUI 컴포넌트는 1개의 컨테이너에 포함됨
★★★Frame, Window, Dialog(사용자로부터 입력받는 form 등) 등 -> 이것들은 최상위 컨테이너로만 쓰임. 다른 컴포넌트와의 관계에서 다른 것들 밑에 안 들어간다는말

컨트롤은 자체로 존재할 수 없고 다른 컨테이너 밑에 있어야함

일반 컨테이너 : Panel, ScrollPane

Frame(컨테이너) 안에 Control과 Panel(컨테이너)이 있고, Panel 안에 Panel(컨테이너)과 컨트롤이 있을 수 있음. 그리고 그 Panel 안에 Control이 있을 수 있음

* Window 클래스(단순히 사각 영역만 제공하는 유형의 컴포넌트. 이 밑에 Frame과 Dialog 있음)
최상위 수준의 컨테이너 : 다른 컨테이너의 사각영역에 포함될 수 없음
Frame과 다르게 제목이나 테두리가 없으며 메뉴바를 가지지 않음(마우스로 이동이 안 됨)
생성자
Window(Frame owner), Window(Window owner) // owner, 즉 소유자에 의해 영향 받음. owner가 종료되면 Window도 같이 종료됨. owner에 해당하는 Frame이나 Window의 visible 속성이 false가 되면 따라서 false가 됨
기본 레이아웃은 BorderLayout

* Frame 클래스(최상위 컨테이너로 가장 많이 사용됨)
최상위 수준의 컨테이너 : 부모 컴포넌트를 가지지 못함
제목과 테두리가 있으며 메뉴바를 가질 수 있음
계층 구조에서 Window의 서브 클래스
생성자
Frame( )
Frame(String title) : 제목표시줄에 들어갈 문구
기본 레이아웃은 BorderLayout

* Window와 Frame 클래스 예
public class WindowFrame {
	public static void main(String args[]) {
		Frame f = new Frame("Frame"); // 제목표시줄에 들어갈 문구
		f.setSize(500, 400);
		f.setBackground(Color.white);
		f.setVisible(true);
		Window w = new Window(f) { // owner로 위에서 생성한 Frame 객체가 들어감
			public void paint(Graphics g) { // Window를 부모로 하는 익명 클래스 정의
				g.drawString("Window", 10, 50); // Window 영역이 정해지면(아래 보면 r을 통해 정해짐) Window의 (10, 50) 위치에 "Window"를 draw
			}
		};
		Rectangle r = new Rectangle(50, 50, 100, 100); // ★(x좌표, y좌표, 너비, 높이) // Frame 제목표시줄 모서리. 그러니까 창의 맨 왼쪽 모서리부터 시작해서 x좌표, y좌표에서 시작해서 너비, 높이 크기로)
		w.setBounds(r);
		w.setBackground(Color.yellow);
		w.setVisible(true); // 화면에 등장하게 되면서 다시그리기 이벤트가 발생이 되고, paint메소드가 자동 호출됨. paint는 Window 기준이기 때문에 Window의 시작 위치는 x좌표가 50, y좌표가 50이 시작위치(0, 0)가 되고, 거기서 이제 너비 10, 높이 50 위치에 문구 "Window"가 들어가는 것임
		w.toFront();
	}
}
------------------------------------
Frame       	          _ ㅁ X
------------------------------------

     ----------------
     l                 l
     l  Window     l
     l                 l
     ----------------	
	

------------------------------------

* fileDialog : 파일을 저장을 할 때, 또는 파일을 불러오기를 할 때 파일을 선택할 수 있게 하는 대화상자
fileDialog는 ★★모달 대화상자임. 모달은 입력을 독점하기 때문에 파일 관련 일만 화면에서 할 수 있음

** 메뉴
* 메뉴 클래스 계층 구조
Object - MenuComponent 밑에 MenuBar, MenuItem
MenuItem 밑에 Menu, CheckboxMenuItem
Menu 밑에 PopupMenu

* 풀다운 메뉴
제목 표시줄 밑의 메뉴바를 가짐
메뉴 만들기 과정(Menu를 디렉터리라고 생각하고, MenuItem을 파일이라고 생각하자)
1. MenuBar 객체 생성
2. MenuBar에 추가할 Menu객체를 생성
3. Menu에 추가할 또다른 서브 Menu객체나 MenuItem 객체를 생성하고 Menu에 붙임 - add( )
4. 생성한 Menu를 Menubar에 추가 – add( )
5. 프레임에 MenuBar를 붙임 - setMenuBar( ) // 프레임객체.setMenuBar()

import java.awt.*;
public class PulldownMenu {
	public static void main(String args[]) {
		Frame f = new Frame("Pulldown Menu");
		MenuBar mb = new MenuBar();
		Menu
		m = new Menu("Menu1");
		m.add(new MenuItem("MenuItem1"));
		Menu sm = new Menu("SubMenu1");
		sm.add(new MenuItem("SubMenuItem1"));
		sm.add(new MenuItem("SubMenuItem2"));
		m.add(sm);
		m.add(new MenuItem("MenuItem2"));
		mb.add(m);
		f.setMenuBar(mb); // 프레임에 MenuBar를 붙임
		f.setSize(200, 200);
		f.setBackground
		(Color.white);
		f.setVisible(true);
	}
}
-------------------------------------
Pulldown Menu                _ ㅁ X
-------------------------------------
Menu1
-------------------------------------
     MenuItem1
     SubMenu1 ㅡ SubMenuItem1
     MenuItem2    SubMenuItem2

-------------------------------------

* 체크박스 메뉴아이템 이란것도 있는 듯. 위에서 메뉴들 앞에 체크박스가 있음. 그걸 선택 혹은 해제하면 이벤트 발생

* 팝업 메뉴
★메뉴바가 없이 컨테이너 내부에서 어디든 나타남
메뉴 만들기
PopupMenu 객체를 생성한다
PopupMenu에 MenuItem이나 서브 Menu객체를 추가 – add( )
PopupMenu를 Frame에 추가 – add( )
★PopupMenu를 보이게 함 – show( )

** 배치 관리자의 사용
* 배치 관리자
일관성 있는 배치 관리 방법을 제공하는 클래스
모든 컨테이너는 기본 배치 관리자를 속성으로 가짐, 배치 관리자를 변경할 수 있음
★자식 컴포넌트의 크기와 위치를 자동으로 조정함, 컨테이너의 크기가 바뀌면 자식 컴포넌트들의 크기와 위치가 자동 재조정됨

자식 컴포넌트의 수동 배치(배치 관리자를 쓰지 않겠다는 말)
배치 관리자를 제거해야 함 : myContainer.setLayout(null) // 기본 관리 배치자를 변경할 때도 setLayout을 씀. 인자로 null을 주면 배치 관리자를 안 쓰겠다는 말
이후 크기와 위치를 수동 설정함 : setLocation(x, y), setSize(width, height)

* 배치 관리자의 종류
BorderLayout : 중앙, 동, 서, 남, 북에 배치함, 중앙이 크게 설정되고 나머지는 최소한으로 설정, Frame, Window, Dialog의 기본 배치 관리자

FlowLayout : 한 행에 순서대로 수평으로 배치(모자라면 다음 행에) 선호 크기(컴포넌트 유형에 따라, 즉, 버튼이냐 텍스트 필드냐 등에 따라서 preferred size가 있음)로 배치함, Panel의 기본 배치 관리자

GridLayout : 바둑판 모양으로, 격자 형식으로 배치, 컴포넌트 크기가 동일함(자식 컴포넌트의 유형이 달라고 컴포넌트 크기가 동일)

CardLayout : 한 번에 한 장의 카드(컴포넌트)를 보여줌

* BorderLayout
Center, East, West, South, North 영역에 배치
한 영역에 컴포넌트 1개만 배치함(하나의 자식 컴포넌트)
컴포넌트 사이의 수평/수직 간격을 지정할 수 있음
★컨테이너 크기를 확장하면 남북의 컴포넌트는 수평으로, 동서는 수직으로 확장됨. 중앙이 가장 커짐
생성자
BorderLayout(int hgap, int vgap) // 수평간격, 수직간격
예
aFrame.setLayout(new BorderLayout(30, 20));
aFrame.add(btn1, “North”); // aFrame은 컨테이너, btn1은 자식 컴포넌트, 북쪽에 배치
aFrame.add(btn2, BorderLayout.SOUTH); // 위보단 이걸로 하는게 정형화된 것

import java.awt.*;
public class BorderLayoutTest extends Frame {
	public BorderLayoutTest() {
		super("BorderLayout");
		setSize(300, 300);
		setLayout(new BorderLayout(10, 20));
		Label l_east = new Label("EAST", Label.CENTER); // Label은 컨트롤, Label.CENTER로 인해 문구가 중앙배치
		l_east.setBackground(Color.red);
		… … // SOUTH, WEST 등을 만들었다는 얘기
		Label l_center = new Label("CENTER", Label.CENTER);
		l_center.setBackground(Color.gray);
		add(l_east, BorderLayout.EAST); // this가 생략된 것 -> this.add(l_east, BorderLayout.EAST);
		add(l_south, BorderLayout.SOUTH);
		add(l_west, BorderLayout.WEST);
		add(l_north, BorderLayout.NORTH);
		add(l_center, BorderLayout.CENTER); // ★이런거 안 정해주면 기본적으로 전부다 중앙에 들어감. 그래서 마지막에 들어간 자식 컴포넌트만 화면에 보임
	}
	public static void main(String[ ] args) {
		Frame f = new BorderLayoutTest();
		f.setVisible(true);
	}
}
-----------------------------------------
BorderLayout                       _ ㅁ X
-----------------------------------------
                   NORTH
-----------------------------------------
        l                            l
WEST l         CENTER          l EAST
        l                            l
-----------------------------------------
                   SOUTH
-----------------------------------------

* FlowLayout
자식 컴포넌트를 한 줄에 차례로 배치
공간이 모자라면 다음 줄에 배치함
적정 크기(preferred size)로 배치함
중앙/좌/우로 정렬, 수평/수직 간격을 지정할 수 있음
생성자
FlowLayout( )
FlowLayout(int align, int hgap, int vgap)
align은 FlowLayout.LEFT, FlowLayout.RIGHT, FlowLayout.CENTER,
FlowLayout.LEADING, (앞으로 정렬. 즉 left to right일 경우에  FlowLayout.LEFT와 같음. right to left일 경우 xxx③②① 이런 순서가 기본)
FlowLayout.TRAILING (뒤에서부터 정렬. 즉 left to right일 경우 FlowLayout.RIGHT와 같음, right to left일 경우 ③②①xxx 이런 순서가 기본)
중 하나

import java.awt.*;
public class FlowLayoutTest extends Frame {
	public FlowLayoutTest( ) {
		super("FlowLayout");
		setSize(300, 100);
		setLayout(new FlowLayout(FlowLayout.RIGHT, 10, 0)); // 기본이 borderLayout인데 FlowLayout으로 바꿈, 수평 간격10, 수직 간격0, 우로 정렬(기본은 left to right)
		add(new Button("button1")); add(new Button("button2"));
		add(new Button("button3")); add(new Button("button4"));
		add(new Button("button5")); add(new Button("button6"));
	}
	public static void main(String[ ] args) {
		Frame f = new FlowLayoutTest( );
		f.setVisible(true);
	}
}
----------------------------------------
FlowLayout                         _ ㅁ X
----------------------------------------
    button1 button2 button3 button4
                          button5 button6



----------------------------------------
// FlowLayout.RIGHT 이기 때문에 우측 정렬

* GridLayout
바둑판 모양의 격자에 차례로 배치함
좌에서 우로(변경 가능), 위에서 아래로
자식 컴포넌트들의 크기는 동일
생성자
GridLayout(int rows, int cols, int hgap, int vgap)
rows : 행수(줄의 수)
cols : 열의 수
rows 또는 cols 중 하나가 0인 경우 임의 개수 가능

* CardLayout
자식 컴포넌트를 카드로 간주
한번에 하나의 카드만 보여줌
생성자
CardLayout(int hgap, int vgap)
메소드
void first(Container parent)
컨테이너의 첫 번째 카드를 보여줌(last()는 마지막 카드 보여줌)
void next(Container parent) // 다음것 보여줌(previous()는 전 것 보여줌)
void show(Container parent, String name)
add( )할 때 이름을 지정한 경우, 해당 이름의 카드를 보여줌
~~~

import java.awt.*;
public class CardLayoutTest extends Frame {
	CardLayout cl;
	public CardLayoutTest( ) {
		super("CardLayout");
		setSize(300, 100);
		cl = new CardLayout();
		setLayout(cl); // 기본 배치 관리자를 CardLayout으로 변경 // this가 생략. this.setLayout(cl);
		add( new Label("안녕하세요.", Label.CENTER));
		add( new Label("만나서 반가워요.", Label.CENTER));
		add( new Label("다음에 또 만나요.", Label.CENTER));
	}
	public void rotate( ) throws Exception{
		cl.first(this); // 여기서 cl은 프레임 객체가 가지고 있는 카드레이아웃 객체, this는 프레임 객체
		Thread.sleep(1000);
		while(true) {
		cl.next(this);
		Thread.sleep(1000);
		}
	}
	public static void main(String[ ] args) throws Exception {
		CardLayoutTest f = new CardLayoutTest( );
		f.setVisible(true);
		f.rotate( );
	}
}
~~~
안녕하세요. / 만나서 반가워요. / 다음에 또 만나요. // 이게 반복

* AWT는 Java에서 GUI를 만들기 위한 API를 제공한다.
* GUI 컴포넌트는 클래스 형태로 제공되며 컨트롤과 컨테이너로 분류된다.
* Frame 클래스는 테두리와 메뉴바를 가질 수 있으며 기본 배치 관리자로 BorderLayout을 사용한다.
* 컨테이너는 컨트롤이나 다른 컨테이너를 포함할 수 있는 컴포넌트로 배치관리자를 사용하여 자식 컴포넌트의 크기나 위치를 자동으로 조정한다.
* BorderLayout은 중앙/동/서/남/북에 자식 컴포넌트를 하나씩 배치하며, FlowLayout은 자식 컴포넌트를 한 줄씩 수평으로 배치하는 배치 관리자이다.









*****************************************************************************
14강. AWT 이벤트 처리하기
*****************************************************************************

** AWT 컨트롤 클래스
* Button 클래스
제목(또는 이름)이 있는 버튼을 표현
버튼을 눌렀을 때 이벤트 처리에 의해 액션을 수행할 수 있음
생성자와 메소드
Button( ),
Button(String label) // 버튼의 이름
void setLabel(String label) // 이름 바꾸기
String getLabel( ) // 이름 얻기
Component 클래스에서 상속받은 메소드
setVisible( ),
setBounds( ), // x좌표, y좌표, 너비, 높이
setEnabled( ) // 활성화, 비활성화
등

* Canvas : 그림을 그리거나 글자를 출력하거나 등의 사용자 정의 컨트롤을 만들 때 사용하는 사각 공간을 표현하는 클래스

* Checkbox 클래스
체크 박스를 표현
선택(true)/비선택(false) 또는 on/off 상태를 표현
생성자와 메소드
Checkbox( ), Checkbox(String label, boolean state) // String label : 체크박스의 이름, boolean state : 선택된 상태 혹은 선택되지 않은 상태로 표시 가능
Checkbox(String , boolean , CheckboxGroup) // 제목, 선택 상태, 체크박스그룹
같은 그룹의 체크박스들은 라디오 버튼처럼 동작. 즉, 하나의 체크박스만이 on 상태가 될 수 있음
void setLabel(String) String getLabel() // 제목을 바꾸거나 얻는거
void setState(booelan), // 체크된 상태로 표시할 수 있음
Boolean getState()

import java.awt.*;
public class CheckboxTest {
	public static void main(String[ ] args) {
		Frame f = new Frame("Checkbox");
		f.setLayout(new FlowLayout( )); // 기본 배치관리자를 FlowLayout( )로 바꿈
		f.add(new Checkbox("Whiskey")); // 상태를 지정하지 않으면 off 상태
		f.add(new Checkbox("Beer"));
		CheckboxGroup group = new CheckboxGroup( );
		f.add(new Checkbox("Yes", false, group)); // 화면에 라디오 버튼으로 보이게 됨
		f.add(new Checkbox("No", true, group));
		f.setSize(300, 80);
		f.setVisible(true);
	}
} 
------------------------------------------
Checkbox                              _ ㅁ X
------------------------------------------
ㅁWhiskey ㅁBeer     ○Yes ●No
------------------------------------------

* Choice 클래스
콤보 박스를 표현
선택할 아이템이 많은 경우 사용
하나를 선택할 수 있으며, 현재 선택된 것이 보임
메소드
void addItem(String item) // 항목추가. 마지막에 추가됨
void insert(String item, int index) // index에 추가됨 // 인덱스는 0부터 시작함
String getItem(int index)
int getSelectedIndex( )
String getSelectedItem( )

* List 클래스
하나 또는 여러 개의 아이템을 선택할 수 있게 함
선택할 아이템이 매우 많을 때 사용
★기본은 단일 선택이나 다중 선택 가능, 스크롤 가능
생성자와 메소드
List( ), // 한 번에 보여줄 아이템의 개수를 지정하지 않으면 4개가 기본 설정됨
List(int rows), // 한 번에 보여줄 아이템의 개수
List(int rows, boolean multipleMode) // 한 번에 보여줄 아이템의 개수와 다중 선택 여부를 지정(true로 하면 다중선택)
void add(String item), void add(String item, int index)
String getItem(int index)
int getSelectedIndex( ), int[ ] getSelectedIndexes( )
String getSelectedItem( ), String[ ] getSelectedItems( )

import java.awt.*;
public class ListTest {
	public static void main(String[ ] args) {
		Frame f = new Frame("List");
		List l = new List( );
		l.add("Red");
		l.add("Green");
		l.add("Blue");
		l.add("Yello");
		l.add("Cyan");
		f.add(l);
		f.setSize(200, 100);
		f.setVisible(true);
	}
} 

* Label 클래스 : 특정 영역에 문자열을 출력하기 위한 컴포넌트

* TextComponent 클래스(생성자를 제공하지 않음)
텍스트를 편집하거나 다루기 위한 컴포넌트
TextArea와 TextField의 부모 클래스
메소드
int getCaretPosition( ), void setCaretPosition(int position) : (편집 위치를 알려주는) 캐릿의 위치를 조회/설정
String getSelectedText( )
String getText( )
void select(int start, int end) : start부터 end-1까지 문자열을 선택 상태로 지정
void setText(String t)

* TextField 클래스
한 줄의 텍스트 편집을 위한 컴포넌트
여러 줄의 텍스트 편집에는 TextArea 클래스를 사용
생성자와 메소드
TextField(String text, int columns) : 초기 텍스트값, colums수
void setColumns(int cols), int getColumns( )
void setEchoChar(char c), char getEchoChar( ) : 비밀번호 등을 입력할 때 echo 문자를 '*' 등으로 설정
void setText(String text)

** 이벤트
* 이벤트(Event)
사용자가 GUI 컴포넌트를 사용하면서 발생시키는 행위 : 마우스 클릭, 버튼 누름, 키보드 입력, 메뉴 선택 등
이벤트는 종류별로 클래스로 정의되어 있음 : MouseEvent, ActionEvent, ItemEvent(리스트나 초이스에서 어떤 항목을 선택했을 때), KeyEvent(키보드 관련) 등

java.awt.event(패키지)
AWT 컴포넌트에서 발생하는 다양한 이벤트를 처리하기 위한 인터페이스와 클래스 제공
xxxEvent, // 클래스
xxxListener, // Event 클래스에 상응하는 Listener 인터페이스
xxxAdapter // Listener 인터페이스에 상응하는 Adapter 인터페이스

* 이벤트기반프로그래밍
무한루프를 돌면서 사용자의 행위로 인한 이벤트를 청취하여 응답하는 형태로 작동하는 프로그래밍
컴포넌트와 이벤트 발생
GUI 컴포넌트에서 여러 이벤트가 발생할 수 있음
이벤트 소스(Event Source) : 이벤트가 발생하는 컴포넌트를 이벤트 소스라고 함
컴포넌트마다 발생될 수 있는 이벤트가 정해져 있음
Button의 경우 발생 가능한 이벤트 : ActionEvent, ComponentEvent, FocusEvent, KeyEvent, MouseEvent
ActionEvent가 발생할 수 있는 컴포넌트 : Button, List, MenuItem, TextField

* 이벤트 처리 방식
위임형 이벤트 처리 모델 : 이벤트 리스너 객체에 이벤트 처리를 위임함(컴포넌트(이벤트 소스)에 이벤트가 발생했을 때, 컴포넌트에 등록된 리스너 객체를 통해 이벤트 처리 코드를 실행함)
모든 컴포넌트는 이벤트 소스가 될 수 있음 : 이벤트가 발생할 수 있다는 말
이벤트 소스에 이벤트 리스너 객체를 등록하는 방법
하나의 이벤트 소스에서 여러 다른 이벤트가 발생 가능하며, 이벤트 종류별로 각각 이벤트 처리를 등록해야 함
방법
★컴포넌트.addXxxListener (리스너객체); // 여기서 컴포넌트는 이벤트 소스, 리스너객체가 이벤트를 처리함

** 이벤트 클래스와 이벤트 리스너
* 이벤트 클래스와 리스너 인터페이스
이벤트 클래스
이벤트는 클래스(xxxEvent)로 분류되어 있음(MouseEvent는 마우스 클릭과 관련된 이벤트)
이벤트 클래스는 종류에 맞는 정보와 메소드를 가짐

리스너 인터페이스
이벤트 리스너 인터페이스는 이벤트 처리를 위한 인터페이스 : 리스너 객체(리스너 인터페이스를 구현한 클래스의 객체)는 이벤트 처리를 위임 받은 객체
이벤트 클래스에 1대1로 대응되는 인터페이스
예: WindowEvent - WindowListener, ItemEvent - ItemListener

* 이벤트 리스너 인터페이스
리스너 인터페이스에는 개별 이벤트를 처리하기 위한 메소드가 하나 또는 여러 개 존재함
★★2개 이상의 메소드를 가지는 인터페이스는 상응하는 이벤트 어댑터 클래스가 존재함(내가 관심있는건 하나의 메소드인데 그 외 것들까지 다 구현해야하면 낭비이므로, 인터페이스의 메소드들을 구현해놓은 어댑터 클래스가 있으니, 즉, 리스너 인터페이스를 구현하지말고, 그 어댑터를 상속받아서 써라)

이벤트 리스너 객체
★★이벤트 리스너 인터페이스를 구현한 클래스의 객체, 또는 이벤트 어댑터 클래스를 상속받은 클래스의 객체
★★frame.addWindowListner(xxx) : 먼저 윈도우리스너를 구현한 클래스를 정의하고, 근데 이때 7개의 메소드를 구현해야함. 그리고 그 객체를 xxx에 넣으면 됨. 그런데 위의 어댑터 설명에 의해, 7개의 메소드를 이미 구현한(빈 몸체기는 함) 어댑터가 있으니, 그 어댑터를 상속받는 클래스를 정의하고, 그 객체를 xxx에 넣어도 됨)

이벤트 처리를 담당함 : 적절한 메소드를 실행

* ★이벤트 클래스와 이벤트 발생(아래에 ☆표시된 클래스들은 상응하는 리스너 인터페이스에 메소드가 하나만 있음. 그래서 구현 시 하나의 메소드만 구현하면 되므로 어댑터 클래스가 존재하지 않음. 고수준 이벤트라고도 함. 다른것들은 저수준 이벤트)
☆ActionEvent : 버튼 클릭, ★리스트 항목을 더블 클릭, 메뉴 항목 선택, 텍스트필드에서 엔터키를 치는 경우(ActionListener)
☆AdjustmentEvent : 스크롤바를 조작할 때
ComponentEvent : 컴포넌트가 가려지거나 보일 때, 크기나 위치가 변할 때(ComponentListener)
ContainerEvent : 컨테이너에 자식 컴포넌트가 추가되거나 삭제될 때
FocusEvent : 입력 포커스를 얻거나 잃었을 때(FocusListener)
☆ItemEvent : 체크박스, 체크메뉴 항목, 초이스 항목, 리스트 항목을 선택하거나 해제할 때(ItemListener)
KeyEvent : 키보드가 누르거나 떼거나 타이핑할 때(KeyListener)
MouseEvent : 마우스 클릭, 마우스 포인터가 컴포넌트 위로 올라오거나 나갈 때, 마우스를 누르거나 뗄 때(MouseListener), 마우스가 움직이거나 드래깅 될 때(MouseMotionListener)
☆TextEvent : 텍스트컴포넌트에서 텍스트에 변화가 생겼을 때(TextListener)
WindowEvent : 윈도우의 시스템 버튼을 눌렀을 때(WindowListener)

* 이벤트리스너, 이벤트어댑터와메소드
☆ActionListener : actionPerformed(ActionEvent e)
☆AdjustmentListener : adjustmentValueChanged(AdjustmentEvent e)
ComponentListener / ComponentAdapter : componentHidden(ComponentEvent e), componentMoved(ComponentEvent e), componentResized(ComponentEvent e), componentShown(ComponentEvent e)
ContainerListener / ContainerAdapter : componentAdded(ContainerEvent e), componentRemoved(ContainerEvent e)
FocusListener / FocusAdapter : focusGained(FocusEvent e), focusLost(FocusEvent e)
☆ItemListener : itemStateChanged(ItemEvent e)
KeyListener / KeyAdpater : keyTyped(KeyEvent e), keyPressed(KeyEvent e), keyReleased(KeyEvent e)
MouseListener / MouseAdapter : mousePressed(MouseEvent e), mouseReleased(MouseEvent e), mouseEntered(MouseEvent e), mouseExited(MouseEvent e), mouseClicked(MouseEvent e)
MouseMotionListener / MouseAdapter : mouseMoved(MouseEvent e), mouseDragged(MouseEvent e)
☆TextListener : textValueChanged(TextEvent e)
WindowListener / WindowAdapter : windowOpened(WindowEvent), windowClosing(WindowEvent), windowClosed(WindowEvent), windowIconified(WindowEvent), windowDeiconified(WindowEvent) windowActivated(WindowEvent), windowDeactivated(WindowEvent)

** 이벤트 처리 방법
* 이벤트의 등록과 처리과정
필요한 클래스의 정의
이벤트 소스와 처리할 이벤트 종류를 결정
예 : Button에서 ActionEvent를 처리하고자 함 // 여기서 Button이 이벤트 소스, 처리하고자하는 이벤트 종류는 ActionEvent
상응하는 리스너 인터페이스를 구현하는 클래스를 정의
여기서 이벤트 처리를 위한 개별 메소드를구현함
개별 메소드가 이벤트를 처리하는 코드임
예 : ActionListener 를 구현하는 클래스 A를 정의하고
actionPerformed( )를 구현
상응하는 어댑터 클래스가 존재하면 어댑터 클래스를 상속 받는 클래스를 정의해도 됨
불필요한 메소드의 구현을 생략할 수 있음

이벤트 등록
리스너 객체를 생성하고 해당 이벤트 소스에
처리하고자 하는 이벤트를 등록함
예: aButton.addActionListener(new A( )); // 여기서 new A()는 ActionListener를 구현한 클래스의 객체
이벤트 처리
버튼을 누르면 ActionEvent가 발생함
등록되어 있는 이벤트 리스너 객체를 통해
void actionPerformed(ActionEvent ev)가 실행됨
이벤트 객체가 인자로 전달됨

* ★★이벤트 처리 예제
class MyFrame extends Frame {
	public MyFrame(String title) {
		super(title);
		this.setSize(400, 300);
		this.setVisible(true);
		//이벤트 리스너 등록
		this.addWindowListener(new MyListener( ));
	}
	public void paint(Graphics g) {
		g.drawString("Hello AWT", 150, 150);
	}
}
public class WindowEventTest {
	public static void main(String args[ ]) {
		MyFrame myFrame = new MyFrame("Hello AWT");
	}
}

import java.awt.*;
import java.awt.event.*;
// 이벤트 리스너 구현 // ★위 MyFrame 클래스 내에 있는 코드 중 this.addWindowListener(new MyListener( ));
class MyListener implements WindowListener {
	public void windowClosing(WindowEvent ev) { // ★★관심있는 메소드만 제대로 구현, 아래 나머지 6개는 그냥 빈 몸체로 구현. 그런데 이게 싫으면 아래 또 다른 예제처럼 어댑테 클래스를 사용하면 된다.
		System.exit(0);
	}
	public void windowActivated(WindowEvent ev) { }
	public void windowClosed(WindowEvent ev) { }
	public void windowDeactivated(WindowEvent ev) { }
	public void windowDeiconified(WindowEvent ev) { }
	public void windowIconified(WindowEvent ev) { }
	public void windowOpened(WindowEvent ev) { }
} 

* 어댑터 클래스 사용 예
import java.awt.*;
import java.awt.event.*;
//어댑터를 상속
class MyListener extends WindowAdapter {
	public void windowClosing(WindowEvent ev) {
		System.exit(0);
	}
}

** 이벤트 종류와 이벤트 처리
* ActionEvent와 ActionListener // ActionEvent를 처리하려면 ActionListener를 구현한 클래스가 있어야 하는데, actionPerformed만 구현하면 된다.
ActionListener 의 메소드
ActionEvent 발생은 명령의 실행을 의미함
void actionPerformed(ActionEvent ev) // ★★
버튼을 클릭하는 경우, 메뉴 항목을 클릭하는 경우, TextField에서 엔터키를 치는 경우, ★리스트의 항목을 더블 클릭하는 경우

ActionEvent 클래스의 메소드
String getActionCommand( ) : 명령의 이름을 리턴
Object getSource( ) : 부모인 EventObject 클래스에서 상속된 메소드 // 이벤트 소스에 해당하는 컴포넌트를 리턴

* WindowEvent와 WindowListener
WindowListener의 메소드
윈도우의 상태 변화를 야기하는 경우
void windowActivated(WindowEvent ev)
void windowClosed(WindowEvent ev)
……
WindowEvent의 메소드
int getNewState( ) // 0이면 정상 상태임
int getOldState( )
Window getWindow( )

* ItemEvent와 ItemListener
ItemListener 의 메소드
void itemStateChanged(ItemEvent ev)
Checkbox, CheckboxMenuItem, Choice, List에서 아이템을 선택하거나 해제하는 경우
ItemEvent의 메소드
Object getItem( )
선택/해제한 항목을 리턴
int getStateChange( )
ItemEvent.SELECTED, ItemEvent.DESELECTED

* ItemEvent 처리 예제
class MyListener implements ItemListener {
	public void itemStateChanged(ItemEvent ev) {
		String item = (String)ev.getItem( );
		System.out.print(item + "\t");
		if (ev.getStateChange( ) == ItemEvent.SELECTED)
			System.out.println("SELECTED");
		else
			System.out.println("DESELECTED");
	}
}

* MouseEvent와 리스너
MouseListener 의 메소드
void mouseClicked(MouseEvent ev)
void mouseEntered(MouseEvent e)
void mouseExited(MouseEvent e)
void mousePressed(MouseEvent e)
void mouseReleased(MouseEvent e)
MouseMotionListener 의 메소드
void mouseDragged(MouseEvent ev)
void mouseMoved(MouseEvent ev)

MouseEvent의 메소드
int getButton( )
상태를 바꾼 마우스 버튼을 리턴
MouseEvent.BUTTON1, // 왼쪽 버튼
MouseEvent.BUTTON2 또는 // 가운데 버튼
MouseEvent.BUTTON3 을 리턴 // 오른쪽 버튼
int getClickCount( ) : 클릭한 횟수를 리턴
Point getPoint( ) : 마우스의 x, y 좌표를 리턴
int getX( ), int getY( )

*  MouseEvent 처리 예제
class MyMouseListener extends MouseAdapter {
	public void mouseClicked(MouseEvent ev) {
		Point p = ev.getPoint( );
		String btn = null;
		switch(ev.getButton( )) {
			case MouseEvent.BUTTON1: btn = "Left Button";
				break;
			case MouseEvent.BUTTON2: btn = "Middle Button";
				break;
			case MouseEvent.BUTTON3: btn = "Right Button";
				break;
		}
		System.out.println("Mouse " + btn+ " clicked : " + p);
	}
}
Mouse Left Button clicked : java.awt.Point[x=81,y=35]
Mouse Right Button clicked : java.awt.Point[x=135,y=57]

* 윈도우 프로그램은 이벤트 기반 프로그래밍 방식으로 작성된다.
* 이벤트를 발생시킨 컴포넌트를 이벤트 소스라고 하고, 이벤트의 처리를 맡은 객체를 이벤트 리스너라고 한다.
* 한 컴포넌트에 여러 종류의 이벤트가 발생할 수 있는데, 발생 가능한 이벤트는 컴포넌트의 종류에 따라 다르다.
* 이벤트는 종류별로 클래스로 정의되었 있다. 예로 마우스 클릭과 관련된 이벤트들을 표현하는 MouseEvent라는 클래스가 있다.
* 특정 이벤트를 처리하기 위해 해당 리스너를 구현한 클래스를 정의하고, 객체를 생성하여 이벤트 소스에 이벤트 리스너로 등록한다.
* 이벤트 어댑터가 있는 경우 이벤트 리스너를 구현하는 대신 어댑터를 상속받는 클래스를 정의할 수 있다.









*****************************************************************************
15강. JDBC 프로그래밍
*****************************************************************************

** JDBC와 MySQL
* 데이터베이스 프로그래밍
JDBC(Java DataBase Connectivity) API(이건 껍데기고 아래 JDBC 드라이버가 필요)
Java 프로그램에서 관계형 데이터베이스를 사용하기 위한 API 규격
JDK의 일부로 포함되어 있음(java.sql)
데이터베이스에 연결하고, 데이터베이스에 대해 질의와 갱신
을 요청하고, 결과를 받기 위한 프로그래밍 방법을 제공

* JDBC 드라이버(자바 프로그램에서 보내는 데이터베이스 요청같은 것들을 DBMS가 이해할 수 있게 변환해주는 어댑터)
JDBC API는 DBMS 제조사가 제공하는 JDBC 드라이버를 통해 구현됨
사용하고자 하는 특정 DBMS의 JDBC 드라이버를 다운로드 받아 설치해야, JDBC API를 사용한 프로그램을 실행할 수 있음

* DBMS 설치
MySQL을 설치하기로 함
MySQL Community Server의 최신 버전을 설치
Oracle 회원 가입 필요
https://dev.mysql.com/downloads/에 접속
MySQL Installer for Windows를 클릭하면
Windows (x86, 32-bit), MSI Installer가 등장함
mysql-installer-community-8.0.23.0.msi
MySQL Installer 창의 Setup Type에서 “Server only”로 설치
설치 과정에서 root 계정의 암호를 입력하고 반드시 기억해야 함
기본적으로 이름이 MYSQL80인 Window Service로 등록됨

* MySQL의 사용
MySQL데몬(mysqld.exe)이 실행 중인지 확인
데몬을 실행하려면 “Windows 관리 도구”에서 “서비스” 이용
윈도우 시작 버튼 을 클릭하고 “서비스”를 타이핑하면 나옴
MySQL 8.0 Command Line Client 프로그램을 실행
시작 메뉴>MySQL>MySQL 8.0 Command Line Client
또는 명령 프롬프트 창에서 mysql –u root –p를 실행

Command Line Client를 실행하고, root 계정의 암호를 입력하여, MySQL 서버에 접속함
mysql> show databases;
mysql> create database test;
mysql> show databases;
mysql> use test;
mysql> create table book
-> ( title varchar(100),
-> author varchar(20),
-> price int);
mysql> show tables;
mysql> show columns from book;
mysql> insert into book values(‘데이터베이스’, ‘정재헌’, 200);
mysql> insert into book values(‘C 프로그래밍’, ‘홍길동’, 300);

mysql> select * from book;
+---------------+---------+----------+
| title | author | price |
+---------------+---------+----------+
| 데이터베이스 | 정재헌 | 200 |
| C 프로그래밍 | 홍길동 | 300 |
+---------------+---------+----------+
2 rows in set (0.00 sec)
mysql> update book set price=500 where author='정재헌';
Query OK, 1 row affected (0.02 sec)
Rows matched: 1 Changed: 1 Warnings: 0
mysql> delete from book where author='정재헌';
Query OK, 1 row affected (0.03 sec)
mysql> quit

* JDBC 드라이버 설치
DBMS 사이트에서 JDBC 드라이버를 다운로드 받아 설치함
MySQL을 사용하는 경우
https://dev.mysql.com/downloads/에 접속
Connector/J를 다운로드 받음
Platform Independent에서 zip파일을 다운 받음
이클립스 설정
Eclipse에서는 Project>Properties>Java Build Path>
Libraries>Classpath>Add External JARs…를 이용하여
mysql-connector-java-8.0.23.jar를 추가함

** JDBC 프로그래밍
* JDBC 프로그래밍 기본
JDBC 패키지를 import
import java.sql.*;
JDBC 드라이버를 동적으로 로드
Class.forName(com.mysql.cj.jdbc.Driver) 호출(최신 JDBC 버전에서는 생략해도 됨)
DBMS와 연결 설정 : DriverManager.getConnection( ) 호출
SQL 실행 : Connection, Statement, ResultSet 객체 사용(다 인터페이스)
연결 해제 : 사용 중인 데이터베이스 자원을 반납. finally 블록에서 close( ) 실행

* DBMS와 연결하기
DriverManager.getConnection( ) 메서드는 URL, 사용자 아이디, 비밀번호를 이용하여 MySQL 서버에 접속을 시도
성공하면 Connection 유형의 객체를 리턴
String url = "jdbc:mysql://서버주소:3306/db이름";
String user = "사용자아이디";
String password = "비밀번호";
Connection conn = DriverManager.getConnection(url, user, password); // ★

* select 구문의실행과결과받아오기
SQL 구문 실행 : Statement 객체를 생성하고 실행을 위해 executeQuery( )를 호출
★쿼리 결과 받기 : ResultSet 객체를 사용

★★아래에서 Statement 객체를 생성할 때는 인자가 없고, executeQuery( )를 통해 SQL 구문을 실행할 때 SQL 구문을 인자로 제공하는데, 곧 나올 preparedStatement랑 비교해봐야함
Statement stmt = conn.createStatement( ); // Statement 객체를 생성
ResultSet rs = stmt.executeQuery("select 속성명 from 테이블"); // ★executeQuery( )를 통해 SQL 구문 실행
while(rs.next( )) {
	System.out.println(rs.getString("속성명");
}
rs.close( ); stmt.close( ); conn.close( );

* insert/update/delete 구문의 실행
SQL 구문 실행
★Statement 객체를 생성하고 executeUpdate( )를 호출
★영향을 받은 행의 개수가 리턴됨(ResultSet이 아님)
Statement stmt = conn.createStatement( );
int resultCount = stmt.executeUpdate("insert into 테이블명 values(…)");
stmt.close( ); conn.close( );

* JDBC 프로그램 예제
★아래에서 ☆표시된 부분은 sql exception이 발생할 수 있기 때문에 예외처리를 한 것임 
~~~
import java.sql.*;
public class JDBCTest1 {
	public static void main(String[ ] args) {
		Connection conn = null; Statement stmt = null; ResultSet rs = null;
	try {
		// Class.forName("com.mysql.cj.jdbc.Driver").newInstance( ); // JDBC 드라이버를 동적으로 로드하고 드라이버 객체를 등록하는 부분으로 생략해도 됨
		String url = "jdbc:mysql://localhost/test";
		String user = "root";
		String pass = "비밀번호";
		☆conn = DriverManager.getConnection(url, user, pass); // DriverManager : 드라이버를 관래해주는 객체
		☆stmt = conn.createStatement( );
		☆rs = stmt.executeQuery("SELECT * FROM book");
		System.out.println("제목\t\t저자\t가격");
		while(rs.next( )) {
			System.out.print(rs.getString("title")+"\t");
			System.out.print(rs.getString("author")+"\t");
			System.out.println(rs.getInt("price")+"\t");
		}
	} catch (Exception ex) {
		System.out.println(ex);
	}
   ~~~
... ...
제목 저자 가격
데이터베이스 정재헌 200
C 프로그래밍 홍길동 300

** DatabaseMetaData 객체와 Statement 객체(이 이름들은 인터페이스 이름)
* DatabaseMetaData 객체
DBMS의 정보를 가지는 객체
객체는 Connection 객체의 getMetaData( ) 메소드로 생성됨
주요 메소드
String getDriverName( )
String getURL( )
String getUserName( )

* DBMS 정보 알아내기
import java.sql.*;
public class DatabaseMetaDataTest{
	public static void main(String[ ] args) {
		Connection conn = null;
	try {
		String url = "jdbc:mysql://localhost/test";
		String user = "사용자";
		String pass = "비밀번호";
		conn = DriverManager.getConnection(url, user, pass);
		DatabaseMetaData dbmd = conn.getMetaData( );
		String driver_name = dbmd.getDriverName( );
		System.out.println(driver_name);
		System.out.println(dbmd.getURL( ));
		System.out.println(dbmd.getUserName( ));
	} catch (Exception ex) {
		System.out.println(ex);
	}
… … 

* Statement 객체
SQL 구문을 실행하고 결과를 반환해 주는 객체
객체는 Connection 객체의 createStatement( ) 메소드를 통해 생성됨
주요 메소드
boolean execute(String sql)
★SQL 구문을 실행하며, select 구문을 실행하는 경우 true를 리턴
이어서 getResultSet( ) 또는 getUpdateCount( )를 호출함
stmt = conn.createStatement( );
if(stmt.execute("SELECT * FROM book")) rs=stmt.getResultSet( );
stmt = conn.createStatement( );
if(!stmt.execute("delete from book where …")) // 조건에 !가 들어간 것 주의
	System.out.println(stmt.getUpdateCount( )+ " 개의 행 삭제");

주요 메소드
ResultSet getResultSet( ) : SQL 구문(select 구문)을 실행한 결과를 리턴함
int getUpdateCount( ) : SQL 구문(select 구문 제외)의실행으로영향을 받은 행의 개수를 리턴함
ResultSet executeQuery(String sql)
★★select 구문을 실행할 때 사용
실행 결과를 나타내는 테이블인 ResultSet 객체를 리턴함
int executeUpdate(String sql)
update, insert, delete 구문을 실행할 때 사용
영향 받은 행의 개수를 리턴함

* Statement 객체의 사용 예
update, insert, delete 구문의 실행
Connection conn = DriverManager.getConnection(url, user, pass);
Statement stmt = conn.createStatement( );
int resultCount = stmt.executeUpdate("insert into book values (...)");
System.out.println(resultCount + " 개의 행이 삽입되었습니다.");
resultCount = stmt.executeUpdate("update book set name = value, ...");
System.out.println(resultCount + " 개의 행이 변경되었습니다.");
resultCount = stmt.executeUpdate("delete from book where ...");
System.out.println(resultCount + " 개의 행이 삭제되었습니다.");

** ResultSet 객체
* ResultSet객체
select 구문의 실행 결과를 나타내는 테이블
Statement 객체의 getResultSet()(execute 사용 시), executeQuery() 메소드가 리턴하는 객체
테이블에서 한 행을 가리키는 커서(행 단위로, 테이블에서 한 행을 가리키고 있음)를 가짐
select 구문을 실행하여 ResultSet 객체가 생성되면 커서가 만들어지고, select 구문의 실행 결과를 가리킴
커서는 행을 가리키는 포인터, 기본적으로 위에서 아래로 진행
★커서의 초기값은 첫 행의 직전 행을 가리킴

* ResultSet의 메소드
boolean next( ) : 커서를 다음 행으로 이동시킨다.
boolean previous( ) : 커서를 이전 행으로 이동시킨다.
Statement getStatement( ) : 현재 ResultSet을 생성시킨 Statement 객체를 리턴함

★★★ 아래에서 index는 첫 번째가 1임. 0이 아님
String getString(int index), String getString(Sring columnName) : ResultSet 객체에서 해당 열의 문자열을 리턴함
int getInt(int index), int getInt(Sring columnName) : ResultSet 객체에서 해당 열의 int 값을 리턴함

* ResultSet 객체의 사용예
try {
… …
		conn = DriverManager.getConnection(url, user, pass);
	stmt = conn.createStatement( );
	rs = stmt.executeQuery("SELECT * FROM book");
	System.out.println("제목\t\t저자\t가격");
	while(rs.next( )) {
		System.out.print(rs.getString(1)+"\t"); // ★첫 번째 컬럼의 값
		System.out.print(rs.getString(2)+"\t");
		System.out.println(rs.getInt(3)+"\t"); // ★getInt 주의
	}
	} catch (Exception ex) {
		System.out.println(ex);
	}
제목 저자 가격
데이터베이스 정재헌 200
C 프로그래밍 홍길동 300
삼국지 나승민 1000
Java 김준표 500

** PreparedStatement 객체와 ResultSetMetaData 객체(이 이름들은 인터페이스 이름)
* PreparedStatement 객체(PreparedStatement 인터페이스는 Statememt 인터페이스의 서브 인터페이스)
Precompile된 SQL 문을 표현
객체는 Connection 객체의 prepareStatement(String sql) 메소드를 통해 생성됨
★★★객체를 생성할 때 SQL 구문이 주어짐(SQL 구문을 실행할 때가 아님)
★그래서 같은 SQL 문을 여러 번 실행할 때 효율적임
SQL문에 매개 변수(?)를 사용하고, 실행 전에 값을 지정할 수 있음
String query = "insert into book values(?, ?, ?)";
ps = conn.prepareStatement(query);
ps.setString(1, "삼국지");
ps.setString(2, "나관중");
ps.setInt(3, 1000);
ResultCount = ps.executeUpdate( );

* PreparedStatement의주요메소드
boolean execute( )
ResultSet executQuery( )
int executeUpdate( )
인자가 없음
void setInt(int parameterIndex, int x)
void setString(int parameterIndex, String x)
SQL 구문에 있는 매개 변수(?)에 값을 지정
★SQL 구문에서 첫 번째 나온 ?의 인덱스가 1임

* PreparedStatement객체의사용예
try {
	… …
	conn = DriverManager.getConnection(url, user, pass);
	String query = "select * from book where price > ?";
	ps = conn.prepareStatement(query);
	ps.setInt(1, 100);
	rs = ps.executeQuery( );
	System.out.println("제목\t\t저자\t가격");
	while(rs.next( )) {
		System.out.print(rs.getString(1)+"\t");
		System.out.print(rs.getString(2)+"\t");
		System.out.println(rs.getInt(3)+"\t");
	}
	} catch (Exception ex) {
		System.out.println(ex);
	}

* DBMS와 Java의 자료형 변환
DBMS 테이블에서 열의 자료형과 Java의 자료형, 그리고 JDBC 메소드 간의 관계
DBMS 자료형 : CHAR String getString( ) setString( )
Java 자료형 : VARCHAR String getString( ) setString( )
ResultSet 메소드 : INTEGER int getInt( ) setInt( )
PreparedStatement 메소드 : DATE java.sql.Date getDate( ) setDate( )

* ResultSetMetaData 객체
ResultSet 객체에서 테이블의 이름, 열의 이름과 타입 정보를 얻을 때 사용되는 객체
ResultSet의 getMetaData( ) 메소드로 생성함
주요 메소드
String getColumnName(int index) : index 위치의 컬럼 이름을 리턴
int getColumnCount( ) : ResultSet의 컬럼 개수를 리턴
int getColumnType(int index) : index 위치의 컬럼 자료형을 리턴
String getTableName(int index) : index 위치의 컬럼을 포함하는 테이블의 이름을 리턴

* ResultSetMetaData 객체의 사용 예
~~~
try {
	… …
	conn = DriverManager.getConnection(url, user, pass);
	String query = "select * from book"; ps = conn.prepareStatement(query);
	rs = ps.executeQuery( );
	ResultSetMetaData rsmd = rs.getMetaData( );
	int colCount = rsmd.getColumnCount( );
	for(int i = 1;i <= colCount;i++) {
		System.out.print(rsmd.getColumnName(i) +"\t");
	}
	System.out.println( );
	while(rs.next( )) {
		for(int i = 1; i <= colCount; i++) {
			switch(rsmd.getColumnType(i)) {
				case Types.INTEGER:
					System.out.print(rs.getInt(i) + "\t");
					break;
				case Types.VARCHAR:
					System.out.print(rs.getString(i) + "\t");
					break;
			}
		}
		System.out.println( );
	}
} catch (Exception ex) { System.out.println(ex); }
~~~
title author price
데이터베이스 정재헌 200
C 프로그래밍 홍길동 300
삼국지 나관중 1000

* JDBC는 Java 프로그램에서 관계형 데이터베이스와 연동할 수 있게 하는 표준 API이다.
* DBMS와 연결을 설정할 때는 java.sql.Connection 객체를 사용한다.
* SQL 구문을 실행할 때 Statement 인터페이스의 execute(), executeQuery(), executeUpdate()를 사용한다.
* select 구문을 실행할 때 executeQuery()를 실행하며 검색 결과가 ResulteSet 객체로 리턴된다.
* 같은 SQL 문을 여러 번 실행할 때는 PreparedStatement 객체를 사용하는 것이 효율적이며, SQL 문에 매개변수를 사용하고 실행 전에 값을 지정할 수 있다.